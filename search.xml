<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《PHP基础教程（第4版）》</title>
      <link href="/2023/07/25/PHP%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89/"/>
      <url>/2023/07/25/PHP%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/527efa359c7d12f012639a10b4d00cdd.png" alt="《PHP基础教程（第4版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>由贾菡等编译的《PHP基础教程(第4版)》以通俗易懂的语言向初学者介绍了PHP语言的基本概念、使用方法和注意事项。全书通过丰富的示例，引领读者逐步掌握这门流行的Web开发语言，使读者能够上手编写适用于常用场景的PHP脚本。</p><p>《PHP基础教程(第4版)》适合有基本HTML经验的读者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Brian Halligan 市场营销软件开发公司HubSpot创始人兼CEO，致力于帮助其他企业“被目标客户找到”。他也是一位眼光超前的风险投资家、经验丰富的销售及营销主管，常应邀去MIT以及哈佛商学院举办讲座。</p><p>Dharmesh Shah HubSpot公司创始人兼CTO，天使投资人，撰写的博客OnStartups.com拥有大量粉丝。他还屡次应邀就市场营销以及企业家精神这类主题发表演说。</p><p>侯德杰 北京邮电大学英语专业，后取得北京交通大学项目管理硕士学位。目前就职于北京全路通信信号研究设计院，全职翻译和审核文档，曾翻译出版《网络营销实训》，对网络营销有较深入的研究。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1 章 PHP 概述　　 1<br>1.1 HTML 语法基础　　 1<br>1.2 PHP 语法基础　　6<br>1.3 使用FTP 　 8<br>1.4 测试脚本　　 9<br>1.5 向浏览器发送文本　　 12<br>1.6 使用PHP 手册　　14<br>1.7 向浏览器发送HTML 　　16<br>1.8 为脚本添加注释　　19<br>1.9 调试的基本步骤　　21<br>1.10 回顾和实践　　 22<br>第2 章 变量　　 24<br>2.1 什么是变量　　 24<br>2.2 变量语法　　 27<br>2.3 变量类型　　 29<br>2.4 为变量赋值　　 32<br>2.5 理解引号　　 34<br>2.6 回顾和实践　　 37<br>第3 章 HTML 表单和PHP 　　 38<br>3.1 创建简单的表单　　 38<br>3.2 选择表单的method　　 42<br>3.3 使用PHP 接收表单数据　　 44<br>3.4 显示错误　　 48<br>3.5 错误报告　　 51<br>3.6 向页面手动发送数据　　 53<br>3.7 回顾和实践　　 58<br>第4 章 使用数值　　 60<br>4.1 创建表单　　 60<br>4.2 算术运算　　 63<br>4.3 格式化数值　　 67<br>4.4 理解优先级　　 70<br>4.5 数值的自增和自减　　 72<br>4.6 创建随机数　　 75<br>4.7 回顾和实践　　 77<br>第5 章 使用字符串　　 78<br>5.1 创建HTML 表单　　 78<br>5.2 连接字符串　　 81<br>5.3 处理换行符　　 84<br>5.4 HTML 和PHP　　 85<br>5.5 字符串的编码和解码　　89<br>5.6 查找子字符串　　 92<br>5.7 替换局部字符串　　 96<br>5.8 回顾和实践　　 99<br>第6 章 控制结构　　100<br>6.1 创建HTML 表单　　 100<br>6.2 if 条件语句　　 104<br>6.3 验证函数　　 106<br>6.4 使用else 　　110<br>6.5 更多运算符　　112<br>6.6 使用elseif　　 121<br>6.7 switch 条件语句　　 125<br>6.8 for 循环　　 130<br>6.9 回顾和实践　　135<br>第7 章 使用数组　　136<br>7.1 什么是数组　　136<br>7.2 创建数组　　138<br>7.3 向数组添加项　　 141<br>7.4 访问数组元素　　 144<br>7.5 创建多维数组　　 148<br>7.6 数组排序　　 152<br>7.7 字符串和数组之间的转换　　156<br>7.8 在表单中创建数组　　160<br>7.9 回顾和实践　　165<br>第8 章 创建Web 应用程序　　166<br>8.1 创建模板　　 166<br>8.2 使用外部文件　　 175<br>8.3 使用常量　　180<br>8.4 使用日期和时间　　 184<br>8.5 再谈使用PHP 处理HTML 表单　　 188<br>8.6 使表单更具粘性　　 194<br>8.7 发送Email　　 201<br>8.8 输出缓冲　　205<br>8.9 处理HTTP 头　　 209<br>8.10 回顾和实践　　 213<br>第9 章 cookie 和session 　　214<br>9.1 什么是cookie　　 214<br>9.2 创建cookie　　 217<br>9.3 读取cookie　　 223<br>9.4 向cookie 添加参数　　 227<br>9.5 删除cookie　　 230<br>9.6 什么是session　　 233<br>9.7 创建session　　234<br>9.8 访问session 变量　　 237<br>9.9 删除session　　239<br>9.10 回顾和实践　　241<br>第10 章 创建函数　　243<br>10.1 创建和使用简单函数　　243<br>10.2 创建和调用接受参数的函数　　248<br>10.3 设置参数默认值　　 253<br>10.4 创建和使用带有返回值的函数　　 255<br>10.5 理解变量作用域　　 259<br>10.6 回顾和实践　　 264<br>第11 章 文件和目录　　265<br>11.1 文件权限　　265<br>11.2 写入文件　　270<br>11.3 锁定文件　　276<br>11.4 读取文件　　278<br>11.5 处理文件上传　　 281<br>11.6 导航目录　　288<br>11.7 创建目录　　293<br>11.8 增量读取文件　　298<br>11.9 回顾和实践　　 303<br>第12 章 数据库介绍　　305<br>12.1 SQL 介绍　　 305<br>12.2 连接MySQL 　307<br>12.3 MySQL 错误处理　　311<br>12.4 创建和选择数据库　　313<br>12.5 创建表　　316<br>12.6 向数据库插入数据　　320<br>12.7 安全查询数据　　325<br>12.8 从数据库中检索数据　　 328<br>12.9 删除数据库中的数据　　 333<br>12.10 更新数据库中的数据　　 338<br>12.11 回顾和实践　　 343<br>第13 章 将所有的组合在一起　　344<br>13.1 准备开始　　 344<br>13.2 连接数据库　　 346<br>13.3 编写用户定义函数　　 347<br>13.4 创建模板　　349<br>13.5 登录　　 352<br>13.6 登出　　 355<br>13.7 添加名人名言　　 357<br>13.8 列示名人名言　　 361<br>13.9 编辑名人名言　　 364<br>13.10 删除名人名言　　 370<br>13.11 创建主页　　 374<br>13.12 回顾和实践　　378<br>附录A 安装和配置　　379<br>附录B 深入学习PHP 的资源　　397</p><h3 id="PHP基础教程（第4版）-PDF-下载"><a href="#PHP基础教程（第4版）-PDF-下载" class="headerlink" title="PHP基础教程（第4版） PDF 下载"></a>PHP基础教程（第4版） PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1wYnMhDS5kqsgHKb9lSNC3w?pwd=cxu2">https://pan.baidu.com/s/1wYnMhDS5kqsgHKb9lSNC3w?pwd=cxu2</a> </p><p>提取码：cxu2</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 开发 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kubernetes in Action中文版》</title>
      <link href="/2023/05/24/Kubernetes%20in%20Action%E4%B8%AD%E6%96%87%E7%89%88/"/>
      <url>/2023/05/24/Kubernetes%20in%20Action%E4%B8%AD%E6%96%87%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/4311db6aa915c642bafafcf5873fd2d5.png" alt="《Kubernetes in Action中文版》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《Kubernetes in Action中文版》主要讲解如何在 Kubernetes 中部署分布式容器应用。《Kubernetes in Action中文版》开始部分概要介绍了 Docker 和Kubernetes 的由来和发展，然后通过在 Kubernetes 中部署一个应用程序，一点点增加功能，逐步加深我们对于Kubernetes架构的理解和操作的实践。在本书的后面部分，也可以学习一些高阶的主题，比如监控、调试及伸缩。 Kubernetes是希腊文，意思是“舵手”，带领我们安全地到达未知水域。Kubernetes这样的容器编排系统，会帮助我们妥善地管理分布式应用的部署结构和线上流量，高效地组织容器和服务。Kubernetes 作为数据中心操作系统，在设计软件系统时，能够尽量降低在底层网络和硬件设施上的负担。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Marko Luksa是一位拥有20年以上专业开发经验的软件工程师，经手项目小到简单的Web应用，大到ERP系统、框架和中间件软件，应有尽有。在为Red Hat工作期间，他从Google App Engine API实现的开发起步, 这些API将基于Red Hat的JBoss中间件产品，之后他一直在为CDI&#x2F;Weld、Infinispan&#x2F;JBoss DataGrid等项目贡献力量。2014后, 他加入Red Hat的Cloud Enablement团队，负责 Kubernetes和相关技术开发的更新，保障公司的中间件软件能将Kubernetes与OpenShift特性的潜能用到极致。 译者简介 七牛容器云 （KIRK）团队，是负责七牛云基于自身公有云业务在容器方面的多年实践经验，针对企业应用快速部署、便捷运维打造的容器云计算平台。提供持续集成、弹性伸缩、应用市场等功能特性，使企业专注于业务逻辑开发，缩短业务上线周期，优化资源利用率，提高服务响应效率的一支技术团队。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>1Kubernetes介绍1<br>1.1Kubernetes系统的需求2<br>1.1.1从单体应用到微服务2<br>1.1.2为应用程序提供一个一致的环境5<br>1.1.3迈向持续交付：DevOps和无运维6<br>1.2介绍容器技术7<br>1.2.1什么是容器7<br>1.2.2Docker容器平台介绍11<br>1.2.3rkt——一个Docker的替代方案14<br>1.3Kubernetes介绍15<br>1.3.1初衷15<br>1.3.2深入浅出地了解Kubernetes15<br>1.3.3Kubernetes集群架构17<br>1.3.4在Kubernetes中运行应用18<br>1.3.5使用Kubernetes的好处20<br>1.4本章小结22<br>2开始使用Kubernetes和Docker23<br>2.1创建、运行及共享容器镜像23<br>2.1.1安装Docker并运行HelloWorld容器24<br>2.1.2创建一个简单的Node.js应用26<br>2.1.3为镜像创建Dockerfile27<br>2.1.4构建容器镜像27<br>2.1.5运行容器镜像30<br>2.1.6探索运行容器的内部31<br>2.1.7停止和删除容器32<br>2.1.8向镜像仓库推送镜像33<br>2.2配置Kubernetes集群34<br>2.2.1用Minikube运行一个本地单节点Kubernetes集群34<br>2.2.2使用GoogleKubernetesEngine托管Kubernetes集群36<br>2.2.3为kubectl配置别名和命令行补齐39<br>2.3在Kubernetes上运行第一个应用40<br>2.3.1部署Node.js应用40<br>2.3.2访问Web应用43<br>2.3.3系统的逻辑部分45<br>2.3.4水平伸缩应用46<br>2.3.5查看应用运行在哪个节点上49<br>2.3.6介绍Kubernetesdashboard50<br>2.4本章小结51<br>3pod：运行于Kubernetes中的容器53<br>3.1介绍pod53<br>3.1.1为何需要pod54<br>3.1.2了解pod55<br>3.1.3通过pod合理管理容器56<br>3.2以YAML或JSON描述文件创建pod58<br>3.2.1检查现有pod的YAML描述文件59<br>3.2.2为pod创建一个简单的YAML描述文件61<br>3.2.3使用kubectlcreate来创建pod63<br>3.2.4查看应用程序日志64<br>3.2.5向pod发送请求65<br>3.3使用标签组织pod66<br>3.3.1介绍标签66<br>3.3.2创建pod时指定标签67<br>3.3.3修改现有pod的标签68<br>3.4通过标签选择器列出pod子集69<br>3.4.1使用标签选择器列出pod69<br>3.4.2在标签选择器中使用多个条件71<br>3.5使用标签和选择器来约束pod调度71<br>3.5.1使用标签分类工作节点72<br>3.5.2将pod调度到特定节点72<br>3.5.3调度到一个特定节点73<br>3.6注解pod73<br>3.6.1查找对象的注解74<br>3.6.2添加和修改注解74<br>3.7使用命名空间对资源进行分组75<br>3.7.1了解对命名空间的需求75<br>3.7.2发现其他命名空间及其pod75<br>3.7.3创建一个命名空间76<br>3.7.4管理其他命名空间中的对象77<br>3.7.5命名空间提供的隔离78<br>3.8停止和移除pod78<br>3.8.1按名称删除pod78<br>3.8.2使用标签选择器删除pod79<br>3.8.3通过删除整个命名空间来删除pod80<br>3.8.4删除命名空间中的所有pod，但保留命名空间80<br>3.8.5删除命名空间中的（几乎）所有资源80<br>3.9本章小结81<br>4副本机制和其他控制器：部署托管的pod83<br>4.1保持pod健康84<br>4.1.1介绍存活探针84<br>4.1.2创建基于HTTP的存活探针85<br>4.1.3使用存活探针86<br>4.1.4配置存活探针的附加属性87<br>4.1.5创建有效的存活探针88<br>4.2了解ReplicationController89<br>4.2.1ReplicationController的操作90<br>4.2.2创建一个ReplicationController92<br>4.2.3使用ReplicationController94<br>4.2.4将pod移入或移出ReplicationController的作用域97<br>4.2.5修改pod模板100<br>4.2.6水平缩放pod101<br>4.2.7删除一个ReplicationController103<br>4.3使用ReplicaSet而不是ReplicationController104<br>4.3.1比较ReplicaSet和ReplicationController104<br>4.3.2定义ReplicaSet105<br>4.3.3创建和检查ReplicaSet106<br>4.3.4使用ReplicaSet的更富表达力的标签选择器106<br>4.3.5ReplicaSet小结107<br>4.4使用DaemonSet在每个节点上运行一个pod107<br>4.4.1使用DaemonSet在每个节点上运行一个pod108<br>4.4.2使用DaemonSet只在特定的节点上运行pod109<br>4.5运行执行单个任务的pod112<br>4.5.1介绍Job资源112<br>4.5.2定义Job资源113<br>4.5.3看Job运行一个pod114<br>4.5.4在Job中运行多个pod实例114<br>4.5.5限制Jobpod完成任务的时间116<br>4.6安排Job定期运行或在将来运行一次116<br>4.6.1创建一个CronJob116<br>4.6.2了解计划任务的运行方式118<br>4.7本章小结118<br>5服务：让客户端发现pod并与之通信121<br>5.1介绍服务122<br>5.1.1创建服务123<br>5.1.2服务发现129<br>5.2连接集群外部的服务132<br>5.2.1介绍服务endpoint133<br>5.2.2手动配置服务的endpoint133<br>5.2.3为外部服务创建别名135<br>5.3将服务暴露给外部客户端136<br>5.3.1使用NodePort类型的服务137<br>5.3.2通过负载均衡器将服务暴露出来140<br>5.3.3了解外部连接的特性142<br>5.4通过Ingress暴露服务143<br>5.4.1创建Ingress资源145<br>5.4.2通过Ingress访问服务146<br>5.4.3通过相同的Ingress暴露多个服务147<br>5.4.4配置Ingress处理TLS传输149<br>5.5pod就绪后发出信号150<br>5.5.1介绍就绪探针151<br>5.5.2向pod添加就绪探针152<br>5.5.3了解就绪探针的实际作用154<br>5.6使用headless服务来发现独立的pod155<br>5.6.1创建headless服务156<br>5.6.2通过DNS发现pod156<br>5.6.3发现所有的pod——包括未就绪的pod157<br>5.7排除服务故障158<br>5.8本章小结159<br>6卷：将磁盘挂载到容器161<br>6.1介绍卷162<br>6.1.1卷的应用示例162<br>6.1.2介绍可用的卷类型164<br>6.2通过卷在容器之间共享数据165<br>6.2.1使用emptyDir卷165<br>6.2.2使用Git仓库作为存储卷168<br>6.3访问工作节点文件系统上的文件171<br>6.3.1介绍hostPath卷171<br>6.3.2检查使用hostPath卷的系统pod172<br>6.4使用持久化存储173<br>6.4.1使用GCE持久磁盘作为pod存储卷174<br>6.4.2通过底层持久化存储使用其他类型的卷177<br>6.5从底层存储技术解耦pod179<br>6.5.1介绍持久卷和持久卷声明179<br>6.5.2创建持久卷180<br>6.5.3通过创建持久卷声明来获取持久卷182<br>6.5.4在pod中使用持久卷声明184<br>6.5.5了解使用持久卷和持久卷声明的好处185<br>6.5.6回收持久卷186<br>6.6持久卷的动态卷配置187<br>6.6.1通过StorageClass资源定义可用存储类型188<br>6.6.2请求持久卷声明中的存储类188<br>6.6.3不指定存储类的动态配置190<br>6.7本章小结193<br>7ConfigMap和Secret：配置应用程序195<br>7.1配置容器化应用程序195<br>7.2向容器传递命令行参数196<br>7.2.1在Docker中定义命令与参数196<br>7.2.2在Kubernetes中覆盖命令和参数199<br>7.3为容器设置环境变量200<br>7.3.1在容器定义中指定环境变量201<br>7.3.2在环境变量值中引用其他环境变量201<br>7.3.3了解硬编码环境变量的不足之处202<br>7.4利用ConfigMap解耦配置202<br>7.4.1ConfigMap介绍202<br>7.4.2创建ConfigMap203<br>7.4.3给容器传递ConfigMap条目作为环境变量206<br>7.4.4一次性传递ConfigMap的所有条目作为环境变量208<br>7.4.5传递ConfigMap条目作为命令行参数209<br>7.4.6使用configMap卷将条目暴露为文件210<br>7.4.7更新应用配置且不重启应用程序216<br>7.5使用Secret给容器传递敏感数据218<br>7.5.1介绍Secret218<br>7.5.2默认令牌Secret介绍218<br>7.5.3创建Secret220<br>7.5.4对比ConfigMap与Secret221<br>7.5.5在pod中使用Secret222<br>7.6本章小结228<br>8从应用访问pod元数据以及其他资源229<br>8.1通过DownwardAPI传递元数据229<br>8.1.1了解可用的元数据230<br>8.1.2通过环境变量暴露元数据231<br>8.1.3通过downwardAPI卷来传递元数据234<br>8.2与KubernetesAPI服务器交互237<br>8.2.1探究KubernetesRESTAPI238<br>8.2.2从pod内部与API服务器进行交互242<br>8.2.3通过ambassador容器简化与API服务器的交互248<br>8.2.4使用客户端库与API服务器交互251<br>8.3本章小结253<br>9Deployment:声明式地升级应用255<br>9.1更新运行在pod内的应用程序256<br>9.1.1删除旧版本pod，使用新版本pod替换257<br>9.1.2先创建新pod再删除旧版本pod257<br>9.2使用ReplicationController实现自动的滚动升级259<br>9.2.1运行第一个版本的应用259<br>9.2.2使用kubectl来执行滚动式升级261<br>9.2.3为什么kubectlrolling-update已经过时265<br>9.3使用Deployment声明式地升级应用266<br>9.3.1创建一个Deployment267<br>9.3.2升级Deployment269<br>9.3.3回滚Deployment273<br>9.3.4控制滚动升级速率276<br>9.3.5暂停滚动升级278<br>9.3.6阻止出错版本的滚动升级279<br>9.4本章小结284<br>10StatefulSet：部署有状态的多副本应用285<br>10.1复制有状态pod285<br>10.1.1运行每个实例都有单独存储的多副本286<br>10.1.2每个pod都提供稳定的标识287<br>10.2了解Statefulset289<br>10.2.1对比Statefulset和ReplicaSet289<br>10.2.2提供稳定的网络标识290<br>10.2.3为每个有状态实例提供稳定的专属存储292<br>10.2.4Statefulset的保障294<br>10.3使用Statefulset295<br>10.3.1创建应用和容器镜像295<br>10.3.2通过Statefulset部署应用296<br>10.3.3使用你的pod301<br>10.4在Statefulset中发现伙伴节点305<br>10.4.1通过DNS实现伙伴间彼此发现306<br>10.4.2更新Statefulset308<br>10.4.3尝试集群数据存储309<br>10.5了解Statefulset如何处理节点失效310<br>10.5.1模拟一个节点的网络断开310<br>10.5.2手动删除pod312<br>10.6本章小结313<br>11了解Kubernetes机理315<br>11.1了解架构315<br>11.1.1Kubernetes组件的分布式特性316<br>11.1.2Kubernetes如何使用etcd318<br>11.1.3API服务器做了什么322<br>11.1.4API服务器如何通知客户端资源变更324<br>11.1.5了解调度器325<br>11.1.6介绍控制器管理器中运行的控制器327<br>11.1.7Kubelet做了什么331<br>11.1.8KubernetesServiceProxy的作用332<br>11.1.9介绍Kubernetes插件333<br>11.1.10总结概览335<br>11.2控制器如何协作335<br>11.2.1了解涉及哪些组件335<br>11.2.2事件链336<br>11.2.3观察集群事件337<br>11.3了解运行中的pod是什么339<br>11.4跨pod网络340<br>11.4.1网络应该是什么样的340<br>11.4.2深入了解网络工作原理341<br>11.4.3引入容器网络接口343<br>11.5服务是如何实现的344<br>11.5.1引入kube-proxy344<br>11.5.2kube-proxy如何使用iptables344<br>11.6运行高可用集群346<br>11.6.1让你的应用变得高可用346<br>11.6.2让Kubernetes控制平面变得高可用347<br>11.7本章小结350<br>12KubernetesAPI服务器的安全防护351<br>12.1了解认证机制351<br>12.1.1用户和组352<br>12.1.2ServiceAccount介绍353<br>12.1.3创建ServiceAccount354<br>12.1.4将ServiceAccount分配给pod356<br>12.2通过基于角色的权限控制加强集群安全358<br>12.2.1介绍RBAC授权插件359<br>12.2.2介绍RBAC资源360<br>12.2.3使用Role和RoleBinding363<br>12.2.4使用ClusterRole和ClusterRoleBinding367<br>12.2.5了解默认的ClusterRole和ClusterRoleBinding376<br>12.2.6理性地授予授权权限379<br>12.3本章小结379<br>13保障集群内节点和网络安全381<br>13.1在pod中使用宿主节点的Linux命名空间381<br>13.1.1在pod中使用宿主节点的网络命名空间382<br>13.1.2绑定宿主节点上的端口而不使用宿主节点的网络命名空间383<br>13.1.3使用宿主节点的PID与IPC命名空间385<br>13.2配置节点的安全上下文386<br>13.2.1使用指定用户运行容器387<br>13.2.2阻止容器以root用户运行388<br>13.2.3使用特权模式运行pod389<br>13.2.4为容器单独添加内核功能390<br>13.2.5在容器中禁用内核功能391<br>13.2.6阻止对容器根文件系统的写入392<br>13.2.7容器使用不同用户运行时共享存储卷394<br>13.3限制pod使用安全相关的特性396<br>13.3.1PodSecurityPolicy资源介绍396<br>13.3.2了解runAsUser、fsGroup和supplementalGroup策略398<br>13.3.3配置允许、默认添加、禁止使用的内核功能400<br>13.3.4限制pod可以使用的存储卷类型402<br>13.3.5对不同的用户与组分配不同的PodSecurityPolicy402<br>13.4隔离pod的网络406<br>13.4.1在一个命名空间中启用网络隔离406<br>13.4.2允许同一命名空间中的部分pod访问一个服务端pod407<br>13.4.3在不同Kubernetes命名空间之间进行网络隔离408<br>13.4.4使用CIDR隔离网络409<br>13.4.5限制pod的对外访问流量409<br>13.5本章小结410<br>14计算资源管理411<br>14.1为pod中的容器申请资源411<br>14.1.1创建包含资源requests的pod412<br>14.1.2资源requests如何影响调度413<br>14.1.3CPUrequests如何影响CPU时间分配418<br>14.1.4定义和申请自定义资源418<br>14.2限制容器的可用资源419<br>14.2.1设置容器可使用资源量的硬限制419<br>14.2.2超过limits421<br>14.2.3容器中的应用如何看待limits422<br>14.3了解podQoS等级423<br>14.3.1定义pod的QoS等级424<br>14.3.2内存不足时哪个进程会被杀死426<br>14.4为命名空间中的pod设置默认的requests和limits427<br>14.4.1LimitRange资源简介428<br>14.4.2LimitRange对象的创建428<br>14.4.3强制进行限制430<br>14.4.4应用资源requests和limits的默认值430<br>14.5限制命名空间中的可用资源总量431<br>14.5.1ResourceQuota资源介绍431<br>14.5.2为持久化存储指定配额434<br>14.5.3限制可创建对象的个数434<br>14.5.4为特定的pod状态或者QoS等级指定配额435<br>14.6监控pod的资源使用量436<br>14.6.1收集、获取实际资源使用情况437<br>14.6.2保存并分析历史资源的使用统计信息439<br>14.7本章小结442<br>15自动横向伸缩pod与集群节点443<br>15.1pod的横向自动伸缩444<br>15.1.1了解自动伸缩过程444<br>15.1.2基于CPU使用率进行自动伸缩447<br>15.1.3基于内存使用进行自动伸缩453<br>15.1.4基于其他自定义度量进行自动伸缩453<br>15.1.5确定哪些度量适合用于自动伸缩456<br>15.1.6缩容到0个副本456<br>15.2pod的纵向自动伸缩456<br>15.2.1自动配置资源请求457<br>15.2.2修改运行中pod的资源请求457<br>15.3集群节点的横向伸缩457<br>15.3.1ClusterAutoscaler介绍457<br>15.3.2启用ClusterAutoscaler459<br>15.3.3限制集群缩容时的服务干扰460<br>15.4本章小结461<br>16高级调度463<br>16.1使用污点和容忍度阻止节点调度到特定节点463<br>16.1.1介绍污点和容忍度464<br>16.1.2在节点上添加自定义污点466<br>16.1.3在pod上添加污点容忍度467<br>16.1.4了解污点和污点容忍度的使用场景467<br>16.2使用节点亲缘性将pod调度到特定节点上469<br>16.2.1指定强制性节点亲缘性规则470<br>16.2.2调度pod时优先考虑某些节点472<br>16.3使用pod亲缘性与非亲缘性对pod进行协同部署475<br>16.3.1使用pod间亲缘性将多个pod部署在同一个节点上475<br>16.3.2将pod部署在同一机柜、可用性区域或者地理地域478<br>16.3.3表达pod亲缘性优先级取代强制性要求479<br>16.3.4利用pod的非亲缘性分开调度pod481<br>16.4本章小结483<br>17开发应用的最佳实践485<br>17.1集中一切资源486<br>17.2了解pod的生命周期487<br>17.2.1应用必须预料到会被杀死或者重新调度487<br>17.2.2重新调度死亡的或者部分死亡的pod490<br>17.2.3以固定顺序启动pod491<br>17.2.4增加生命周期钩子493<br>17.2.5了解pod的关闭497<br>17.3确保所有的客户端请求都得到了妥善处理500<br>17.3.1在pod启动时避免客户端连接断开500<br>17.3.2在pod关闭时避免客户端连接断开501<br>17.4让应用在Kubernetes中方便运行和管理505<br>17.4.1构建可管理的容器镜像505<br>17.4.2合理地给镜像打标签，正确地使用ImagePullPolicy506<br>17.4.3使用多维度而不是单维度的标签506<br>17.4.4通过注解描述每个资源506<br>17.4.5给进程终止提供更多的信息507<br>17.4.6处理应用日志508<br>17.5开发和测试的最佳实践510<br>17.5.1开发过程中在Kubernetes之外运行应用510<br>17.5.2在开发过程中使用Minikube512<br>17.5.3发布版本和自动部署资源清单513<br>17.5.4使用Ksonnet作为编写YAML&#x2F;JSONmanifest文件的额外选择513<br>17.5.5利用持续集成和持续交付514<br>17.6本章小结515<br>18Kubernetes应用扩展517<br>18.1定义自定义API对象517<br>18.1.1CustomResourceDefinitions介绍518<br>18.1.2使用自定义控制器自动定制资源522<br>18.1.3验证自定义对象526<br>18.1.4为自定义对象提供自定义API服务器527<br>18.2使用Kubernetes服务目录扩展Kubernetes528<br>18.2.1服务目录介绍529<br>18.2.2服务目录API服务器与控制器管理器介绍530<br>18.2.3Service代理和OpenServiceBrokerAPI530<br>18.2.4提供服务与使用服务533<br>18.2.5解除绑定与取消配置535<br>18.2.6服务目录给我们带来了什么535<br>18.3基于Kubernetes搭建的平台536<br>18.3.1红帽OpenShift容器平台536<br>18.3.2DeisWorkflow与Helm539<br>18.4本章小结541<br>A在多个集群中使用kubectl543<br>B使用kubeadm配置多节点集群549<br>C使用其他容器运行时563<br>DClusterFederation567</p><h3 id="Kubernetes-in-Action中文版-PDF-下载地址"><a href="#Kubernetes-in-Action中文版-PDF-下载地址" class="headerlink" title="Kubernetes in Action中文版 PDF 下载地址:"></a>Kubernetes in Action中文版 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1WeU06FLqA0dFtOSO6Kj49Q?pwd=42h4">https://pan.baidu.com/s/1WeU06FLqA0dFtOSO6Kj49Q?pwd=42h4</a> </p><p>提取码：42h4</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Lua程序设计》</title>
      <link href="/2023/05/24/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/05/24/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cf9e4f3d7bd23092d0bd78cf82db10d1.png" alt="《Lua程序设计》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《Lua程序设计（第4版）》由Lua 语言作者亲自撰写，针对Lua 语言本身由浅入深地从各个方面进行了完整和细致的讲解。作为第4 版，《Lua程序设计（第4版）》主要针对的是Lua 5.3，这是《Lua程序设计（第4版）》撰写时Lua 语言的最新版本。作者从语言使用者的角度出发，讲解了语言基础、编程实操、高级特性及C 语言API 等四个方面的内容，既有Lua 语言基本数据类型、输入输出、控制结构等基础知识，也有对模块、闭包、元表、协程、延续、反射、环境、垃圾回收、函数式编程、面向对象编程、C 语言API 等高级特性的系统讲解，还有对Lua 5.3 中引入的整型、位运算、瞬表、延续等新功能的细致说明。 所有与Lua 语言打交道的人均能从《Lua程序设计（第4版）》受益，包括游戏、嵌入式、物联网、软件安全、逆向工程、移动互联网、C 语言核心系统开发等诸多领域中对Lua 语言有一般使用需要的从业人员，以及需要从编译原理或语言设计哲学和实现角度深入学习Lua 语言脚本引擎的高级开发者或研究人员。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第 1 部分 语言基础 1<br>1 Lua 语言入门 2<br>1.1 程序段 3<br>1.2 一些词法规范 5<br>1.3 全局变量 7<br>1.4 类型和值 7<br>1.4.1 nil 8<br>1.4.2 Boolean 8<br>1.5 独立解释器 10<br>1.6 练习 12<br>2 小插曲：八皇后问题 13<br>2.1 练习 15<br>3 数值 17<br>3.1 数值常量 17<br>3.2 算术运算 19<br>3.3 关系运算 21<br>3.4 数学库 21<br>3.4.1 随机数发生器 22<br>3.4.2 取整函数 22<br>3.5 表示范围 24<br>3.6 惯例 25<br>3.7 运算符优先级 26<br>3.8 兼容性 27<br>3.9 练习 28<br>4 字符串 30<br>4.1 字符串常量 31<br>4.2 长字符串&#x2F;多行字符串 33<br>4.3 强制类型转换 34<br>4.4 字符串标准库 36<br>4.5 Unicode 编码 39<br>4.6 练习 41<br>5 表 43<br>5.1 表索引 44<br>5.2 表构造器 46<br>5.3 数组、列表和序列 48<br>5.4 遍历表 50<br>5.5 安全访问 52<br>5.6 表标准库 53<br>5.7 练习 54<br>6 函数 56<br>6.1 多返回值 58<br>6.2 可变长参数函数 61<br>6.3 函数 table.unpack 64<br>6.4 正确的尾调用 65<br>6.5 练习 66<br>7 输入输出 68<br>7.1 简单 I&#x2F;O 模型 68<br>7.2 完整 I&#x2F;O 模型 72<br>7.3 其他文件操作 74<br>7.4 其他系统调用 75<br>7.4.1 运行系统命令 75<br>7.5 练习 77<br>8 补充知识 78<br>8.1 局部变量和代码块 78<br>8.2 控制结构 80<br>8.2.1 if then else 81<br>8.2.2 while 81<br>8.2.3 repeat 82<br>8.2.4 数值型 for 82<br>8.2.5 泛型 for 83<br>8.3 break、return 和 goto 84<br>8.4 练习 88<br>第 2 部分 编程实操 90<br>9 闭包 91<br>9.1 函数是第一类值 92<br>9.2 非全局函数 94<br>9.3 词法定界 96<br>9.4 小试函数式编程 100<br>9.5 练习 103<br>10 模式匹配 105<br>10.1 模式匹配的相关函数 105<br>10.1.1 函数 string.find 105<br>10.1.2 函数 string.match 106<br>10.1.3 函数 string.gsub 107<br>10.1.4 函数 string.gmatch 107<br>10.2 模式 108<br>10.3 捕获 112<br>10.4 替换 114<br>10.4.1 URL 编码 116<br>10.4.2 制表符展开 118<br>10.5 诀窍 119<br>10.6 练习 123<br>11 小插曲：出现频率最高的单词 124<br>11.1 练习 126<br>12 日期和时间 128<br>12.1 函数 os.time 129<br>12.2 函数 os.date 130<br>12.3 日期和时间处理 132<br>12.4 练习 134<br>13 位和字节 135<br>13.1 位运算 135<br>13.2 无符号整型数 136<br>13.3 打包和解包二进制数据 139<br>13.4 二进制文件 142<br>13.5 练习 144<br>14 数据结构 145<br>14.1 数组 146<br>14.2 矩阵及多维数组 146<br>14.3 链表 149<br>14.4 队列及双端队列 150<br>14.5 反向表 151<br>14.6 集合与包 152<br>14.7 字符串缓冲区 154<br>14.8 图形 156<br>14.9 练习 158<br>15 数据文件和序列化 159<br>15.1 数据文件 160<br>15.2 序列化 162<br>15.2.1 保存不带循环的表 165<br>15.2.2 保存带有循环的表 167<br>15.3 练习 169<br>16 编译、执行和错误 171<br>16.1 编译 171<br>16.2 预编译的代码 175<br>16.3 错误 177<br>16.4 错误处理和异常 179<br>16.5 错误信息和栈回溯 180<br>16.6 练习 182<br>17 模块和包 184<br>17.1 函数 require 185<br>17.1.1 模块重命名 187<br>17.1.2 搜索路径 188<br>17.1.3 搜索器 190<br>17.2 Lua 语言中编写模块的基本方法 190<br>17.3 子模块和包 193<br>17.4 练习 194<br>第 3 部分 语言特性 196<br>18 迭代器和泛型 for 197<br>18.1 迭代器和闭包 197<br>18.2 泛型 for 的语法 200<br>18.3 无状态迭代器 201<br>18.4 按顺序遍历表 203<br>18.5 迭代器的真实含义 205<br>18.6 练习 206<br>19 小插曲：马尔可夫链算法 208<br>19.1 练习 211<br>20 元表和元方法 212<br>20.1 算术运算相关的元方法 213<br>20.2 关系运算相关的元方法 216<br>20.3 库定义相关的元方法 217<br>20.4 表相关的元方法 219<br>20.4.1 __index 元方法 219<br>20.4.2 __newindex 元方法 220<br>20.4.3 具有默认值的表 221<br>20.4.4 跟踪对表的访问 222<br>20.4.5 只读的表 224<br>20.5 练习 225<br>21 面向对象（Object-Oriented）编程 226<br>21.1 类（Class） 228<br>21.2 继承（Inheritance） 230<br>21.3 多重继承（Multiple Inheritance） 232<br>21.4 私有性（Privacy） 235<br>21.5 单方法对象（Single-method Object） 237<br>21.6 对偶表示（Dual Representation） 238<br>21.7 练习 240<br>22 环境（Environment） 241<br>22.1 具有动态名称的全局变量 242<br>22.2 全局变量的声明 243<br>22.3 非全局环境 246<br>22.4 使用 _ENV 248<br>22.5 环境和模块 251<br>22.6 _ENV 和 load 252<br>22.7 练习 254<br>23 垃圾收集 255<br>23.1 弱引用表 255<br>23.2 记忆函数（Memorize Function） 257<br>23.3 对象属性（Object Attribute） 259<br>23.4 回顾具有默认值的表 260<br>23.5 瞬表（Ephemeron Table） 261<br>23.6 析构器（Finalizer） 262<br>23.7 垃圾收集器 266<br>23.8 控制垃圾收集的步长（Pace） 267<br>23.9 练习 268<br>24 协程（Coroutine） 270<br>24.1 协程基础 270<br>24.2 哪个协程占据主循环 273<br>24.3 将协程用作迭代器 276<br>24.4 事件驱动式编程 279<br>24.5 练习 284<br>25 反射（Reflection） 285<br>25.1 自省机制（Introspective Facility） 286<br>25.1.1 访问局部变量 288<br>25.1.2 访问非局部变量 289<br>25.1.3 访问其他协程 291<br>25.2 钩子（Hook） 292<br>25.3 调优（Profile） 293<br>25.4 沙盒（Sandbox） 296<br>25.5 练习 300<br>26 小插曲：使用协程实现多线程 301<br>26.1 练习 306<br>第 4 部分 C 语言 API 307<br>27 C 语言 API 总览 308<br>27.1 第一个示例 309<br>27.2 栈 312<br>27.2.1 压入元素 313<br>27.2.2 查询元素 314<br>27.2.3 其他栈操作 317<br>27.3 使用 C API 进行错误处理 320<br>27.3.1 处理应用代码中的错误 320<br>27.3.2 处理库代码中的错误 321<br>27.4 内存分配 322<br>27.5 练习 324<br>28 扩展应用 325<br>28.1 基础知识 325<br>28.2 操作表 327<br>28.2.1 一些简便方法 331<br>28.3 调用 Lua 函数 333<br>28.4 一个通用的调用函数 334<br>28.5 练习 338<br>29 在 Lua 中调用 C 语言 339<br>29.1 C 函数 339<br>29.2 延续（Continuation） 342<br>29.3 C 模块 345<br>29.4 练习 347<br>30 编写 C 函数的技巧 349<br>30.1 数组操作 349<br>30.2 字符串操作 351<br>30.3 在 C 函数中保存状态 355<br>30.3.1 注册表 355<br>30.3.2 上值 358<br>30.3.3 共享的上值（Shared upvalue） 361<br>30.4 练习 362<br>31 C 语言中的用户自定义类型 363<br>31.1 用户数据（Userdata） 364<br>31.2 元表（Metatable） 367<br>31.3 面向对象访问 370<br>31.4 数组访问 372<br>31.5 轻量级用户数据 373<br>31.6 练习 375<br>32 管理资源 376<br>32.1 目录迭代器 376<br>32.2 XML 解析器 380<br>32.3 练习 390<br>33 线程和状态 392<br>33.1 多线程 392<br>33.2 Lua 状态 397<br>33.3 练习 406</p><h3 id="Lua程序设计-PDF-下载地址"><a href="#Lua程序设计-PDF-下载地址" class="headerlink" title="Lua程序设计 PDF 下载地址:"></a>Lua程序设计 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1uZCy84RbQIQ6NpLMc__MtQ?pwd=0g09">https://pan.baidu.com/s/1uZCy84RbQIQ6NpLMc__MtQ?pwd=0g09</a> </p><p>提取码：0g09</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Lua语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kafka权威指南》</title>
      <link href="/2023/05/24/Kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/24/Kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1cf24ea01ffd8c6e8d27b099935eedd4.png" alt="《Kafka权威指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>每个应用程序都会产生数据，包括日志消息、度量指标、用户活动记录、响应消息等。如何移动数据，几乎变得与数据本身一样重要。如果你是架构师、开发者或者产品工程师，同时也是Apache Kafka新手，那么这本实践指南将会帮助你成为流式平台上处理实时数据的专家。 本书由出身于LinkedIn的Kafka核心作者和一线技术人员共同执笔，详细介绍了如何部署Kafka集群、开发可靠的基于事件驱动的微服务，以及基于Kafka平台构建可伸缩的流式应用程序。通过详尽示例，你将会了解到Kafka的设计原则、可靠性保证、关键API，以及复制协议、控制器和存储层等架构细节。 ● 了解发布和订阅消息模型以及该模型如何被应用在大数据生态系统中 ● 学习使用Kafka生产者和消费者来生成消息和读取消息 ● 了解Kafka保证可靠性数据传递的模式和场景需求 ● 使用Kafka构建数据管道和应用程序的最佳实践 ● 在生产环境中管理Kafka，包括监控、调优和维护 ● 了解Kafka的关键度量指标 ● 探索Kafka如何成为流式处理利器</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Neha Narkhede， Confluent联合创始人、CTO，曾在LinkedIn主导基于Kafka和Apache Samza构建流式基础设施，是Kafka作者之一。 Gwen Shapira， Confluent系统架构师，帮助客户构建基于Kafka的系统，在可伸缩数据架构方面拥有十余年经验；曾任Cloudera公司解决方案架构师。另著有《Hadoop应用架构》。 Todd Palino， LinkedIn主任级SRE，负责部署管理大型的Kafka、Zookeeper和Samza集群。 【译者简介】 薛命灯，毕业于厦门大学软件学院，十余年软件开发和架构经验，InfoQ高级社区编辑。译有《硅谷革命》《生产微服务》等书。微信公众号CodeDeep。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>序xiii<br>前言xv<br>第1章　初识Kafka1<br>1.1　发布与订阅消息系统1<br>1.1.1　如何开始2<br>1.1.2　独立的队列系统3<br>1.2　Kafka登场4<br>1.2.1　消息和批次4<br>1.2.2　模式4<br>1.2.3　主题和分区5<br>1.2.4　生产者和消费者5<br>1.2.5　broker和集群6<br>1.2.6　多集群7<br>1.3　为什么选择Kafka8<br>1.3.1　多个生产者8<br>1.3.2　多个消费者8<br>1.3.3　基于磁盘的数据存储9<br>1.3.4　伸缩性9<br>1.3.5　高性能9<br>1.4　数据生态系统9<br>1.5　起源故事11<br>1.5.1　LinkedIn的问题11<br>1.5.2　Kafka的诞生12<br>1.5.3　走向开源12<br>1.5.4　命名13<br>1.6　开始Kafka之旅13<br>第2章　安装Kafka14<br>2.1　要事先行14<br>2.1.1　选择操作系统14<br>2.1.2　安装Java14<br>2.1.3　安装Zookeeper15<br>2.2　安装KafkaBroker17<br>2.3　broker配置18<br>2.3.1　常规配置18<br>2.3.2　主题的默认配置19<br>2.4　硬件的选择23<br>2.4.1　磁盘吞吐量23<br>2.4.2　磁盘容量23<br>2.4.3　内存23<br>2.4.4　网络24<br>2.4.5　CPU24<br>2.5　云端的Kafka24<br>2.6　Kafka集群24<br>2.6.1　需要多少个broker25<br>2.6.2　broker配置25<br>2.6.3　操作系统调优26<br>2.7　生产环境的注意事项28<br>2.7.1　垃圾回收器选项28<br>2.7.2　数据中心布局29<br>2.7.3　共享Zookeeper29<br>2.8　总结30<br>第3章　Kafka生产者——向Kafka写入数据31<br>3.1　生产者概览32<br>3.2　创建Kafka生产者33<br>3.3　发送消息到Kafka34<br>3.3.1　同步发送消息35<br>3.3.2　异步发送消息35<br>3.4　生产者的配置36<br>3.5　序列化器39<br>3.5.1　自定义序列化器39<br>3.5.2　使用Avro序列化41<br>3.5.3　在Kafka里使用Avro42<br>3.6　分区45<br>3.7　旧版的生产者API46<br>3.8　总结47<br>第4章　Kafka消费者——从Kafka读取数据48<br>4.1　KafkaConsumer概念48<br>4.1.1　消费者和消费者群组48<br>4.1.2　消费者群组和分区再均衡51<br>4.2　创建Kafka消费者52<br>4.3　订阅主题53<br>4.4　轮询53<br>4.5　消费者的配置55<br>4.6　提交和偏移量57<br>4.6.1　自动提交58<br>4.6.2　提交当前偏移量59<br>4.6.3　异步提交59<br>4.6.4　同步和异步组合提交61<br>4.6.5　提交特定的偏移量61<br>4.7　再均衡监听器62<br>4.8　从特定偏移量处开始处理记录64<br>4.9　如何退出66<br>4.10　反序列化器67<br>4.11　独立消费者——为什么以及怎样使用没有群组的消费者71<br>4.12　旧版的消费者API71<br>4.13　总结72<br>第5章　深入Kafka73<br>5.1　集群成员关系73<br>5.2　控制器74<br>5.3　复制74<br>5.4　处理请求76<br>5.4.1　生产请求78<br>5.4.2　获取请求78<br>5.4.3　其他请求80<br>5.5　物理存储81<br>5.5.1　分区分配81<br>5.5.2　文件管理82<br>5.5.3　文件格式83<br>5.5.4　索引84<br>5.5.5　清理84<br>5.5.6　清理的工作原理84<br>5.5.7　被删除的事件86<br>5.5.8　何时会清理主题86<br>5.9　总结86<br>第6章　可靠的数据传递87<br>6.1　可靠性保证87<br>6.2　复制88<br>6.3　broker配置89<br>6.3.1　复制系数89<br>6.3.2　不完全的首领选举90<br>6.3.3　最少同步副本91<br>6.4　在可靠的系统里使用生产者92<br>6.4.1　发送确认92<br>6.4.2　配置生产者的重试参数93<br>6.4.3　额外的错误处理94<br>6.5　在可靠的系统里使用消费者94<br>6.5.1　消费者的可靠性配置95<br>6.5.2　显式提交偏移量95<br>6.6　验证系统可靠性97<br>6.6.1　配置验证98<br>6.6.2　应用程序验证98<br>6.6.3　在生产环境监控可靠性99<br>6.7　总结100<br>第7章　构建数据管道101<br>7.1　构建数据管道时需要考虑的问题102<br>7.1.1　及时性102<br>7.1.2　可靠性102<br>7.1.3　高吞吐量和动态吞吐量103<br>7.1.4　数据格式103<br>7.1.5　转换104<br>7.1.6　安全性104<br>7.1.7　故障处理能力104<br>7.1.8　耦合性和灵活性105<br>7.2　如何在ConnectAPI和客户端API之间作出选择105<br>7.3　KafkaConnect106<br>7.3.1　运行Connect106<br>7.3.2　连接器示例——文件数据源和文件数据池107<br>7.3.3　连接器示例——从MySQL到ElasticSearch109<br>7.3.4　深入理解Connect114<br>7.4　Connect之外的选择116<br>7.4.1　用于其他数据存储的摄入框架116<br>7.4.2　基于图形界面的ETL工具117<br>7.4.3　流式处理框架117<br>7.5　总结117<br>第8章　跨集群数据镜像118<br>8.1　跨集群镜像的使用场景118<br>8.2　多集群架构119<br>8.2.1　跨数据中心通信的一些现实情况119<br>8.2.2　Hub和Spoke架构120<br>8.2.3　双活架构121<br>8.2.4　主备架构123<br>8.2.5　延展集群127<br>8.3　Kafka的MirrorMaker128<br>8.3.1　如何配置129<br>8.3.2　在生产环境部署MirrorMaker130<br>8.3.3　MirrorMaker调优132<br>8.4　其他跨集群镜像方案134<br>8.4.1　优步的uReplicator134<br>8.4.2　Confluent的Replicator135<br>8.5　总结135<br>第9章　管理Kafka136<br>9.1　主题操作136<br>9.1.1　创建主题137<br>9.1.2　增加分区138<br>9.1.3　删除主题138<br>9.1.4　列出集群里的所有主题139<br>9.1.5　列出主题详细信息139<br>9.2　消费者群组140<br>9.2.1　列出并描述群组140<br>9.2.2　删除群组142<br>9.2.3　偏移量管理142<br>9.3　动态配置变更143<br>9.3.1　覆盖主题的默认配置143<br>9.3.2　覆盖客户端的默认配置145<br>9.3.3　列出被覆盖的配置145<br>9.3.4　移除被覆盖的配置146<br>9.4　分区管理146<br>9.4.1　首选的首领选举146<br>9.4.2　修改分区副本147<br>9.4.3　修改复制系数150<br>9.4.4　转储日志片段151<br>9.4.5　副本验证152<br>9.5　消费和生产153<br>9.5.1　控制台消费者153<br>9.5.2　控制台生产者155<br>9.6　客户端ACL157<br>9.7　不安全的操作157<br>9.7.1　移动集群控制器157<br>9.7.2　取消分区重分配157<br>9.7.3　移除待删除的主题158<br>9.7.4　手动删除主题158<br>9.8　总结159<br>第10章　监控Kafka160<br>10.1　度量指标基础160<br>10.1.1　度量指标在哪里160<br>10.1.2　内部或外部度量161<br>10.1.3　应用程序健康检测161<br>10.1.4　度量指标的覆盖面161<br>10.2　broker的度量指标162<br>10.2.1　非同步分区162<br>10.2.2　broker度量指标166<br>10.2.3　主题和分区的度量指标173<br>10.2.4　Java虚拟机监控174<br>10.2.5　操作系统监控175<br>10.2.6　日志176<br>10.3　客户端监控177<br>10.3.1　生产者度量指标177<br>10.3.2　消费者度量指标179<br>10.3.3　配额181<br>10.4　延时监控182<br>10.5　端到端监控183<br>10.6　总结183<br>第11章　流式处理184<br>11.1　什么是流式处理185<br>11.2　流式处理的一些概念186<br>11.2.1　时间187<br>11.2.2　状态188<br>11.2.3　流和表的二元性188<br>11.2.4　时间窗口189<br>11.3　流式处理的设计模式190<br>11.3.1　单个事件处理191<br>11.3.2　使用本地状态191<br>11.3.3　多阶段处理和重分区193<br>11.3.4　使用外部查找——流和表的连接193<br>11.3.5　流与流的连接195<br>11.3.6　乱序的事件195<br>11.3.7　重新处理196<br>11.4　Streams示例197<br>11.4.1　字数统计197<br>11.4.2　股票市场统计199<br>11.4.3　填充点击事件流201<br>11.5　KafkaStreams的架构概览202<br>11.5.1　构建拓扑202<br>11.5.2　对拓扑进行伸缩203<br>11.5.3　从故障中存活下来205<br>11.6　流式处理使用场景205<br>11.7　如何选择流式处理框架206<br>11.8　总结208<br>附录A　在其他操作系统上安装Kafka209<br>作者介绍214<br>封面介绍214</p><h3 id="Kafka权威指南-PDF-下载地址"><a href="#Kafka权威指南-PDF-下载地址" class="headerlink" title="Kafka权威指南 PDF 下载地址:"></a>Kafka权威指南 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1NbS95FK6jjwdsT3CVVpBdA?pwd=g4l1">https://pan.baidu.com/s/1NbS95FK6jjwdsT3CVVpBdA?pwd=g4l1</a> </p><p>提取码：g4l1</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《每天5分钟玩转Docker容器技术》</title>
      <link href="/2023/05/24/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%ACDocker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/05/24/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%ACDocker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/711ccdbbc82b13f2ef0dd8ef5cb677c5.png" alt="《每天5分钟玩转Docker容器技术》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>Docker和容器技术是当下热门的IT技术，无论是互联网还是传统企业都在研究和实践如何用容器构建自己的 IT 基础设施。学习本书能够让读者少走弯路，系统地学习、掌握和实践 Docker 和容器技术。 本书共分为三部分。靠前部分介绍容器技术生态环境。第二部分是容器核心知识，包括架构、镜像、容器、网络和存储。第三部分是容器进阶知识，包括多主机管理、跨主机网络方案、监控、日志管理和数据管理。读者在学习的过程中，可以跟着教程进行操作，在实践中掌握 Docker 容器技术的核心技能。在之后的工作中，可以将本教程作为参考书，按需查找相关知识点。 本书主要面向微服务软件开发人员，以及 IT 实施和运维工程师等相关人员，也适合高等院校和培训学校相关专业的师生教学参考。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>CloudMan，十多年 IT 从业经验，就职于国际知名 IT 企业，从事 IT 基础设施实施服务，项目涉及服务器、存储、网络、虚拟化、云技术等各个方面。CloudMan 对新技术长期保持浓厚的兴趣和学习热情，十几年来一直专注 IT 技术领域的钻研与实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1篇启程<br>第1章鸟瞰容器生态系统3<br>1.1容器生态系统3<br>1.2本教程覆盖的知识范围10<br>1.3准备实验环境10<br>1.3.1环境选择10<br>1.3.2安装Docker10<br>1.4运行第1个容器11<br>1.5小结12<br>第二篇容器技术<br>第2章容器核心知识概述15<br>2.1What——什么是容器15<br>2.2Why——为什么需要容器16<br>2.2.1容器解决的问题16<br>2.2.2Docker的特性20<br>2.2.3容器的优势20<br>2.3How——容器是如何工作的21<br>2.4小结24<br>第3章Docker镜像26<br>3.1镜像的内部结构26<br>3.1.1hello-world——最小的镜像26<br>3.1.2base镜像27<br>3.1.3镜像的分层结构30<br>3.2构建镜像32<br>3.2.1dockercommit32<br>3.2.2Dockerfile34<br>3.3RUNvsCMDvsENTRYPOINT42<br>3.3.1Shell和Exec格式42<br>3.3.2RUN44<br>3.3.3CMD44<br>3.3.4ENTRYPOINT45<br>3.3.5最佳实践46<br>3.4分发镜像46<br>3.4.1为镜像命名46<br>3.4.2使用公共Registry49<br>3.4.3搭建本地Registry51<br>3.5小结52<br>第4章Docker容器55<br>4.1运行容器55<br>4.1.1让容器长期运行56<br>4.1.2两种进入容器的方法57<br>4.1.3运行容器的最佳实践59<br>4.1.4容器运行小结59<br>4.2stop&#x2F;start&#x2F;restart容器60<br>4.3pause&#x2F;unpause容器61<br>4.4删除容器61<br>4.5StateMachine62<br>4.6资源限制65<br>4.6.1内存限额65<br>4.6.2CPU限额66<br>4.6.3BlockIO带宽限额68<br>4.7实现容器的底层技术69<br>4.7.1cgroup70<br>4.7.2namespace70<br>4.8小结72<br>第5章Docker网络74<br>5.1none网络74<br>5.2host网络75<br>5.3bridge网络76<br>5.4user-defined网络78<br>5.5容器间通信84<br>5.5.1IP通信84<br>5.5.2DockerDNSServer85<br>5.5.3joined容器85<br>5.6将容器与外部世界连接87<br>5.6.1容器访问外部世界87<br>5.6.2外部世界访问容器90<br>5.7小结91<br>第6章Docker存储92<br>6.1storagedriver92<br>6.2DataVolume94<br>6.2.1bindmount94<br>6.2.2dockermanagedvolume96<br>6.3数据共享99<br>6.3.1容器与host共享数据99<br>6.3.2容器之间共享数据99<br>6.4volumecontainer100<br>6.5data-packedvolumecontainer102<br>6.6DataVolume生命周期管理103<br>6.6.1备份104<br>6.6.2恢复104<br>6.6.3迁移104<br>6.6.4销毁104<br>6.7小结105<br>第三篇容器进阶知识<br>第7章多主机管理109<br>7.1实验环境描述110<br>7.2安装DockerMachine111<br>7.3创建Machine112<br>7.4管理Machine114<br>第8章容器网络117<br>8.1libnetwork&amp;CNM117<br>8.2overlay119<br>8.2.1实验环境描述120<br>8.2.2创建overlay网络121<br>8.2.3在overlay中运行容器122<br>8.2.4overlay网络连通性124<br>8.2.5overlay网络隔离126<br>8.2.6overlayIPAM127<br>8.3macvlan127<br>8.3.1准备实验环境127<br>8.3.2创建macvlan网络128<br>8.3.3macvlan网络结构分析130<br>8.3.4用sub-interface实现多macvlan网络131<br>8.3.5macvlan网络间的隔离和连通132<br>8.4flannel136<br>8.4.1实验环境描述137<br>8.4.2安装配置etcd137<br>8.4.3buildflannel138<br>8.4.4将flannel网络的配置信息保存到etcd139<br>8.4.5启动flannel139<br>8.4.6配置Docker连接flannel141<br>8.4.7将容器连接到flannel网络143<br>8.4.8flannel网络连通性144<br>8.4.9flannel网络隔离146<br>8.4.10flannel与外网连通性146<br>8.4.11host-gwbackend146<br>8.5weave148<br>8.5.1实验环境描述148<br>8.5.2安装部署weave149<br>8.5.3在host1中启动weave149<br>8.5.4在host1中启动容器150<br>8.5.5在host2中启动weave并运行容器153<br>8.5.6weave网络连通性154<br>8.5.7weave网络隔离155<br>8.5.8weave与外网的连通性156<br>8.5.9IPAM158<br>8.6calico158<br>8.6.1实验环境描述159<br>8.6.2启动etcd159<br>8.6.3部署calico160<br>8.6.4创建calico网络161<br>8.6.5在calico中运行容器161<br>8.6.6calico默认连通性164<br>8.6.7calicopolicy167<br>8.6.8calicoIPAM169<br>8.7比较各种网络方案170<br>8.7.1网络模型171<br>8.7.2DistributedStore171<br>8.7.3IPAM171<br>8.7.4连通与隔离172<br>8.7.5性能172<br>第9章容器监控173<br>9.1Docker自带的监控子命令173<br>9.1.1ps173<br>9.1.2…74<br>9.1.3stats175<br>9.2sysdig175<br>9.3WeaveScope179<br>9.3.1安装179<br>9.3.2容器监控181<br>9.3.3监控host184<br>9.3.4多主机监控186<br>9.4cAdvisor189<br>9.4.1监控DockerHost189<br>9.4.2监控容器191<br>9.5Prometheus194<br>9.5.1架构194<br>9.5.2多维数据模型195<br>9.5.3实践196<br>9.6比较不同的监控工具204<br>9.7几点建议205<br>第10章日志管理207<br>10.1Dockerlogs207<br>10.2Dockerloggingdriver209<br>10.3ELK211<br>10.3.1日志处理流程211<br>10.3.2安装ELK套件212<br>10.3.3Filebeat214<br>10.3.4管理日志216<br>10.4Fluentd220<br>10.4.1安装Fluentd221<br>10.4.2重新配置Filebeat221<br>10.4.3监控容器日志221<br>10.5Graylog222<br>10.5.1Graylog架构222<br>10.5.2部署Graylog223<br>10.5.3配置Graylog225<br>10.5.4监控容器日志227<br>10.6小结229<br>第11章数据管理230<br>11.1从一个例子开始230<br>11.2实践Rex-Raydriver232<br>11.2.1安装Rex-Ray232<br>11.2.2配置VirtualBox234<br>11.2.3创建Rex-Rayvolume236<br>11.2.4使用Rex-Rayvolume237<br>写在最后243</p><h3 id="每天5分钟玩转Docker容器技术-PDF-下载地址"><a href="#每天5分钟玩转Docker容器技术-PDF-下载地址" class="headerlink" title="每天5分钟玩转Docker容器技术 PDF 下载地址:"></a>每天5分钟玩转Docker容器技术 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1erOEpzOOWo5djAMRMIlPHA?pwd=avvw">https://pan.baidu.com/s/1erOEpzOOWo5djAMRMIlPHA?pwd=avvw</a> </p><p>提取码：avvw</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Nginx（第2版）》</title>
      <link href="/2023/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/586618a77d10293862d1149eba4e03c3.png" alt="《深入理解Nginx（第2版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书致力于说明开发Nginx模块的必备知识，第1版发行以后，深受广大读者的喜爱．然而由于Ng,nx功能繁多且性能强大，以致必须了解的基本技能也很庞杂，而第1版成书匆忙，缺失了几个进阶的技巧描述，因此第2版在此基础上进行了完善。</p><p>书中首先通过介绍官方Nginx的基本用法和配置规则，帮助读者了解一般Nginx模块的用法，然后重点介绍了女口何开发HTTP模块(含HTTP过滤模块)来得到定制化的Nginx，其中包括开发—个功能复杂的模块所需要了解的各种知识，并对内存池的实现细节及TCP协议进行了详细介绍；接着，综合Nginx框架代码分析了Nginx架构的设计理念和技巧，此外，还新增了如何在模块中支持HTTP变量，以及与slab共享内存等相关的内容，相信通过完善，可进一步帮助读者更好地开发出功能丰富、性能—流的Nginx模块。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>陶辉，毕业于西安交通大学计算机科学与技术专业，曾就职于华为中央软件部、腾讯QQ空间、思科中国CRDC等公司，目前在阿里巴巴云计算公司的飞天团队工作，研究方向为介于Iaas和Paas间的弹性计算，多年以来专注于Nginx的定制化应用，对Nginx的设计与特性有深刻认识，实战经验丰富，编写过许多优秀的Nginx模块并应用于企业级产品中，同时撰写了大量关于Nginx的技术文章。擅长Linux下高性能服务器的开发，以及分布式环境下海量数据存储的设计开发。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　Nginx能帮我们做什么<br>第1章　研究Nginx前的准备工作2<br>1.1　Nginx是什么2<br>1.2　为什么选择Nginx5<br>1.3　准备工作7<br>1.3.1　Linux操作系统7<br>1.3.2　使用Nginx的必备软件7<br>1.3.3　磁盘目录8<br>1.3.4　Linux内核参数的优化9<br>1.3.5　获取Nginx源码10<br>1.4　编译安装Nginx11<br>1.5　configure详解11<br>1.5.1　configure的命令参数11<br>1.5.2　configure执行流程18<br>1.5.3　configure生成的文件21<br>1.6　Nginx的命令行控制23<br>1.7　小结27<br>第2章　Nginx的配置28<br>2.1　运行中的Nginx进程间的关系28<br>2.2　Nginx配置的通用语法31<br>2.2.1　块配置项31<br>2.2.2　配置项的语法格式32<br>2.2.3　配置项的注释33<br>2.2.4　配置项的单位33<br>2.2.5　在配置中使用变量33<br>2.3　Nginx服务的基本配置34<br>2.3.1　用于调试进程和定位问题的配置项34<br>2.3.2　正常运行的配置项36<br>2.3.3　优化性能的配置项37<br>2.3.4　事件类配置项39<br>2.4　用HTTP核心模块配置一个静态Web服务器40<br>2.4.1　虚拟主机与请求的分发41<br>2.4.2　文件路径的定义45<br>2.4.3　内存及磁盘资源的分配47<br>2.4.4　网络连接的设置49<br>2.4.5　MIME类型的设置52<br>2.4.6　对客户端请求的限制53<br>2.4.7　文件操作的优化54<br>2.4.8　对客户端请求的特殊处理56<br>2.4.9　ngx_http_core_module模块提供的变量57<br>2.5　用HTTPproxymodule配置一个反向代理服务器59<br>2.5.1　负载均衡的基本配置61<br>2.5.2　反向代理的基本配置63<br>2.6　小结66<br>第二部分　如何编写HTTP模块<br>第3章　开发一个简单的HTTP模块68<br>3.1　如何调用HTTP模块68<br>3.2　准备工作70<br>3.2.1　整型的封装71<br>3.2.2　ngx_str_t数据结构71<br>3.2.3　ngx_list_t数据结构71<br>3.2.4　ngx_table_elt_t数据结构75<br>3.2.5　ngx_buf_t数据结构75<br>3.2.6　ngx_chain_t数据结构77<br>3.3　如何将自己的HTTP模块编译进Nginx77<br>3.3.1　config文件的写法77<br>3.3.2　利用configure脚本将定制的模块加入到Nginx中78<br>3.3.3　直接修改Makefile文件81<br>3.4　HTTP模块的数据结构82<br>3.5　定义自己的HTTP模块86<br>3.6　处理用户请求89<br>3.6.1　处理方法的返回值89<br>3.6.2　获取URI和参数92<br>3.6.3　获取HTTP头部94<br>3.6.4　获取HTTP包体97<br>3.7　发送响应99<br>3.7.1　发送HTTP头部99<br>3.7.2　将内存中的字符串作为包体发送101<br>3.7.3　经典的“HelloWorld”示例102<br>3.8　将磁盘文件作为包体发送103<br>3.8.1　如何发送磁盘中的文件104<br>3.8.2　清理文件句柄106<br>3.8.3　支持用户多线程下载和断点续传107<br>3.9　用C++语言编写HTTP模块108<br>3.9.1　编译方式的修改108<br>3.9.2　程序中的符号转换109<br>3.10　小结110<br>第4章　配置、error日志和请求上下文111<br>4.1　http配置项的使用场景111<br>4.2　怎样使用http配置113<br>4.2.1　分配用于保存配置参数的数据结构113<br>4.2.2　设定配置项的解析方式115<br>4.2.3　使用14种预设方法解析配置项121<br>4.2.4　自定义配置项处理方法131<br>4.2.5　合并配置项133<br>4.3　HTTP配置模型135<br>4.3.1　解析HTTP配置的流程136<br>4.3.2　HTTP配置模型的内存布局139<br>4.3.3　如何合并配置项142<br>4.3.4　预设配置项处理方法的工作原理144<br>4.4　error日志的用法145<br>4.5　请求的上下文149<br>4.5.1　上下文与全异步Web服务器的关系149<br>4.5.2　如何使用HTTP上下文151<br>4.5.3　HTTP框架如何维护上下文结构152<br>4.6　小结153<br>第5章　访问第三方服务154<br>5.1　upstream的使用方式155<br>5.1.1　ngx_http_upstream_t结构体158<br>5.1.2　设置upstream的限制性参数159<br>5.1.3　设置需要访问的第三方服务器地址160<br>5.1.4　设置回调方法161<br>5.1.5　如何启动upstream机制161<br>5.2　回调方法的执行场景162<br>5.2.1　create_request回调方法162<br>5.2.2　reinit_request回调方法164<br>5.2.3　finalize_request回调方法165<br>5.2.4　process_header回调方法165<br>5.2.5　rewrite_redirect回调方法167<br>5.2.6　input_filter_init与input_filter回调方法167<br>5.3　使用upstream的示例168<br>5.3.1　upstream的各种配置参数168<br>5.3.2　请求上下文170<br>5.3.3　在create_request方法中构造请求170<br>5.3.4　在process_header方法中解析包头171<br>5.3.5　在finalize_request方法中释放资源175<br>5.3.6　在ngx_http_mytest_handler方法中启动upstream175<br>5.4　subrequest的使用方式177<br>5.4.1　配置子请求的处理方式177<br>5.4.2　实现子请求处理完毕时的回调方法178<br>5.4.3　处理父请求被重新激活后的回调方法179<br>5.4.4　启动subrequest子请求179<br>5.5　subrequest执行过程中的主要场景180<br>5.5.1　如何启动subrequest180<br>5.5.2　如何转发多个子请求的响应包体182<br>5.5.3　子请求如何激活父请求185<br>5.6　subrequest使用的例子187<br>5.6.1　配置文件中子请求的设置187<br>5.6.2　请求上下文188<br>5.6.3　子请求结束时的处理方法188<br>5.6.4　父请求的回调方法189<br>5.6.5　启动subrequest190<br>5.7　小结191<br>第6章　开发一个简单的HTTP过滤模块192<br>6.1　过滤模块的意义192<br>6.2　过滤模块的调用顺序193<br>6.2.1　过滤链表是如何构成的194<br>6.2.2　过滤链表的顺序196<br>6.2.3　官方默认HTTP过滤模块的功能简介197<br>6.3　HTTP过滤模块的开发步骤198<br>6.4　HTTP过滤模块的简单例子200<br>6.4.1　如何编写config文件201<br>6.4.2　配置项和上下文201<br>6.4.3　定义HTTP过滤模块203<br>6.4.4　初始化HTTP过滤模块204<br>6.4.5　处理请求中的HTTP头部204<br>6.4.6　处理请求中的HTTP包体206<br>6.5　小结206<br>第7章　Nginx提供的高级数据结构207<br>7.1　Nginx提供的高级数据结构概述207<br>7.2　ngx_queue_t双向链表209<br>7.2.1　为什么设计ngx_queue_t双向链表209<br>7.2.2　双向链表的使用方法209<br>7.2.3　使用双向链表排序的例子212<br>7.2.4　双向链表是如何实现的213<br>7.3　ngx_array_t动态数组215<br>7.3.1　为什么设计ngx_array_t动态数组215<br>7.3.2　动态数组的使用方法215<br>7.3.3　使用动态数组的例子217<br>7.3.4　动态数组的扩容方式218<br>7.4　ngx_list_t单向链表219<br>7.5　ngx_rbtree_t红黑树219<br>7.5.1　为什么设计ngx_rbtree_t红黑树219<br>7.5.2　红黑树的特性220<br>7.5.3　红黑树的使用方法222<br>7.5.4　使用红黑树的简单例子225<br>7.5.5　如何自定义添加成员方法226<br>7.6　ngx_radix_tree_t基数树228<br>7.6.1　ngx_radix_tree_t基数树的原理228<br>7.6.2　基数树的使用方法230<br>7.6.3　使用基数树的例子231<br>7.7　支持通配符的散列表232<br>7.7.1　ngx_hash_t基本散列表232<br>7.7.2　支持通配符的散列表235<br>7.7.3　带通配符散列表的使用例子241<br>7.8　小结245<br>第三部分　深入Nginx<br>第8章　Nginx基础架构248<br>8.1　Web服务器设计中的关键约束249<br>8.2　Nginx的架构设计251<br>8.2.1　优秀的模块化设计251<br>8.2.2　事件驱动架构254<br>8.2.3　请求的多阶段异步处理256<br>8.2.4　管理进程、多工作进程设计259<br>8.2.5　平台无关的代码实现259<br>8.2.6　内存池的设计259<br>8.2.7　使用统一管道过滤器模式的HTTP过滤模块260<br>8.2.8　其他一些用户模块260<br>8.3　Nginx框架中的核心结构体ngx_cycle_t260<br>8.3.1　ngx_listening_t结构体261<br>8.3.2　ngx_cycle_t结构体262<br>8.3.3　ngx_cycle_t支持的方法264<br>8.4　Nginx启动时框架的处理流程266<br>8.5　worker进程是如何工作的269<br>8.6　master进程是如何工作的271<br>8.7　ngx_pool_t内存池276<br>8.8　小结284<br>第9章　事件模块285<br>9.1　事件处理框架概述286<br>9.2　Nginx事件的定义288<br>9.3　Nginx连接的定义291<br>9.3.1　被动连接292<br>9.3.2　主动连接295<br>9.3.3　ngx_connection_t连接池296<br>9.4　ngx_events_module核心模块297<br>9.4.1　如何管理所有事件模块的配置项299<br>9.4.2　管理事件模块300<br>9.5　ngx_event_core_module事件模块302<br>9.6　epoll事件驱动模块308<br>9.6.1　epoll的原理和用法308<br>9.6.2　如何使用epoll310<br>9.6.3　ngx_epoll_module模块的实现312<br>9.7　定时器事件320<br>9.7.1　缓存时间的管理320<br>9.7.2　缓存时间的精度323<br>9.7.3　定时器的实现323<br>9.8　事件驱动框架的处理流程324<br>9.8.1　如何建立新连接325<br>9.8.2　如何解决“惊群”问题327<br>9.8.3　如何实现负载均衡329<br>9.8.4　post事件队列330<br>9.8.5　ngx_process_events_and_timers流程331<br>9.9　文件的异步I&#x2F;O334<br>9.9.1　Linux内核提供的文件异步I&#x2F;O335<br>9.9.2　ngx_epoll_module模块中实现的针对文件的异步I&#x2F;O337<br>9.10　TCP协议与Nginx342<br>9.11　小结347<br>第10章　HTTP框架的初始化348<br>10.1　HTTP框架概述349<br>10.2　管理HTTP模块的配置项352<br>10.2.1　管理main级别下的配置项353<br>10.2.2　管理server级别下的配置项355<br>10.2.3　管理location级别下的配置项358<br>10.2.4　不同级别配置项的合并364<br>10.3　监听端口的管理367<br>10.4　server的快速检索370<br>10.5　location的快速检索370<br>10.6　HTTP请求的11个处理阶段372<br>10.6.1　HTTP处理阶段的普适规则374<br>10.6.2　NGX_HTTP_POST_READ_PHASE阶段375<br>10.6.3　NGX_HTTP_SERVER_REWRITE_PHASE阶段378<br>10.6.4　NGX_HTTP_FIND_CONFIG_PHASE阶段378<br>10.6.5　NGX_HTTP_REWRITE_PHASE阶段378<br>10.6.6　NGX_HTTP_POST_REWRITE_PHASE阶段379<br>10.6.7　NGX_HTTP_PREACCESS_PHASE阶段379<br>10.6.8　NGX_HTTP_ACCESS_PHASE阶段379<br>10.6.9　NGX_HTTP_POST_ACCESS_PHASE阶段380<br>10.6.10　NGX_HTTP_TRY_FILES_PHASE阶段380<br>10.6.11　NGX_HTTP_CONTENT_PHASE阶段380<br>10.6.12　NGX_HTTP_LOG_PHASE阶段382<br>10.7　HTTP框架的初始化流程382<br>10.8　小结384<br>第11章　HTTP框架的执行流程385<br>11.1　HTTP框架执行流程概述386<br>11.2　新连接建立时的行为387<br>11.3　第一次可读事件的处理388<br>11.4　接收HTTP请求行394<br>11.5　接收HTTP头部398<br>11.6　处理HTTP请求400<br>11.6.1　ngx_http_core_generic_phase406<br>11.6.2　ngx_http_core_rewrite_phase408<br>11.6.3　ngx_http_core_access_phase409<br>11.6.4　ngx_http_core_content_phase412<br>11.7　subrequest与post请求415<br>11.8　处理HTTP包体417<br>11.8.1　接收包体419<br>11.8.2　放弃接收包体425<br>11.9　发送HTTP响应429<br>11.9.1　ngx_http_send_header430<br>11.9.2　ngx_http_output_filter432<br>11.9.3　ngx_http_writer435<br>11.10　结束HTTP请求437<br>11.10.1　ngx_http_close_connection438<br>11.10.2　ngx_http_free_request439<br>11.10.3　ngx_http_close_request440<br>11.10.4　ngx_http_finalize_connection441<br>11.10.5　ngx_http_terminate_request443<br>11.10.6　ngx_http_finalize_request443<br>11.11　小结446<br>第12章　upstream机制的设计与实现447<br>12.1　upstream机制概述448<br>12.1.1　设计目的448<br>12.1.2　ngx_http_upstream_t数据结构的意义450<br>12.1.3　ngx_http_upstream_conf_t配置结构体453<br>12.2　启动upstream455<br>12.3　与上游服务器建立连接457<br>12.4　发送请求到上游服务器460<br>12.5　接收上游服务器的响应头部463<br>12.5.1　应用层协议的两段划分方式463<br>12.5.2　处理包体的3种方式464<br>12.5.3　接收响应头部的流程465<br>12.6　不转发响应时的处理流程469<br>12.6.1　input_filter方法的设计469<br>12.6.2　默认的input_filter方法470<br>12.6.3　接收包体的流程472<br>12.7　以下游网速优先来转发响应473<br>12.7.1　转发响应的包头474<br>12.7.2　转发响应的包体477<br>12.8　以上游网速优先来转发响应481<br>12.8.1　ngx_event_pipe_t结构体的意义481<br>12.8.2　转发响应的包头485<br>12.8.3　转发响应的包体487<br>12.8.4　ngx_event_pipe_read_upstream方法489<br>12.8.5　ngx_event_pipe_write_to_downstream方法494<br>12.9　结束upstream请求496<br>12.10　小结499<br>第13章　邮件代理模块500<br>13.1　邮件代理服务器的功能500<br>13.2　邮件模块的处理框架503<br>13.2.1　一个请求的8个独立处理阶段503<br>13.2.2　邮件类模块的定义504<br>13.2.3　邮件框架的初始化506<br>13.3　初始化请求506<br>13.3.1　描述邮件请求的ngx_mail_session_t结构体506<br>13.3.2　初始化邮件请求的流程509<br>13.4　接收并解析客户端请求509<br>13.5　邮件认证510<br>13.5.1　ngx_mail_auth_http_ctx_t结构体510<br>13.5.2　与认证服务器建立连接511<br>13.5.3　发送请求到认证服务器513<br>13.5.4　接收并解析响应514<br>13.6　与上游邮件服务器间的认证交互514<br>13.6.1　ngx_mail_proxy_ctx_t结构体516<br>13.6.2　向上游邮件服务器发起连接516<br>13.6.3　与邮件服务器认证交互的过程518<br>13.7　透传上游邮件服务器与客户端间的流520<br>13.8　小结524<br>第14章　进程间的通信机制525<br>14.1　概述525<br>14.2　共享内存526<br>14.3　原子操作530<br>14.3.1　不支持原子库下的原子操作530<br>14.3.2　x86架构下的原子操作531<br>14.3.3　自旋锁533<br>14.4　Nginx频道535<br>14.5　信号538<br>14.6　信号量540<br>14.7　文件锁541<br>14.8　互斥锁544<br>14.8.1　文件锁实现的ngx_shmtx_t锁546<br>14.8.2　原子变量实现的ngx_shmtx_t锁548<br>14.9　小结553<br>第15章　变量554<br>15.1　使用内部变量开发模块555<br>15.1.1　定义模块556<br>15.1.2　定义http模块加载方式557<br>15.1.3　解析配置中的变量558<br>15.1.4　处理请求560<br>15.2　内部变量工作原理561<br>15.2.1　何时定义变量561<br>15.2.2　相关数据结构详述564<br>15.2.3　定义变量的方法572<br>15.2.4　使用变量的方法572<br>15.2.5　如何解析变量573<br>15.3　定义内部变量576<br>15.4　外部变量与脚本引擎577<br>15.4.1　相关数据结构578<br>15.4.2　编译“set”脚本581<br>15.4.3　脚本执行流程586<br>15.5　小结589<br>第16章　slab共享内存590<br>16.1　操作slab共享内存的方法590<br>16.2　使用slab共享内存池的例子592<br>16.2.1　共享内存中的数据结构593<br>16.2.2　操作共享内存中的红黑树与链表595<br>16.2.3　解析配置文件600<br>16.2.4　定义模块603<br>16.3　slab内存管理的实现原理605<br>16.3.1　内存结构布局607<br>16.3.2　分配内存流程613<br>16.3.3　释放内存流程617<br>16.3.4　如何使用位操作619<br>16.3.5　slab内存池间的管理624<br>16.4　小结624</p><h3 id="深入理解Nginx（第2版）-PDF-下载地址"><a href="#深入理解Nginx（第2版）-PDF-下载地址" class="headerlink" title="深入理解Nginx（第2版） PDF 下载地址:"></a>深入理解Nginx（第2版） PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/159c8gslfQfbKwUM0wFB53A?pwd=v3ae">https://pan.baidu.com/s/159c8gslfQfbKwUM0wFB53A?pwd=v3ae</a> </p><p>提取码：v3ae</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Docker容器与容器云（第2版）》</title>
      <link href="/2023/05/24/Docker%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%91%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/24/Docker%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%91%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/39k8ibvr7xj60m8z1o8qxwl8gfprwc3f.png" alt="《Docker容器与容器云（第2版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书根据Docker 1.10版和Kubernetes 1.2版对第1版进行了全面更新，从实践者的角度出发，以Docker和Kubernetes为重点，沿着“基本用法介绍”到“核心原理解读”到“高级实践技巧”的思路，一本书讲透当前主流的容器和容器云技术，有助于读者在实际场景中利用Docker容器和容器云解决问题并启发新的思考。全书包括两部分，第一部分深入解读Docker容器技术，包括Docker架构与设计、核心源码解读和高级实践技巧；第二部分归纳和比较了三类基于Docker的主流容器云项目，包括专注Docker容器编排与部署的容器云、专注应用支撑的容器云以及一切皆容器的Kubernetes，进而详细解读了Kubernetes核心源码的设计与实现，最后介绍了几种典型场景下的Kubernetes最佳实践。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>浙江大学软件工程实验室（Software Engineering Lab，SEL）</p><p>云计算团队组建于2011年，组织博士和硕士研究生搭建、分析和钻研开源的云计算技术，包括Docker、Kubernetes、Cloud Foundry、OpenStack、CloudStack、Eucalyptus、Convirt、OpenShift等，积极为开源社区贡献代码，管理和参与线上线下讨论社区，参加国内外云计算技术峰会并发言。以开源社区为技术交流研发平台，浙江大学SEL实验室在几年的时间里成长为一个充满热情、富有能力的云计算研发团队，也在国内外开源云计算社区，尤其是在Docker、Kubernetes和Cloud Foundry社区得到了广泛认可。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　Docker深入解读<br>第1章　从容器到容器云　　2<br>1.1　云计算平台　　2<br>1.2　容器，新的革命　　3<br>1.3　进化：从容器到容器云　　7<br>第2章　Docker 基础　　8<br>2.1　Docker的安装　　8<br>2.2　Docker操作参数解读　　9<br>2.3　搭建你的第一个Docker应用栈　　16<br>2.3.1　Docker集群部署　　16<br>2.3.2　第一个Hello World　　17<br>2.3.3　开发、测试和发布一体化　　27<br>第3章　Docker核心原理解读　　28<br>3.1　Docker背后的内核知识　　28<br>3.1.1　namespace资源隔离　　28<br>3.1.2　cgroups资源限制　　45<br>3.2　Docker架构概览　　53<br>3.2.1　Docker daemon　　54<br>3.2.2　Docker client　　54<br>3.2.3　镜像管理　　54<br>3.2.4　execdriver、volumedriver、graphdriver　　55<br>3.2.5　network　　55<br>3.3　client和daemon　　56<br>3.3.1　client模式　　56<br>3.3.2　daemon模式　　58<br>3.3.3　从client到daemon　　64<br>3.4　libcontainer　　67<br>3.4.1　libcontainer的工作方式　　69<br>3.4.2　libcontainer实现原理　　70<br>3.4.3　使用runC与libcontainer进行交互　　75<br>3.5　Docker镜像管理　　77<br>3.5.1　什么是Docker镜像　　77<br>3.5.2　Docker镜像关键概念　　80<br>3.5.3　Docker镜像构建操作　　81<br>3.5.4　Docker镜像的分发方法　　84<br>3.6　Docker存储管理　　87<br>3.6.1　Docker镜像元数据管理　　87<br>3.6.2　Docker存储驱动　　89<br>3.7　Docker数据卷　　99<br>3.7.1　数据卷的使用方式　　100<br>3.7.2　数据卷原理解读　　105<br>3.8　Docker网络管理　　108<br>3.8.1　Docker网络基础　　108<br>3.8.2　Docker daemon网络配置原理　　116<br>3.8.3　libcontainer网络配置原理　　119<br>3.8.4　传统的link原理解析　　125<br>3.8.5　新的link介绍　　127<br>3.9　Docker与容器安全　　129<br>3.9.1　Docker的安全机制　　129<br>3.9.2　Docker安全问题　　135<br>3.9.3　Docker安全的解决方案　　139<br>第4章　Docker 高级实践技巧　　151<br>4.1　容器化思维　　151<br>4.1.1　SSH服务器的替代方案　　151<br>4.1.2　Docker内应用日志管理方案　　152<br>4.1.3　容器化思维及更多　　153<br>4.2　Docker高级网络实践　　153<br>4.2.1　玩转Linux networknamespace　　154<br>4.2.2　pipework原理解析　　159<br>4.2.3　pipework跨主机通信　　165<br>4.2.4　OVS划分VLAN　　170<br>4.2.5　OVS隧道模式　　174<br>4.3　Dockerfile最佳实践　　187<br>4.3.1　Dockerfile的使用　　187<br>4.3.2　Dockerfile实践心得　　191<br>4.4　Docker容器的监控手段　　193<br>4.4.1　Docker容器监控维度　　194<br>4.4.2　容器监控命令　　195<br>4.4.3　常用的容器监控工具　　197<br>4.5　容器化应用构建的基础：高可用配置中心　　201<br>4.5.1　etcd经典应用场景　　201<br>4.5.2　etcd实现原理　　206<br>第二部分　Docker云平台解读<br>第5章　构建自己的容器云　　222<br>5.1　再谈云平台的层次架构　　222<br>5.2　从小工到专家　　225<br>第6章　专注编排与部署：三剑客与Fleet　　230<br>6.1　编排小神器Fig&#x2F;Compose　　230<br>6.1.1　再谈容器编排与部署　　230<br>6.1.2　Compose原理：一探究竟　　233<br>6.2　跨平台宿主环境管理工具Machine　　237<br>6.2.1　Machine与虚拟机软件　　237<br>6.2.2　Machine与IaaS平台　　238<br>6.2.3　Machine小结　　239<br>6.3　集群抽象工具Swarm　　240<br>6.3.1　Swarm简介　　240<br>6.3.2　试用Swarm　　241<br>6.3.3　Swarm集群的多种创建方式　　243<br>6.3.4　Swarm对请求的处理　　245<br>6.3.5　Swarm集群的调度策略　　245<br>6.3.6　Swarm集群高可用（HA）　　246<br>6.3.7　Swarm与Machine　　247<br>6.3.8　Swarm小结　　248<br>6.4　编排之秀Fleet　　248<br>6.4.1　旧问题新角度：Docker distro　　249<br>6.4.2　Fleet的原理剖析　　252<br>第7章　专注应用支撑和运行时：Flynn和Deis　　258<br>7.1　Flynn，一个小而美的两层架构　　258<br>7.1.1　第0层：容器云的基础设施　　259<br>7.1.2　第1层：容器云的功能框架　　259<br>7.1.3　Flynn体系架构与实现原理　　260<br>7.2　谈谈Deis与Flynn　　270<br>7.2.1　应用发布上的比较　　271<br>7.2.2　关于Deis的一些思考　　273<br>第8章　一切皆容器：Kubernetes　　274<br>8.1　Kubernetes是个什么样的项目　　274<br>8.2　Kubernetes的设计解读　　275<br>8.2.1　一个典型案例：Guestbook　　275<br>8.2.2　pod设计解读　　277<br>8.2.3　replication controller设计解读　　288<br>8.2.4　service的设计解读　　294<br>8.2.5　新一代副本控制器replica set　　306<br>8.2.6　Deployment　　307<br>8.2.7　DaemonSet　　312<br>8.2.8　ConfigMap　　312<br>8.2.9　Job　　317<br>8.2.10　Horizontal Pod Autoscaler　　318<br>8.3　Kubernetes核心组件解读　　320<br>8.3.1　Kubernetes的整体架构　　320<br>8.3.2　APIServer　　321<br>8.3.3　scheduler　　328<br>8.3.4　controller manager　　338<br>8.3.5　kubelet　　346<br>8.3.6　kube-proxy　　352<br>8.3.7　核心组件协作流程　　362<br>8.4　Kubernetes存储核心原理　　366<br>8.4.1　volume设计解读　　366<br>8.4.2　volume实现原理分析　　367<br>8.4.3　volume使用案例　　368<br>8.4.4　persistent volume　　371<br>8.5　Kubernetes网络核心原理　　372<br>8.5.1　单pod单IP模型　　373<br>8.5.2　pod和网络容器　　374<br>8.5.3　实现Kubernetes的网络模型　　377<br>8.6　Kubernetes多租户管理与资源控制　　381<br>8.6.1　namespace设计解读　　381<br>8.6.2　Kubernetes用户认证机制　　385<br>8.6.3　Kubernetes用户授权机制　　387<br>8.6.4　Kubernetes多维资源管理机制admission control　　390<br>8.7　Kubernetes高级实践　　402<br>8.7.1　应用健康检查　　402<br>8.7.2　高可用性　　405<br>8.7.3　日志　　408<br>8.7.4　集成DNS　　410<br>8.7.5　容器上下文环境　　412<br>8.8　Kubernetes未来动向　　414<br>8.8.1　Ubernetes　　414<br>8.8.2　petSet　　415<br>8.8.3　performance　　417<br>8.8.4　rescheduler　　417<br>8.8.5　OCI标准　　419<br>8.9　不要停止思考　　419<br>第三部分　附录<br>附录A　Docker的安装　　424<br>附录B　阅读Docker源代码的神兵利器　　432<br>附录C　快速熟悉开源项目　　441<br>附录D　cgroups的测试与使用　　444<br>附录E　cgroups子系统配置参数介绍　　448<br>附录F　Kubernetes的安装　　453<br>后记　　457</p><h3 id="Docker容器与容器云（第2版）-PDF-下载地址"><a href="#Docker容器与容器云（第2版）-PDF-下载地址" class="headerlink" title="Docker容器与容器云（第2版） PDF 下载地址:"></a>Docker容器与容器云（第2版） PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1IglaoAGn0nRKN8tOE32WWQ?pwd=v15b">https://pan.baidu.com/s/1IglaoAGn0nRKN8tOE32WWQ?pwd=v15b</a> </p><p>提取码：v15b</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go专家编程》</title>
      <link href="/2023/05/24/Go%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/24/Go%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cq7yazwp20b5ozt21mt39tu5a0y0olui.jpg" alt="《Go专家编程》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松地了解Go语言的内部运作机制。</p><p>本书首先介绍Go语言常见的数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者可以借此测验自身对该知识点的掌握程度。接着介绍了Go语言最基础的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了一些标准库、异常处理和依赖管理等非语法相关但非常重要的内容。最后结合作者的见闻，整理了一些发生在真实项目中的编程陷阱。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>任洪彩，华为云原生团队核心成员，开源爱好者，深度参与CNCF（云原生计算基金会）旗下Kubernetes、Prometheus等项目贡献，Kubernetes资深成员，担任Kubernetes SIG-Instrumentation Approver，敏捷软件思想深度实践者，在Nokia、华为等公司参与过多个大型项目的研发与重构，对Go、C&#x2F;C++、Python、Swift等语言均有深入的研究与实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　常见数据结构的实现原理<br>1.1　管道<br>1.1.1　热身测验<br>1.1.2　特性速览<br>1.1.3　实现原理<br>1.2　slice<br>1.2.1　热身测验<br>1.2.2　特性速览<br>1.2.3　实现原理<br>1.2.4　切片表达式<br>1.3　map<br>1.3.1　热身测验<br>1.3.2　特性速览<br>1.3.3　实现原理<br>1.4　struct<br>1.4.1　热身测验<br>1.4.2　内嵌字段<br>1.4.3　方法受体<br>1.4.4　字段标签<br>1.5　iota<br>1.5.1　热身测验<br>1.5.2　特性速览<br>1.5.3　实现原理<br>1.6　string<br>1.6.1　热身测验<br>1.6.2　特性速览<br>1.6.3　实现原理<br>第2章　控制结构<br>2.1　select<br>2.1.1　热身测验<br>2.1.2　特性速览<br>2.1.3　实现原理<br>2.2　for-range<br>2.2.1　热身测验<br>2.2.2　特性速览<br>2.2.3　实现原理<br>第3章　协程<br>3.1　协程的概念<br>3.2　调度模型<br>3.3　调度策略<br>第4章　内存管理<br>4.1　内存分配<br>4.2　垃圾回收<br>4.3　逃逸分析<br>第5章　并发控制<br>5.1　channel<br>5.2　WaitGroup<br>5.3　context<br>5.4　Mutex<br>5.5　RWMutex<br>5.5.1　读写锁的数据结构<br>5.5.2　场景分析<br>第6章　反射<br>6.1　热身测验<br>6.2　接口<br>6.3　反射定律<br>第7章　测试<br>7.1　快速开始<br>7.1.1　单元测试<br>7.1.2　基准测试<br>7.1.3　示例测试<br>7.2　进阶测试<br>7.2.1　子测试<br>7.2.2　Main测试<br>7.3　实现原理<br>7.3.1　testing.common<br>7.3.2　testing.TB接口<br>7.3.3　单元测试的实现原理<br>7.3.4　性能测试的实现原理<br>7.3.5　示例测试的实现原理<br>7.3.6　Main测试的实现原理<br>7.3.7　gotest的工作机制<br>7.4　扩展阅读<br>7.4.1　测试参数<br>7.4.2　benchstat<br>第8章　异常处理<br>8.1　error<br>8.1.1　热身测验<br>8.1.2　基础error<br>8.1.3　链式error<br>8.1.4　工程迁移<br>8.2　defer<br>8.2.1　热身测验<br>8.2.2　约法三章<br>8.2.3　实现原理<br>8.2.4　性能优化<br>8.3　panic<br>8.3.1　热身测验<br>8.3.2　工作机制<br>8.3.3　源码剖析<br>8.4　recover<br>8.4.1　热身测验<br>8.4.2　工作机制<br>8.4.3　源码剖析<br>第9章　定时器<br>9.1　一次性定时器（Timer）<br>9.1.1　快速开始<br>9.1.2　实现原理<br>9.2　周期性定时器（Ticker）<br>9.2.1　快速开始<br>9.2.2　实现原理<br>9.3　runtimeTimer<br>9.3.1　实现原理<br>9.3.2　性能优化<br>9.4　案例分享<br>第10章　语法糖<br>10.1　简短变量声明符<br>10.1.1　热身测验<br>10.1.2　规则<br>10.2　可变参函数<br>第11章　版本管理<br>11.1　安装Go<br>11.2　删除Go<br>11.3　升级Go<br>11.4　Go版本管理器<br>11.4.1　快速开始<br>11.4.2　工作机制<br>11.4.3　小结<br>11.5　源码编译<br>11.5.1　源码下载<br>11.5.2　源码编译过程<br>第12章　Go语言依赖管理<br>12.1　GOPATH<br>12.1.1　GOROOT是什么<br>12.1.2　GOPATH是什么<br>12.1.3　依赖查找<br>12.1.4　GOPATH的缺点<br>12.2　vendor<br>12.2.1　vendor目录位置<br>12.2.2　搜索顺序<br>12.2.3　vendor的不足<br>12.3　GoModule<br>12.3.1　GoModule基础<br>12.3.2　快速实践<br>12.3.3　replace指令<br>12.3.4　exclude指令<br>12.3.5　indirect指令<br>12.3.6　版本选择机制<br>12.3.7　incompatible<br>12.3.8　伪版本<br>12.3.9　依赖包存储<br>12.3.10　go.sum<br>12.3.11　模块代理<br>12.3.12　GOSUMDB的工作机制<br>12.3.13　GOSUMDB的实现原理<br>12.3.14　第三方代理<br>12.3.15　私有模块<br>12.3.16　GoModule的演进<br>第13章　编程陷阱<br>13.1　切片扩容<br>13.2　空切片<br>13.3　append的本质<br>13.4　循环变量引用<br>13.5　协程引用循环变量<br>13.6　recover失效</p><h3 id="Go专家编程-PDF-下载地址"><a href="#Go专家编程-PDF-下载地址" class="headerlink" title="Go专家编程 PDF 下载地址:"></a>Go专家编程 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1sdur-j2y9Exf3V3TAGZ_Rw?pwd=mp19">https://pan.baidu.com/s/1sdur-j2y9Exf3V3TAGZ_Rw?pwd=mp19</a> </p><p>提取码：mp19</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Go语言编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言高级编程》</title>
      <link href="/2023/05/24/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/24/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/o6fkcz9f5pj28fedxj7l7biszkbb6cvf.png" alt="《Go语言高级编程》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书从实践出发讲解Go语言编程的进阶知识。本书共6章，第1章简单回顾Go语言的发展历史；第2章和第3章系统介绍CGO编程和Go汇编语言的用法；第4章对RPC和Protobuf技术进行深入介绍，并讲述如何打造一个自己的RPC系统；第5章介绍工业级环境的Web系统的设计和相关技术；第6章介绍Go语言在分布式领域的一些编程技术。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>柴树杉</p><p>国内第一批的Go语言爱好者，Go语言代码贡献者，CGO资深用户。同时对WebAssembly技术有一定研究，著有《WebAssembly标准入门》。Github账号为chai2010。</p><p>曹春晖</p><p>在Web领域工作多年，开源爱好者。对大型网站系统的架构和相关工具的实现很感兴趣，并且有一些研究成果。目前在滴滴平台技术部工作。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 语言基础<br>1.1 Go语言创世纪<br>1.2 Hello, World 的革命<br>1.3 数组、字符串和切片<br>1.4 函数、方法和接口<br>1.5 面向并发的内存模型<br>1.6 常见的并发模式<br>1.7 错误和异常<br>1.8 补充说明<br>第2章 CGO编程<br>2.1 快速入门<br>2.2 CGO基础<br>2.3 类型转换<br>2.4 函数调用<br>2.5 内部机制<br>2.6 实战: 封装qsort<br>2.7 CGO内存模型<br>2.8 C++类包装<br>2.9 静态库和动态库<br>2.10 编译和链接参数<br>2.11 补充说明<br>第3章 汇编语言<br>3.1 快速入门<br>3.2 计算机结构<br>3.3 常量和全局变量<br>3.4 函数<br>3.5 控制流<br>3.6 再论函数<br>3.7 汇编语言的威力<br>3.8 例子：Goroutine ID<br>3.9 Delve调试器<br>3.10 补充说明<br>第4章 RPC和Protobuf<br>4.1 RPC入门<br>4.2 Protobuf<br>4.3 玩转RPC<br>4.4 gRPC入门<br>4.5 gRPC进阶<br>4.6 gRPC和Protobuf扩展<br>4.7 pbgo: 基于Protobuf的框架<br>4.8 grpcurl工具<br>4.9 补充说明<br>第5章 Go和Web<br>5.1 Web开发简介<br>5.2 请求路由<br>5.3 中间件<br>5.4 请求校验<br>5.5 和数据库打交道<br>5.6 服务流量限制<br>5.7 大型Web项目分层<br>5.8 接口和表驱动开发<br>5.9 灰度发布和A&#x2F;B测试<br>5.10 补充说明<br>第6章 分布式系统<br>6.1 分布式 id 生成器<br>6.2 分布式锁<br>6.3 延时任务系统<br>6.4 分布式搜索引擎<br>6.5 负载均衡<br>6.6 分布式配置管理<br>6.7 分布式爬虫<br>6.8 补充说明<br>附录<br>附录A: Go语言常见坑<br>附录B: 有趣的代码片段</p><h3 id="Go语言高级编程-PDF-下载地址"><a href="#Go语言高级编程-PDF-下载地址" class="headerlink" title="Go语言高级编程 PDF 下载地址:"></a>Go语言高级编程 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Chsb8grxKKCd8CJNHG9lXg?pwd=1lli">https://pan.baidu.com/s/1Chsb8grxKKCd8CJNHG9lXg?pwd=1lli</a> </p><p>提取码：1lli</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Go语言编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kubernetes权威指南：从Docker到Kubernetes实践全接触》</title>
      <link href="/2023/05/24/Kubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6/"/>
      <url>/2023/05/24/Kubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/lorogawptmcytwkuacpqwzjp.png" alt="《Kubernetes权威指南：从Docker到Kubernetes实践全接触》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>Kubernetes是由谷歌开源的容器集群管理系统，为容器化应用提供了资源调度、部署运行、服务发现、扩缩容等一整套功能。Kubernetes也是将“一切以服务（Service）为中心，一切围绕服务运转”作为指导思想的创新型产品，它的功能和架构设计自始至终地遵循了这一指导思想。构建在Kubernetes上的系统不仅可以独立运行在物理机、虚拟机集群或者企业私有云上，也可以被托管在公有云上。</p><p>《Kubernetes权威指南：从Docker到Kubernetes实践全接触（第5版）》总计12章，分别讲解Kubernetes的基本概念、实践指南、核心原理、开发指南、网络与存储、运维指南、新特性演进等内容。全书图文并茂、内容丰富、由浅入深、讲解全面，并围绕在生产环境中可能出现的问题，给出了大量典型案例，比如安全配置方案、网络方案、共享存储方案、高可用方案及Trouble Shooting技巧等，有很强的实战指导意义。本书的内容也随着Kubernetes的版本更新不断完善，目前涵盖了Kubernetes从1.0到1.19版本的主要特性，努力为Kubernetes用户提供全方位的Kubernetes技术指南。</p><p>无论是对于软件工程师、软件架构师、测试工程师、运维工程师、技术经理，还是对于资深IT人士，本书都极具参考价值。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>·龚正·</p><p>HPE高级顾问，从事IT工作20余年，在云计算、大数据、大型企业级应用等领域有丰富的咨询规划、架构设计和实施经验，负责过多个大型云平台的规划和建设，是电信、金融、互联网等领域的资深专家，也是《Kubernetes权威指南：企业级容器云实战》等书的作者。</p><p>·吴治辉·</p><p>HPE资深架构师，从事软件研发工作20余年，专注于电信软件和云计算方面的软件研发，有丰富的大型项目架构设计经验，是业界少有的具备很强编程能力的资深架构师，也是《ZeroCIce权威指南》《架构解密：从分布式到微服务》《Kubernetes权威指南：企业级容器云实战》《区块链轻松上手》等书的作者。</p><p>·闫健勇·</p><p>HPE高级项目经理、总架构师，从事电信行业系统建设工作20余年，主导了多项电信大型系统的架构设计和管理，对云计算和大数据在电信行业中的应用有丰富的经验，也是《Kubernetes权威指南：企业级容器云实战》等书的作者。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 Kubernetes入门 1<br>1.1 了解Kubernetes 2<br>1.2 为什么要用Kubernetes 5<br>1.3 从一个简单的例子开始 7<br>1.3.1 环境准备 8<br>1.3.2 启动MySQL服务 8<br>1.3.3 启动Tomcat应用 11<br>1.3.4 通过浏览器访问网页 12<br>1.4 Kubernetes的基本概念和术语 14<br>1.4.1 资源对象概述 14<br>1.4.2 集群类 15<br>1.4.3 应用类 19<br>1.4.4 存储类 40<br>1.4.5 安全类 44<br>第2章 Kubernetes安装配置指南 47<br>2.1 系统要求 48<br>2.2 使用kubeadm工具快速安装Kubernetes集群 49<br>2.2.1 安装kubeadm 50<br>2.2.2 修改kubeadm的默认配置 50<br>2.2.3 下载Kubernetes的相关镜像 51<br>2.2.4 运行kubeadm init命令安装Master节点 52<br>2.2.5 将新的Node加入集群 57<br>2.2.6 安装CNI网络插件 59<br>2.2.7 验证Kubernetes集群是否工作正常 60<br>2.3 以二进制文件方式安装Kubernetes安全高可用集群 61<br>2.3.1 Master高可用部署架构 61<br>2.3.2 创建CA根证书 62<br>2.3.3 部署安全的etcd高可用集群 63<br>2.3.4 部署安全的Kubernetes Master高可用集群 68<br>2.3.5 部署Node的服务 85<br>2.3.6 kube-apiserver基于token的认证机制 89<br>2.4 使用私有镜像库的相关配置 90<br>2.5 Kubernetes的版本升级 91<br>2.5.1 二进制文件升级 91<br>2.5.2 使用kubeadm进行集群升级 92<br>2.6 CRI（容器运行时接口）详解 94<br>2.6.1 CRI概述 94<br>2.6.2 CRI的主要组件 94<br>2.6.3 Pod和容器的生命周期管理 95<br>2.6.4 面向容器级别的设计思路 96<br>2.6.5 尝试使用新的Docker-CRI来创建容器 97<br>2.6.6 CRI的进展 98<br>2.7 kubectl命令行工具用法详解 98<br>2.7.1 kubectl用法概述 99<br>2.7.2 kubectl子命令详解 99<br>2.7.3 kubectl可操作的资源对象详解 103<br>2.7.4 kubectl的公共参数说明 105<br>2.7.5 kubectl格式化输出 106<br>2.7.6 kubectl常用操作示例 108<br>第3章 深入掌握Pod 113<br>3.1 Pod定义详解 114<br>3.2 Pod的基本用法 120<br>3.3 静态Pod 125<br>3.4 Pod容器共享Volume 126<br>3.5 Pod的配置管理 129<br>3.5.1 ConfigMap概述 129<br>3.5.2 创建ConfigMap资源对象 129<br>3.5.3 在Pod中使用ConfigMap 137<br>3.5.4 使用ConfigMap的限制条件 143<br>3.6 在容器内获取Pod信息（Downward API） 144<br>3.6.1 环境变量方式 144<br>3.6.2 Volume挂载方式 148<br>3.6.3 Downward API支持设置的Pod和Container信息 153<br>3.7 Pod生命周期和重启策略 154<br>3.8 Pod健康检查和服务可用性检查 155<br>3.9 玩转Pod调度 159<br>3.9.1 Deployment或RC：全自动调度 162<br>3.9.2 NodeSelector：定向调度 163<br>3.9.3 NodeAffinity：Node亲和性调度 165<br>3.9.4 PodAffinity：Pod亲和与互斥调度策略 167<br>3.9.5 Taints和Tolerations（污点和容忍） 171<br>3.9.6 Pod Priority Preemption：Pod优先级调度 176<br>3.9.7 DaemonSet：在每个Node上都调度一个Pod 178<br>3.9.8 Job：批处理调度 181<br>3.9.9 Cronjob：定时任务 185<br>3.9.10 自定义调度器 188<br>3.9.11 Pod容灾调度 190<br>3.10 Init Container（初始化容器） 192<br>3.11 Pod的升级和回滚 196<br>3.11.1 Deployment的升级 196<br>3.11.2 Deployment的回滚 203<br>3.11.3 暂停和恢复Deployment的部署操作 205<br>3.11.4 其他管理对象的更新策略 207<br>3.12 Pod的扩缩容 209<br>3.12.1 手动扩缩容机制 209<br>3.12.2 自动扩缩容机制 211<br>3.13 使用StatefulSet搭建MongoDB集群 233<br>3.13.1 前提条件 234<br>3.13.2 部署StatefulSet 234<br>3.13.3 查看MongoDB集群的状态 238<br>3.13.4 StatefulSet的常见应用场景 241<br>第4章 深入掌握Service 245<br>4.1 Service定义详解 246<br>4.2 Service的概念和原理 248<br>4.2.1 Service的概念 248<br>4.2.2 Service的负载均衡机制 252<br>4.2.3 Service的多端口设置 254<br>4.2.4 将外部服务定义为Service 256<br>4.2.5 将Service暴露到集群外部 257<br>4.2.6 Service支持的网络协议 260<br>4.2.7 Kubernetes的服务发现机制 261<br>4.2.8 Headless Service的概念和应用 263<br>4.2.9 端点分片与服务拓扑 265<br>4.3 DNS服务搭建和配置指南 274<br>4.3.1 修改每个Node上kubelet的DNS启动参数 276<br>4.3.2 部署CoreDNS服务 276<br>4.3.3 服务名的DNS解析 280<br>4.3.4 CoreDNS的配置说明 282<br>4.4 Node本地DNS缓存 284<br>4.5 Pod的DNS域名相关特性 291<br>4.5.1 Pod的DNS域名 291<br>4.5.2 为Pod自定义hostname和subdomain 292<br>4.5.3 Pod的DNS策略 294<br>4.5.4 Pod中的自定义DNS配置 295<br>4.6 Ingress 7层路由机制 297<br>4.6.1 一个完整的例子（Ingress Controller+Ingress策略+客户端访问） 298<br>4.6.2 Ingress资源对象详解 309<br>4.6.3 Ingress策略配置详解 315<br>4.6.4 Ingress的TLS安全设置 319<br>第5章 核心组件的运行机制 326<br>5.1 Kubernetes API Server原理解析 327<br>5.1.1 Kubernetes API Server概述 327<br>5.1.2 API Server架构解析 330<br>5.1.3 独特的Kubernetes Proxy API接口 335<br>5.1.4 集群功能模块之间的通信 336<br>5.1.5 API Server网络隔离的设计 338<br>5.2 Controller Manager原理解析 339<br>5.2.1 副本调度控制器 340<br>5.2.2 Node Controller 342<br>5.2.3 ResourceQuota Controller 343<br>5.2.4 Namespace Controller 345<br>5.2.5 Service Controller与Endpoints Controller 345<br>5.3 Scheduler原理解析 346<br>5.3.1 Scheduler的调度流程 347<br>5.3.2 Scheduler Framework 349<br>5.3.3 多调度器特性 351<br>5.4 kubelet运行机制解析 352<br>5.4.1 节点管理 352<br>5.4.2 Pod管理 353<br>5.4.3 容器健康检查 354<br>5.4.4 cAdvisor资源监控 355<br>5.4.5 容器运行时 357<br>5.5 kube-proxy运行机制解析 359<br>5.5.1 第一代Proxy 360<br>5.5.2 第二代Proxy 361<br>5.5.2 第三代Proxy 362<br>第6章 深入分析集群安全机制 364<br>6.1 API Server认证管理 365<br>6.1.1 HTTPS证书认证 366<br>6.1.2 HTTP Bearer Token认证 367<br>6.1.3 OpenID Connect Token第三方认证 368<br>6.1.4 Authenticating Proxy（认证代理） 372<br>6.2 API Server授权管理 373<br>6.2.1 ABAC授权模式详解 374<br>6.2.2 Webhook授权模式详解 377<br>6.2.3 RBAC授权模式详解 380<br>6.2.4 Node授权模式详解 405<br>6.3 Admission Control 406<br>6.4 Service Account 410<br>6.5 Secret私密凭据 415<br>6.6 Pod安全策略 419<br>6.6.1 PodSecurityPolicy的工作机制 419<br>6.6.2 PodSecurityPolicy配置详解 421<br>6.6.3 PodSecurityPolicy策略示例 427<br>6.6.4 PodSecurityPolicy的RBAC授权 431<br>6.6.5 Pod安全设置（Security Context）详解 436<br>第7章 网络原理 445<br>7.1 Kubernetes网络模型 446<br>7.2 Docker网络基础 448<br>7.2.1 网络命名空间 448<br>7.2.2 Veth设备对 451<br>7.2.3 网桥 454<br>7.2.4 iptables和Netfilter 456<br>7.2.5 路由 459<br>7.3 Docker的网络实现 461<br>7.3.1 查看Docker启动后的系统情况 463<br>7.3.2 查看容器启动后的网络配置（容器无端口映射） 465<br>7.3.3 查看容器启动后的网络配置（容器有端口映射） 468<br>7.3.4 Docker的网络局限性 469<br>7.4 Kubernetes的网络实现 470<br>7.4.1 容器到容器的通信 470<br>7.4.2 Pod之间的通信 471<br>7.5 Pod和Service网络实战 474<br>7.5.1 部署一个RC&#x2F;Pod 476<br>7.5.2 发布一个服务 481<br>7.6 CNI网络模型 489<br>7.6.1 CNM网络模型简介 489<br>7.6.2 CNI网络模型详解 490<br>7.6.3 在Kubernetes中使用网络插件 507<br>7.7 开源容器网络方案 508<br>7.7.1 Flannel插件的原理和部署示例 508<br>7.7.2 Open vSwitch插件的原理和部署示例 513<br>7.7.3 直接路由的原理和部署示例 518<br>7.7.4 Calico插件的原理和部署示例 521<br>7.8 Kubernetes的网络策略 541<br>7.8.1 网络策略设置说明 542<br>7.8.2 Selector功能说明 544<br>7.8.3 为命名空间配置默认的网络策略 545<br>7.8.4 网络策略应用示例 547<br>7.8.5 NetworkPolicy的发展 550<br>7.9 Kubernetes对IPv4和IPv6双栈的支持 551<br>7.9.1 为Kubernetes集群启用IPv4和IPv6双栈 551<br>7.9.2 Pod双栈IP地址验证 554<br>7.9.3 Service双栈IP地址验证 557<br>第8章 存储原理和应用 560<br>8.1 Kubernetes存储机制概述 561<br>8.1.1 将资源对象映射为存储卷 562<br>8.1.2 Node本地存储卷 569<br>8.2 持久卷（Persistent Volume）详解 573<br>8.2.1 PV和PVC的工作原理 574<br>8.2.2 PV详解 581<br>8.2.3 PVC详解 587<br>8.2.4 Pod使用PVC 589<br>8.2.5 StorageClass详解 593<br>8.3 动态存储管理实战：GlusterFS 600<br>8.3.1 准备工作 600<br>8.3.2 创建GlusterFS管理服务容器集群 600<br>8.3.3 创建Heketi服务 603<br>8.3.4 通过Heketi管理GlusterFS集群 607<br>8.3.5 定义StorageClass 610<br>8.3.6 定义PVC 610<br>8.3.7 Pod使用PVC的存储资源 613<br>8.4 CSI存储机制详解 614<br>8.4.1 CSI的设计背景 614<br>8.4.2 CSI的核心组件和部署架构 615<br>8.4.3 CSI存储插件应用实战 617<br>8.4.4 CSI存储快照管理 632<br>8.4.5 CSI的发展 638<br>第9章 Kubernetes开发指南 647<br>9.1 REST简述 648<br>9.2 Kubernetes API详解 650<br>9.2.1 Kubernetes API概述 650<br>9.2.2 Kubernetes API版本的演进策略 658<br>9.2.3 API Groups（API组） 658<br>9.2.4 API REST的方法说明 661<br>9.2.5 API Server响应说明 663<br>9.3 使用Fabric8访问Kubernetes API 665<br>9.3.1 具体应用示例 666<br>9.3.2 其他客户端库 679<br>9.4 Kubernetes API的扩展 680<br>9.4.1 使用CRD扩展API资源 681<br>9.4.2 使用API聚合机制扩展API资源 692<br>第10章 Kubernetes运维管理 702<br>10.1 Node管理 703<br>10.1.1 Node的隔离与恢复 703<br>10.1.2 Node的扩容 704<br>10.2 更新资源对象的Label 705<br>10.3 Namespace：集群环境共享与隔离 706<br>10.3.1 创建Namespace 706<br>10.3.2 定义Context 707<br>10.3.3 设置工作组在特定Context中工作 708<br>10.4 Kubernetes资源管理 710<br>10.4.1 计算资源管理 712<br>10.4.2 资源配置范围管理（LimitRange） 722<br>10.4.3 资源服务质量管理（Resource QoS） 730<br>10.4.4 资源配额管理（Resource Quotas） 738<br>10.4.5 ResourceQuota和LimitRange实践 744<br>10.4.6 Pod中多个容器共享进程命名空间 754<br>10.4.7 PID资源管理 757<br>10.4.8 节点的CPU管理策略 757<br>10.4.9 拓扑管理器 761<br>10.5 资源紧缺时的Pod驱逐机制 766<br>10.5.1 驱逐时机 766<br>10.5.2 驱逐阈值 767<br>10.5.3 节点状态 768<br>10.5.4 节点状态的振荡 769<br>10.5.5 回收Node级别的资源 769<br>10.5.6 驱逐用户的Pod 770<br>10.5.7 资源最少回收量 771<br>10.5.8 节点资源紧缺情况下的系统行为 772<br>10.5.9 可调度的资源和驱逐策略实践 773<br>10.5.10 现阶段的问题 773<br>10.6 Pod Disruption Budget（主动驱逐保护） 774<br>10.7 Kubernetes集群监控 778<br>10.7.1 使用Metrics Server监控Node和Pod的CPU和内存使用数据 778<br>10.7.2 Prometheus+Grafana集群性能监控平台搭建 783<br>10.8 Kubernetes集群日志管理 803<br>10.8.1 容器应用和系统组件输出日志的各种场景 803<br>10.8.2 Fluentd+Elasticsearch+Kibana日志系统部署 807<br>10.8.3 部署日志采集sidecar工具采集容器日志 821<br>10.9 Kubernetes的审计机制 822<br>10.10 使用Web UI（Dashboard）管理集群 826<br>10.11 Helm：Kubernetes应用包管理工具 839<br>10.11.1 Helm的整体架构 840<br>10.11.2 Helm版本说明 840<br>10.11.3 Helm的安装 842<br>10.11.4 Helm的使用 843<br>10.11.5 Chart说明 857<br>10.11.6 搭建私有Chart仓库 858<br>第11章 Trouble Shooting指南 862<br>11.1 查看系统Event 863<br>11.2 查看容器日志 865<br>11.3 查看Kubernetes服务日志 866<br>11.4 常见问题 868<br>11.4.1 由于无法下载pause镜像导致Pod一直处于Pending状态 868<br>11.4.2 Pod创建成功，但RESTARTS数量持续增加 870<br>11.4.3 通过服务名无法访问服务 871<br>11.5 寻求帮助 872<br>第12章 Kubernetes开发中的新功能 875<br>12.1 对Windows容器的支持 876<br>12.1.1 在Windows Server上安装Docker 876<br>12.1.2 在Windows Server上部署Kubernetes Node组件 877<br>12.1.3 在Windows Server上部署容器应用和服务 886<br>12.1.4 Kubernetes支持的Windows容器特性、限制和发展趋势 892<br>12.2 对GPU的支持 896<br>12.2.1 环境准备 897<br>12.2.2 在容器中使用GPU资源 900<br>12.2.3 发展趋势 902<br>12.3 Pod的垂直扩缩容 902<br>12.3.1 VPA详解 903<br>12.3.2 安装Vertical Pod Autoscaler 906<br>12.3.3 为Pod设置垂直扩缩容 906<br>12.3.4 注意事项 907<br>12.4 Kubernetes生态系统与演进路线 908<br>12.4.1 Kubernetes与CNCF 908<br>12.4.2 Kubernetes的演进路线 910<br>12.4.3 Kubernetes的开发模式 914<br>附录A Kubernetes核心服务配置详解 915</p><h3 id="Kubernetes权威指南：从Docker到Kubernetes实践全接触-PDF-下载地址"><a href="#Kubernetes权威指南：从Docker到Kubernetes实践全接触-PDF-下载地址" class="headerlink" title="Kubernetes权威指南：从Docker到Kubernetes实践全接触 PDF 下载地址:"></a>Kubernetes权威指南：从Docker到Kubernetes实践全接触 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/10h6b_BpJcqYDBuhogOm_oA?pwd=5lqf">https://pan.baidu.com/s/10h6b_BpJcqYDBuhogOm_oA?pwd=5lqf</a> </p><p>提取码：5lqf</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go并发编程实战（第2版）》</title>
      <link href="/2023/05/24/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/24/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/fe6fe0ca4452413f25f54d4132c79620.png" alt="《Go并发编程实战（第2版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书首先介绍了Go语言的优秀特性、安装设置方法、工程结构、标准命令和工具、语法基础、数据类型以及流程控制方法，接着阐述了与多进程编程和多线程编程有关的知识，然后重点介绍了goroutine、channel以及Go提供的传统同步方法，最后通过一个完整实例——网络爬虫框架进一步阐述Go语言的哲学和理念，同时分享作者在多年编程生涯中的一些见解和感悟。</p><p>与上一版相比，本书不仅基于Go 1.8对上一版进行了全面更新，而且更深入地描绘了Go运行时系统的内部机理，并且大幅改进了示例代码。</p><p>本书适用于有一定计算机编程基础的从业者以及对Go语言编程感兴趣的爱好者，非常适合作为Go语言编程进阶教程。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>郝林 从业12年有余的软件工匠，国内知名的Go语言技术布道者，Go语言北京用户组和GoHackers社群的发起人和组织者，多套免费在线Go语言教程的作者，深信Go语言在人工智能时代和机器人时代也能大放异彩的科技信徒。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　初识Go语言　　1<br>1.1　语言特性　　1<br>1.2　安装和设置　　2<br>1.3　工程结构　　3<br>1.3.1　工作区　　3<br>1.3.2　GOPATH　　4<br>1.3.3　源码文件　　5<br>1.3.4　代码包　　8<br>1.4　标准命令简述　　11<br>1.5　问候程序　　13<br>1.6　小结　　14<br>第2章　语法概览　　15<br>2.1　基本构成要素　　15<br>2.1.1　标识符　　15<br>2.1.2　关键字　　16<br>2.1.3　字面量　　17<br>2.1.4　操作符　　17<br>2.1.5　表达式　　19<br>2.2　基本类型　　20<br>2.3　高级类型　　22<br>2.3.1　数组　　23<br>2.3.2　切片　　23<br>2.3.3　字典　　24<br>2.3.4　函数和方法　　25<br>2.3.5　接口　　28<br>2.3.6　结构体　　29<br>2.4　流程控制　　30<br>2.4.1　代码块和作用域　　30<br>2.4.2　if语句　　32<br>2.4.3　switch语句　　32<br>2.4.4　for语句　　34<br>2.4.5　defer语句　　36<br>2.4.6　panic和recover　　38<br>2.5　聊天机器人　　40<br>2.6　小结　　44<br>第3章　并发编程综述　　45<br>3.1　并发编程基础　　45<br>3.1.1　串行程序与并发程序　　46<br>3.1.2　并发程序与并行程序　　46<br>3.1.3　并发程序与并发系统　　47<br>3.1.4　并发程序的不确定性　　47<br>3.1.5　并发程序内部的交互　　47<br>3.2　多进程编程　　48<br>3.2.1　进程　　48<br>3.2.2　关于同步　　55<br>3.2.3　管道　　60<br>3.2.4　信号　　65<br>3.2.5　socket　　74<br>3.3　多线程编程　　97<br>3.3.1　线程　　98<br>3.3.2　线程的同步　　107<br>3.4　多线程与多进程　　125<br>3.5　多核时代的并发编程　　126<br>3.6　小结　　130<br>第4章　Go的并发机制　　131<br>4.1　原理探究　　131<br>4.1.1　线程实现模型　　132<br>4.1.2　调度器　　142<br>4.1.3　更多细节　　158<br>4.2　goroutine　　160<br>4.2.1　go语句与goroutine　　160<br>4.2.2　主goroutine的运作　　166<br>4.2.3　runtime包与goroutine　　166<br>4.3　channel　　169<br>4.3.1　channel的基本概念　　169<br>4.3.2　单向channel　　180<br>4.3.3　for语句与channel　　184<br>4.3.4　select语句　　185<br>4.3.5　非缓冲的channel　　190<br>4.3.6　time包与channel　　192<br>4.4　实战演练：载荷发生器　　198<br>4.4.1　参数和结果　　199<br>4.4.2　基本结构　　201<br>4.4.3　初始化　　206<br>4.4.4　启动和停止　　212<br>4.4.5　调用器和功能测试　　221<br>4.5　小结　　231<br>第5章　同　　步　　232<br>5.1　锁的使用　　232<br>5.1.1　互斥锁　　232<br>5.1.2　读写锁　　236<br>5.1.3　锁的完整示例　　238<br>5.2　条件变量　　244<br>5.3　原子操作　　247<br>5.3.1　增或减　　247<br>5.3.2　比较并交换　　249<br>5.3.3　载入　　250<br>5.3.4　存储　　251<br>5.3.5　交换　　251<br>5.3.6　原子值　　252<br>5.3.7　应用于实际　　256<br>5.4　只会执行一次　　257<br>5.5　WaitGroup　　258<br>5.6　临时对象池　　262<br>5.7　实战演练——ConcurrentMap　　265<br>5.8　小结　　280<br>第6章　网络爬虫框架设计和实现　　281<br>6.1　网络爬虫与框架　　281<br>6.2　功能需求和分析　　283<br>6.3　总体设计　　284<br>6.4　详细设计　　286<br>6.4.1　基本数据结构　　286<br>6.4.2　接口的设计　　293<br>6.5　工具的实现　　309<br>6.5.1　缓冲器　　309<br>6.5.2　缓冲池　　311<br>6.5.3　多重读取器　　317<br>6.6　组件的实现　　318<br>6.6.1　内部基础接口　　319<br>6.6.2　组件注册器　　321<br>6.6.3　下载器　　323<br>6.6.4　分析器　　325<br>6.6.5　条目处理管道　　328<br>6.7　调度器的实现　　329<br>6.7.1　基本结构　　329<br>6.7.2　初始化　　331<br>6.7.3　启动　　333<br>6.7.4　停止　　343<br>6.7.5　其他方法　　344<br>6.7.6　总结　　345<br>6.8　一个简单的图片爬虫　　346<br>6.8.1　概述　　346<br>6.8.2　命令参数　　346<br>6.8.3　初始化调度器　　348<br>6.8.4　监控调度器　　354<br>6.8.5　启动调度器　　364<br>6.9　扩展与思路　　365<br>6.10　本章小结　　368<br>附录A　Go语言的学习资源　　369</p><h3 id="Go并发编程实战（第2版）-PDF-下载地址"><a href="#Go并发编程实战（第2版）-PDF-下载地址" class="headerlink" title="Go并发编程实战（第2版） PDF 下载地址:"></a>Go并发编程实战（第2版） PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1FZjrtblTQGRnZDPxGo0WVg?pwd=7oo9">https://pan.baidu.com/s/1FZjrtblTQGRnZDPxGo0WVg?pwd=7oo9</a> </p><p>提取码：7oo9</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《DevOps实践指南》</title>
      <link href="/2023/05/23/DevOps%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/23/DevOps%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/c9c87291194e8042c6dd80f9f4756516.png" alt="《DevOps实践指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书共分为6个部分：第一部分概述DevOps的历史和三个基本原则，即“三步工作法”；第二部分介绍开启DevOps转型的过程；第三到五部分深入探讨“三步工作法”的各个要素；第六部分关注如何将安全性和合规性正确集成到日常工作中。全书涵盖40余个DevOps案例，以谷歌、亚马逊、Facebook等全球知名企业和组织的实际调查结果为依据，展示如何通过现代化的运维管理提升管理效率，进而为企业赢得更大市场、创造更多利润。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Gene Kim</p><p>Tripwire创始人、前CTO，IT Revolution创始人，DevOps企业峰会主办人，畅销书《凤凰项目》合著者。</p><p>Jez Humble</p><p>DevOps Research and Assessment公司CTO，加州大学伯克利分校信息学院讲师；曾任ThoughtWorks首席顾问。《精益企业》和Jolt大奖图书《持续交付》的合著者。</p><p>Patrick Debois</p><p>DevOps之父，致力于通过在开发、项目管理和系统管理之中应用敏捷技术来填补项目和运维之间的鸿沟。</p><p>John Willis</p><p>Chain Bridge System创始人，曾任Docker公司布道师，现就职于SJ Technologies公司。</p><p>译者简介：</p><p>刘征</p><p>Nutanix路坦力资深架构师，EXIN首批国内DevOps Master和DevOps Professional认证讲师，持有红帽RHCA认证和AWS高级架构师认证，谙熟企业数据中心的IT服务管理。目前致力于推广DevOps相关的理念和实践，在DevOps社区中积极地参与培训和研讨会等活动，是DevOpsDays大会社区在中国的核心组织者和志愿工作者。</p><p>王磊</p><p>前ThoughtWorks咨询师，EXIN首批国内DevOps Master认证讲师。拥有10多年软件行业经验，以及服务化架构、持续交付和DevOps转型等方面的丰富实践经验。国内较早倡导和实践微服务的先行者，著有国内首本微服务架构相关图书《微服务架构与实践》，是西安DevOps Meetup活动的联合发起人。</p><p>马博文</p><p>前ThoughtWorks咨询师，AWS认证助理架构师、开发者。拥有多年Web开发和DevOps经验，熟悉持续交付、微服务。曾参与翻译《Scala编程实战》《DevOps实践》等书，是西安DevOps Meetup活动的发起人。</p><p>曾朝京</p><p>Micro Focus资深解决方案顾问，曾参加EXIN首批国内Devops Master讲师认证培训。长期从事IT运维管理领域咨询工作，曾为能源、金融、航空运输、政府行业中的多个大型企业提供IT运维管理规划。目前致力于探索DevOps理念在企业IT部门的实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　DevOps介绍<br>第1章　敏捷、持续交付和三步法　　4<br>1.1　制造业价值流　　4<br>1.2　技术价值流　　4<br>1.2.1　聚焦于部署前置时间　　5<br>1.2.2　关注返工指标——%C&#x2F;A　　7<br>1.3　三步工作法：DevOps的基础原则　　7<br>1.4　小结　　8<br>第2章　第一步：流动原则　　9<br>2.1　使工作可见　　9<br>2.2　限制在制品数　　10<br>2.3　减小批量大小　　11<br>2.4　减少交接次数　　13<br>2.5　持续识别和改善约束点　　14<br>2.6　消除价值流中的困境和浪费　　15<br>2.7　小结　　16<br>第3章　第二步：反馈原则　　17<br>3.1　在复杂系统中安全地工作　　17<br>3.2　及时发现问题　　18<br>3.3　群策群力，战胜问题获取新知　　19<br>3.4　在源头保障质量　　21<br>3.5　为下游工作中心而优化　　22<br>3.6　小结　　22<br>第4章　第三步：持续学习与实验原则　　23<br>4.1　建立学习型组织和安全文化　　23<br>4.2　将日常工作的改进制度化　　25<br>4.3　把局部发现转化为全局优化　　26<br>4.4　在日常工作中注入弹性模式　　27<br>4.5　领导层强化学习文化　　27<br>4.6　小结　　29<br>4.7　第一部分总结　　29<br>第二部分　从何处开始<br>第5章　选择合适的价值流作为切入点　　32<br>5.1　绿地项目与棕地项目　　34<br>5.2　兼顾记录型系统和交互型系统　　35<br>5.3　从最乐于创新的团队开始　　36<br>5.4　扩大DevOps的范围　　37<br>5.5　小结　　38<br>第6章　理解、可视化和运用价值流　　39<br>6.1　确定创造客户价值所需的团队　　40<br>6.2　针对团队工作绘制价值流图　　40<br>6.3　组建专门的转型团队　　42<br>6.3.1　拥有共同的目标　　43<br>6.3.2　保持小跨度的改进计划　　44<br>6.3.3　为非功能性需求预留20%的<br>开发时间，减少技术债务　　44<br>6.3.4　提高工作的可视化程度　　47<br>6.4　用工具强化预期行为　　47<br>6.5　小结　　48<br>第7章　参考康威定律设计组织结构　　49<br>7.1　组织原型　　51<br>7.2　过度职能导向的危害（“成本优化”）　　51<br>7.3　组建以市场为导向的团队（“速度优化”）　　52<br>7.4　使职能导向有效　　53<br>7.5　将测试、运维和信息安全融入日常工作　　54<br>7.6　使团队成员都成为通才　　54<br>7.7　投资于服务和产品，而非项目　　56<br>7.8　根据康威定律设定团队边界　　56<br>7.9　创建松耦合架构，提高生产力和安全性　　57<br>7.10　小结　　60<br>第8章　将运维融入日常开发工作　　61<br>8.1　创建共享服务，提高开发生产力　　62<br>8.2　将运维工程师融入服务团队　　63<br>8.3　为每个服务团队分派运维联络人　　64<br>8.4　邀请运维工程师参加开发团队的会议　　65<br>8.4.1　邀请运维工程师参加每日站会　　65<br>8.4.2　邀请运维工程师参加回顾会议　　66<br>8.4.3　使用看板图展示运维工作　　66<br>8.5　小结　　67<br>8.6　第二部分总结　　67<br>第三部分　第一步：流动的技术实践<br>第9章　为部署流水线奠定基础　　70<br>9.1　按需搭建开发环境、测试环境和生产环境　　71<br>9.2　应用统一的代码仓库　　72<br>9.3　使基础设施的重建更容易　　74<br>9.4　运行在类生产环境里才算“完成”　　75<br>9.5　小结　　76<br>第10章　实现快速可靠的自动化测试　　77<br>10.1　对代码和环境做持续构建、测试和集成　　79<br>10.2　构建快速可靠的自动化测试套件　　81<br>10.2.1　在自动化测试中尽早发现<br>错误　　83<br>10.2.2　尽可能并行地快速执行测试　　84<br>10.2.3　先编写自动化测试　　84<br>10.2.4　尽量将手动测试自动化　　85<br>10.2.5　在测试套件中集成性能测试　　86<br>10.2.6　在测试套件中集成非功能性需求测试　　86<br>10.3　在部署流水线失败时拉下安灯绳　　87<br>10.4　小结　　89<br>第11章　应用和实践持续集成　　90<br>11.1　小批量开发与大批量合并　　92<br>11.2　应用基于主干的开发实践　　93<br>11.3　小结　　95<br>第12章　自动化和低风险发布　　96<br>12.1　自动化部署流程　　97<br>12.1.1　应用自动化的自助式部署　　100<br>12.1.2　在部署流水线中集成代码部署　　101<br>12.2　将部署与发布解耦　　104<br>12.2.1　基于环境的发布模式　　105<br>12.2.2　基于应用的发布模式更安全　　109<br>12.3　持续交付和持续部署实践的调查　　112<br>12.4　小结　　113<br>第13章　降低发布风险的架构　　114<br>13.1　能提高生产力、可测试性和安全性的架构　　115<br>13.2　架构原型：单体架构与微服务　　116<br>13.3　安全地演进企业架构　　118<br>13.4　小结　　121<br>13.5　第三部分总结　　121<br>第四部分　第二步：反馈的技术实践<br>第14章　建立能发现并解决问题的遥测系统　　125<br>14.1　建设集中式监控架构　　127<br>14.2　建立生产环境的应用程序日志遥测　　129<br>14.3　使用遥测指导问题的解决　　131<br>14.4　将建立生产遥测融入日常工作　　132<br>14.5　建立自助访问的遥测和信息辐射器　　133<br>14.6　发现和填补遥测的盲区　　135<br>14.6.1　应用程序和业务度量指标　　136<br>14.6.2　基础架构度量指标　　137<br>14.6.3　显示叠加的指标组合　　138<br>14.7　小结　　139<br>第15章　分析遥测数据以更好地预测故障和实现目标　　140<br>15.1　用均值和标准差识别潜在问题　　141<br>15.2　异常状态的处理和告警　　142<br>15.3　非高斯分布遥测数据的问题　　143<br>15.4　应用异常检测技术　　146<br>15.5　小结　　149<br>第16章　应用反馈实现安全部署　　150<br>16.1　通过遥测使部署更安全　　151<br>16.2　开发和运维共同承担值班工作　　153<br>16.3　让开发人员跟踪工作对下游的影响　　153<br>16.4　让开发人员自行管理生产服务　　155<br>16.5　小结　　159<br>第17章　将假设驱动的开发和A&#x2F;B测试融入日常工作　　160<br>17.1　A&#x2F;B测试简史　　161<br>17.2　在功能测试中集成A&#x2F;B测试　　162<br>17.3　在发布中集成A&#x2F;B测试　　162<br>17.4　在功能规划中集成A&#x2F;B测试　　163<br>17.5　小结　　165<br>第18章　建立评审和协作流程以提升当前工作的质量　　166<br>18.1　变更审批流程的危险　　168<br>18.2 “过度控制变更”的潜在危险　　168<br>18.3　变更的协调和排程　　170<br>18.4　变更的同行评审　　170<br>18.5　人工测试和变更冻结的潜在危害　　173<br>18.6　利用结对编程改进代码变更　　173<br>18.7　消除官僚流程　　176<br>18.8　小结　　177<br>18.9　第四部分总结　　178<br>第五部分　第三步：持续学习与实验的技术实践<br>第19章　将学习融入日常工作　　180<br>19.1　建立公正和学习的文化　　181<br>19.2　举行不指责的事后分析会议　　182<br>19.3　尽可能广泛地公开事后分析会议结果　　184<br>19.4　降低事故容忍度，寻找更弱的故障信号　　185<br>19.5　重新定义失败，鼓励评估风险　　186<br>19.6　在生产环境注入故障来恢复和学习　　186<br>19.7　创建故障演练日　　187<br>19.8　小结　　189<br>第20章　将局部经验转化为全局改进　　190<br>20.1　使用聊天室和聊天机器人自动积累组织知识　　190<br>20.2　软件中便于重用的自动化、标准化流程　　192<br>20.3　创建全组织共享的单一源代码库　　192<br>20.4　运用自动化测试记录和交流实践来传播知识　　194<br>20.5　通过确定非功能性需求来设计运维　　194<br>20.6　把可重用的运维用户故事纳入开发　　195<br>20.7　确保技术选型有助于实现组织目标　　195<br>20.8　小结　　197<br>第21章　预留组织学习和改进的时间　　198<br>21.1　偿还技术债务的制度化惯例　　199<br>21.2　让所有人教学相长　　200<br>21.3　在DevOps会议中分享经验　　201<br>21.4　传播实践的内部顾问和教练　　203<br>21.5　小结　　204<br>21.6　第五部分总结　　204<br>第六部分　集成信息安全、变更管理和合规性的技术实践<br>第22章　将信息安全融入每个人的日常工作　　207<br>22.1　将安全集成到开发迭代的演示中　　207<br>22.2　将安全集成到缺陷跟踪和事后分析会议中　　208<br>22.3　将预防性安全控制集成到共享源代码库及共享服务中　　208<br>22.4　将安全集成到部署流水线中　　209<br>22.5　保证应用程序的安全性　　210<br>22.6　确保软件供应链的安全　　214<br>22.7　确保环境的安全　　215<br>22.8　将信息安全集成到生产环境遥测中　　216<br>22.9　在应用程序中建立安全遥测系统　　217<br>22.10　在环境中建立安全遥测系统　　217<br>22.11　保护部署流水线　　219<br>22.12　小结　　219<br>第23章　保护部署流水线　　220<br>23.1　将安全和合规性集成到变更批准流程中　　220<br>23.2　将大量低风险变更重新归类为标准变更　　221<br>23.3　如何处理常规变更　　222<br>23.4　减少对职责分离的依赖　　224<br>23.5　确保为审计人员和合规人员留存文档和证据　　226<br>23.6　小结　　228<br>23.7　第六部分总结　　228行动起来——本书总结　　229<br>附加材料<br>附　　录　　232<br>附录1　DevOps的大融合　　232<br>附录2　约束理论和核心的长期<br>冲突　　234<br>附录3　恶性循环列表　　235<br>附录4　交接和队列的危害　　235<br>附录5　工业安全神话　　236<br>附录6　丰田安灯绳　　237<br>附录7　软件包产品　　238<br>附录8　事后分析会议　　238<br>附录9　猿猴军团　　239<br>附录10　上线时间透明化　　240<br>参考资源　　241<br>致　　谢　　243<br>EXIN DevOps Professional认证备考<br>指南 &amp; 模拟题①　　245</p><h3 id="DevOps实践指南-PDF-下载"><a href="#DevOps实践指南-PDF-下载" class="headerlink" title="DevOps实践指南 PDF 下载"></a>DevOps实践指南 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1RthGEPUoyj5VcUMwZIKapg?pwd=dw2y">https://pan.baidu.com/s/1RthGEPUoyj5VcUMwZIKapg?pwd=dw2y</a> </p><p>提取码：dw2y</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> DevOps </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript开发实战》</title>
      <link href="/2023/05/23/JavaScript%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/23/JavaScript%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/ece758c279279d142e46b17df4f21c5a.png" alt="《JavaScript开发实战》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScript开发实战》是一本 JavaScript 开发入门指导书，主要介绍了变量、对象、函数、数组、构造函数、方括号运算符、作用域、条件语句、模块、模型、视图、控制器、构建网页、控件、模板、数据加载等内容。书中涉及的概念都附有简短示例。此外，还有一个贯穿全书的持续示例 — 冒险游戏 The Crypt。读者可以在一个交互式网站上直接运行书中的代码。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>作者约翰·拉尔森是一名有30多年经验的程序员，精通JavaScript，也是一位经验丰富的教师。因此他深知读者在学习新知识、新技能过程中的困难，知道如何调动读者的积极性，帮助他们克服困难，并且善于用简洁的语言解释计算机语言的难点。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 控制台上的核心概念<br>第 1 章 编程、JavaScript 和 JS Bin<br>1.1 编程<br>1.2 JavaScript<br>1.3 在实践和思考中学习<br>1.4 JS Bin<br>1.4.1 JS Bin 面板<br>1.4.2 在 JS Bin 上运行代码清单<br>1.4.3 输出到控制台<br>1.4.4 代码注释<br>1.4.5 Further Adventures——进阶练习<br>1.4.6 错误消息<br>1.4.7 行号<br>1.4.8 获取账户<br>1.5 游戏 The Crypt——本书的一个持续示例<br>1.5.1 运行 The Crypt<br>1.5.2 创建 The Crypt 的具体步骤<br>1.6 更多示例和练习<br>1.7 浏览器的兼容性<br>1.8 本章小结<br>第 2 章 变量：在程序中存储数据<br>2.1 什么是变量<br>2.2 变量的声明和赋值<br>2.2.1 变量声明<br>2.2.2 变量赋值<br>2.2.3 一步实现变量声明和赋值<br>2.2.4 先运算再赋值<br>2.3 选择合适的变量名<br>2.3.1 关键字和保留字<br>2.3.2 变量的命名规则<br>2.3.3 骆驼式命名法（camelCase）<br>2.3.4 使用描述性变量名<br>2.4 The Crypt——玩家变量<br>2.5 本章小结<br>第 3 章 对象：数据分组<br>3.1 变量需要分组<br>3.2 创建对象<br>3.2.1 创建一个空对象<br>3.2.2 属性“键?值对”<br>3.3 访问对象的属性<br>3.4 更新对象的属性<br>3.5 其他示例<br>3.5.1 撰写一条博客<br>3.5.2 创建一个日历<br>3.5.3 天气怎么样？<br>3.5.4 一个小测验<br>3.5.5 创建自己的程序<br>3.6 游戏 The Crypt——玩家对象<br>3.7 本章小结<br>第 4 章 函数：按需执行代码<br>4.1 重复问题<br>4.1.1 将对象的属性作为文本进行显示<br>4.1.2 加税算出总成本<br>4.2 定义函数和调用函数<br>4.2.1 定义新函数<br>4.2.2 函数表达式和函数声明<br>4.2.3 使用函数<br>4.2.4 使用函数的步骤<br>4.3 减少重复<br>4.3.1 函数可用于将对象的属性作为文本进行显示<br>4.3.2 加税并显示总成本的函数<br>4.4 使代码易于阅读和更新<br>4.4.1 更新 showMovieInfo 函数<br>4.5 游戏 The Crypt——显示玩家的信息<br>4.5.1 用函数显示玩家的信息<br>4.6 本章小结<br>第 5 章 参数：将数据传递给函数<br>5.1 函数重用<br>5.2 将信息传递给函数<br>5.2.1 将实参传递给函数<br>5.2.2 将多个实参传递给一个函数<br>5.3 The Crypt——显示玩家信息<br>5.3.1 显示玩家的姓名<br>5.3.2 显示玩家的健康值<br>5.3.3 显示玩家的位置<br>5.3.4 合并显示玩家的信息<br>5.4 本章小结<br>第 6 章 返回值：从函数获取数据<br>6.1 从函数返回数据<br>6.1.1 用返回值替代函数调用<br>6.1.2 关键字 return<br>6.1.3 使用参数来确定返回值<br>6.2 在控制台提示符下进行实验<br>6.2.1 调用函数<br>6.2.2 声明新的变量<br>6.3 The Crypt——构建玩家信息字符串<br>6.3.1 为玩家的姓名、健康值和位置构建字符串<br>6.3.2 用一个函数显示玩家的信息——把几个函数集合在一起<br>6.4 本章小结<br>第 7 章 对象参数：将对象传递给函数<br>7.1 使用对象作为参数<br>7.1.1 访问对象参数的属性<br>7.1.2 给对象参数添加属性<br>7.2 从函数返回对象<br>7.2.1 构建行星——对象创建函数<br>7.2.2 二维空间的点<br>7.3 方法——设置函数作为对象的属性<br>7.3.1 命名空间——将相关函数组织到一起<br>7.3.2 Math 方法<br>7.3.3 String 方法<br>7.3.4 spacer——将更多的方法收入命名空间<br>7.3.5 进一步探索命名空间<br>7.4 The Crypt——将玩家对象作为参数<br>7.5 本章小结<br>第 8 章 数组：将数据存入列表<br>8.1 创建数组并访问元素<br>8.1.1 创建数组<br>8.1.2 访问数组元素<br>8.2 数组方法<br>8.2.1 添加和删除元素<br>8.2.2 截取和拼接数组<br>8.2.3 使用 forEach 访问每一个元素<br>8.3 The Crypt——玩家的物品数组<br>8.4 本章小结<br>第 9 章 构造函数：构建带有函数的对象<br>9.1 使用函数构建对象<br>9.1.1 添加属性<br>9.1.2 添加方法<br>9.2 使用构造函数构建对象<br>9.2.1 构造函数<br>9.2.2 使用 Planet 构造函数创建一个新世界<br>9.2.3 使用 instanceof 运算符区分对象<br>9.3 建造大师——两个构造函数的示例<br>9.4 The Crypt——为玩家提供掠夺地<br>9.4.1 构建 Place 构造函数——名称标题和描述<br>9.4.2 构建 Place 构造函数——囤积物品<br>9.4.3 构建 Place 构造函数——探索出口<br>9.5 The Crypt——简化玩家创建代码<br>9.5.1 整理玩家属性<br>9.5.2 将函数转换为方法<br>9.5.3 为玩家分配位置<br>9.5.4 使用 null 作为对象的占位符<br>9.6 本章小结<br>第 10 章 方括号运算符：灵活的属性名称<br>10.1 用方括号运算符替代圆点运算符<br>10.1.1 使用方括号——人的姓名作为键<br>10.1.2 最大限度地利用方括号运算符——单词统计<br>10.2 The Crypt——使游戏出口更加刺激好玩<br>10.2.1 使用对象存放出口<br>10.2.2 创建一个添加并显示出口的函数<br>10.2.3 设置每个场所对象的出口集合<br>10.2.4 将 exits 对象添加到完整的 Place 构造函数<br>10.2.5 测试 Place 构造函数<br>10.3 The Crypt——开始游戏！<br>10.3.1 刷新显示——render<br>10.3.2 探索地图——go<br>10.3.3 收集物品——get<br>10.3.4 设计一个更大的冒险游戏——Jahver 的船<br>10.4 下一步目标<br>10.5 本章小结<br>第二部分 组 织 代 码<br>第 11 章 作用域：隐藏信息<br>11.1 全局变量的危险性<br>11.1.1 访问所有区域——偷窥和篡改<br>11.1.2 访问所有区域——借助于实现<br>11.1.3 命名冲突<br>11.1.4 难以查找的错误<br>11.2 局部变量的优势<br>11.3 接口——控制访问权限并提供可用功能<br>11.3.1 使用一个函数来隐藏变量<br>11.3.2 使用 getCount 创建多个独立计数器<br>11.3.3 用构造函数创建多个独立的计数器<br>11.4 创建一个简单的测验应用程序<br>11.4.1 将对象用作一个命名空间<br>11.4.2 隐藏问题数组<br>11.5 The Crypt——隐藏玩家信息<br>11.5.1 当前的 Player 构造函数——全部内容都公开<br>11.5.2 更新版的 Player 构造函数——某些变量被隐藏<br>11.6 The Crypt——隐藏地点信息<br>11.7 The Crypt——用户交互<br>11.7.1 接口——go 和 get<br>11.7.2 隐藏程序的实现<br>11.8 本章小结<br>第 12 章 条件：有选择地运行代码<br>12.1 有条件地执行代码<br>12.1.1 严格相等运算符<br>12.1.2 if 语句<br>12.1.3 else 子句<br>12.1.4 隐藏函数中的密码数字</p><h3 id="JavaScript开发实战-PDF-下载"><a href="#JavaScript开发实战-PDF-下载" class="headerlink" title="JavaScript开发实战 PDF 下载"></a>JavaScript开发实战 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1i_Cez12A3o5iZl7JfO6P_w?pwd=xisp">https://pan.baidu.com/s/1i_Cez12A3o5iZl7JfO6P_w?pwd=xisp</a> </p><p>提取码：xisp</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript高级程序设计（第4版）》</title>
      <link href="/2023/05/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC4%E7%89%88)/"/>
      <url>/2023/05/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC4%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/151a8998ee2c6caeba42f688e52f9f95.png" alt="《JavaScript高级程序设计（第4版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是JavaScript 超级畅销书的最新版。ECMAScript 5 和HTML5 在标准之争中双双胜出，使大量专有实现和客户端扩展正式进入规范，同时也为JavaScript 增添了很多适应未来发展的新特性。本书这一版除增加5 章全新内容外，其他章节也有较大幅度的增补和修订，新内容篇幅约占三分之一。全书从JavaScript 语言实现的各个组成部分——语言核心、DOM、BOM、事件模型讲起，深入浅出地探讨了面向对象编程、Ajax 与Comet 服务器端通信，HTML5 表单、媒体、Canvas（包括WebGL）及Web Workers、地理定位、跨文档传递消息、客户端存储（包括IndexedDB）等新API，还介绍了离线应用和与维护、性能、部署相关的最佳开发实践。本书附录展望了未来的API 和ECMAScript Harmony 规范。</p><p>本书适合有一定编程经验的Web 应用开发人员阅读，也可作为高校及社会实用技术培训相关专业课程的教材。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Nicholas C. Zakas（尼古拉斯•泽卡斯）世界顶级Web技术专家，现为雅虎公司界面呈现架构师，负责My Yahoo!和雅虎首页等大访问量站点的设计。尼古拉斯拥有丰富的Web开发和界面设计经验，曾经参与许多世界级大公司的Web解决方案开发。他还是High Performance JavaScript一书的作者，并与他人合作撰写了Professional Ajax和Even Faster Web Sites。尼古拉斯拥有梅里马克学院计算机科学学士学位和埃迪柯特学院的MBA学位。他的个人网站是<a href="http://www.nczonline.net%EF%BC%8C%E4%BB%96%E7%9A%84Twitter%E5%88%AB%E5%90%8D%E6%98%AF@slicknet./">www.nczonline.net，他的Twitter别名是@slicknet。</a></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　JavaScript简介　　1<br>1.1　JavaScript简史　　1<br>1.2　JavaScript实现　　2<br>1.2.1　ECMAScript　　3<br>1.2.2　文档对象模型（DOM）　　5<br>1.2.3　浏览器对象模型（BOM）　　8<br>1.3　JavaScript版本　　8<br>1.4　小结　　9<br>第2章　在HTML中使用JavaScript　　10<br>2.1　&lt;\script&gt;元素　　10<br>2.1.1　标签的位置　　12<br>2.1.2　延迟脚本　　13<br>2.1.3　异步脚本　　13<br>2.1.4　在XHTML中的用法　　14<br>2.1.5　不推荐使用的语法　　16<br>2.2　嵌入代码与外部文件　　16<br>2.3　文档模式　　16<br>2.4　&lt;\noscript&gt;元素　　18<br>2.5　小结　　18<br>第3章　基本概念　　19<br>3.1　语法　　19<br>3.1.1　区分大小写　　19<br>3.1.2　标识符　　19<br>3.1.3　注释　　20<br>3.1.4　严格模式　　20<br>3.1.5　语句　　20<br>3.2　关键字和保留字　　21<br>3.3　变量　　22<br>3.4　数据类型　　23<br>3.4.1　typeof操作符　　23<br>3.4.2　Undefined类型　　24<br>3.4.3　Null类型　　25<br>3.4.4　Boolean类型　　26<br>3.4.5　Number类型　　27<br>3.4.6　String类型　　32<br>3.4.7　Object类型　　35<br>3.5　操作符　　36<br>3.5.1　一元操作符　　36<br>3.5.2　位操作符　　39<br>3.5.3　布尔操作符　　44<br>3.5.4　乘性操作符　　47<br>3.5.5　加性操作符　　48<br>3.5.6　关系操作符　　50<br>3.5.7　相等操作符　　51<br>3.5.8　条件操作符　　53<br>3.5.9　赋值操作符　　53<br>3.5.10　逗号操作符　　54<br>3.6　语句　　54<br>3.6.1　if语句　　54<br>3.6.2　do-while语句　　55<br>3.6.3　while语句　　55<br>3.6.4　for语句　　56<br>3.6.5　for-in语句　　57<br>3.6.6　label语句　　58<br>3.6.7　break和continue语句　　58<br>3.6.8　with语句　　60<br>3.6.9　switch语句　　60<br>3.7　函数　　62<br>3.7.1　理解参数　　64<br>3.7.2　没有重载　　66<br>3.8　小结　　67<br>第4章　变量、作用域和内存问题　　68<br>4.1　基本类型和引用类型的值　　68<br>4.1.1　动态的属性　　68<br>4.1.2　复制变量值　　69<br>4.1.3　传递参数　　70<br>4.1.4　检测类型　　72<br>4.2　执行环境及作用域　　73<br>4.2.1　延长作用域链　　75<br>4.2.2　没有块级作用域　　76<br>4.3　垃圾收集　　78<br>4.3.1　标记清除　　78<br>4.3.2　引用计数　　79<br>4.3.3　性能问题　　80<br>4.3.4　管理内存　　81<br>4.4　小结　　81<br>第5章　引用类型　　83<br>5.1　Object类型　　83<br>5.2　Array类型　　86<br>5.2.1　检测数组　　88<br>5.2.2　转换方法　　89<br>5.2.3　栈方法　　90<br>5.2.4　队列方法　　91<br>5.2.5　重排序方法　　92<br>5.2.6　操作方法　　94<br>5.2.7　位置方法　　95<br>5.2.8　迭代方法　　96<br>5.2.9　缩小方法　　97<br>5.3　Date类型　　98<br>5.3.1　继承的方法　　100<br>5.3.2　日期格式化方法　　101<br>5.3.3　日期&#x2F;时间组件方法　　102<br>5.4　RegExp类型　　103<br>5.4.1　RegExp实例属性　　105<br>5.4.2　RegExp实例方法　　106<br>5.4.3　RegExp构造函数属性　　107<br>5.4.4　模式的局限性　　109<br>5.5　Function类型　　110<br>5.5.1　没有重载（深入理解）　　111<br>5.5.2　函数声明与函数表达式　　111<br>5.5.3　作为值的函数　　112<br>5.5.4　函数内部属性　　113<br>5.5.5　函数属性和方法　　116<br>5.6　基本包装类型　　118<br>5.6.1　Boolean类型　　120<br>5.6.2　Number类型　　120<br>5.6.3　String类型　　122<br>5.7　单体内置对象　　130<br>5.7.1　Global对象　　131<br>5.7.2　Math对象　　134<br>5.8　小结　　137<br>第6章　面向对象的程序设计　　138<br>6.1　理解对象　　138<br>6.1.1　属性类型　　139<br>6.1.2　定义多个属性　　142<br>6.1.3　读取属性的特性　　143<br>6.2　创建对象　　144<br>6.2.1　工厂模式　　144<br>6.2.2　构造函数模式　　144<br>6.2.3　原型模式　　147<br>6.2.4　组合使用构造函数模式和原型模式　　159<br>6.2.5　动态原型模式　　159<br>6.2.6　寄生构造函数模式　　160<br>6.2.7　稳妥构造函数模式　　161<br>6.3　继承　　162<br>6.3.1　原型链　　162<br>6.3.2　借用构造函数　　167<br>6.3.3　组合继承　　168<br>6.3.4　原型式继承　　169<br>6.3.5　寄生式继承　　171<br>6.3.6　寄生组合式继承　　172<br>6.4　小结　　174<br>第7章　函数表达式　　175<br>7.1　递归　　177<br>7.2　闭包　　178<br>7.2.1　闭包与变量　　181<br>7.2.2　关于this对象　　182<br>7.2.3　内存泄漏　　183<br>7.3　模仿块级作用域　　184<br>7.4　私有变量　　186<br>7.4.1　静态私有变量　　188<br>7.4.2　模块模式　　189<br>7.4.3　增强的模块模式　　191<br>7.5　小结　　192<br>第8章　BOM　　193<br>8.1　window对象　　193<br>8.1.1　全局作用域　　193<br>8.1.2　窗口关系及框架　　194<br>8.1.3　窗口位置　　197<br>8.1.4　窗口大小　　198<br>8.1.5　导航和打开窗口　　199<br>8.1.6　间歇调用和超时调用　　203<br>8.1.7　系统对话框　　205<br>8.2　location对象　　207<br>8.2.1　查询字符串参数　　207<br>8.2.2　位置操作　　208<br>8.3　navigator对象　　210<br>8.3.1　检测插件　　211<br>8.3.2　注册处理程序　　213<br>8.4　screen对象　　214<br>8.5　history对象　　215<br>8.6　小结　　216<br>第9章　客户端检测　　217<br>9.1　能力检测　　217<br>9.1.1　更可靠的能力检测　　218<br>9.1.2　能力检测，不是浏览器检测　　220<br>9.2　怪癖检测　　220<br>9.3　用户代理检测　　221<br>9.3.1　用户代理字符串的历史　　222<br>9.3.2　用户代理字符串检测技术　　228<br>9.3.3　完整的代码　　242<br>9.3.4　使用方法　　245<br>9.4　小结　　246<br>第10章　DOM　　247<br>10.1　节点层次　　247<br>10.1.1　Node类型　　248<br>10.1.2　Document类型　　253<br>10.1.3　Element类型　　261<br>10.1.4　Text类型　　270<br>10.1.5　Comment类型　　273<br>10.1.6　CDATASection类型　　274<br>10.1.7　DocumentType类型　　274<br>10.1.8　DocumentFragment类型　　275<br>10.1.9　Attr类型　　276<br>10.2　DOM操作技术　　277<br>10.2.1　动态脚本　　277<br>10.2.2　动态样式　　279<br>10.2.3　操作表格　　281<br>10.2.4　使用NodeList　　283<br>10.3　小结　　284<br>第11章　DOM扩展　　286<br>11.1　选择符API　　286<br>11.1.1　querySelector()方法　　286<br>11.1.2　querySelectorAll()<br>方法　　287<br>11.1.3　matchesSelector()<br>方法　　288<br>11.2　元素遍历　　288<br>11.3　HTML5　　289<br>11.3.1　与类相关的扩充　　289<br>11.3.2　焦点管理　　291<br>11.3.3　HTMLDocument的变化　　292<br>11.3.4　字符集属性　　293<br>11.3.5　自定义数据属性　　293<br>11.3.6　插入标记　　294<br>11.3.7　scrollIntoView()方法　　298<br>11.4　专有扩展　　298<br>11.4.1　文档模式　　298<br>11.4.2　children属性　　299<br>11.4.3　contains()方法　　300<br>11.4.4　插入文本　　301<br>11.4.5　滚动　　303<br>11.5　小结　　304<br>第12章　DOM2和DOM3　　305<br>12.1　DOM变化　　305<br>12.1.1　针对XML命名空间的变化　　306<br>12.1.2　其他方面的变化　　309<br>12.2　样式　　312<br>12.2.1　访问元素的样式　　313<br>12.2.2　操作样式表　　317<br>12.2.3　元素大小　　320<br>12.3　遍历　　326<br>12.3.1　NodeIterator　　328<br>12.3.2　TreeWalker　　330<br>12.4　范围　　332<br>12.4.1　DOM中的范围　　332<br>12.4.2　IE8及更早版本中的范围　　340<br>12.5　小结　　343<br>第13章　事件　　345<br>13.1　事件流　　345<br>13.1.1　事件冒泡　　346<br>13.1.2　事件捕获　　346<br>13.1.3　DOM事件流　　347<br>13.2　事件处理程序　　348<br>13.2.1　HTML事件处理程序　　348<br>13.2.2　DOM0级事件处理程序　　350<br>13.2.3　DOM2级事件处理程序　　351<br>13.2.4　IE事件处理程序　　352<br>13.2.5　跨浏览器的事件处理程序　　353<br>13.3　事件对象　　355<br>13.3.1　DOM中的事件对象　　355<br>13.3.2　IE中的事件对象　　358<br>13.3.3　跨浏览器的事件对象　　360<br>13.4　事件类型　　362<br>13.4.1　UI事件　　362<br>13.4.2　焦点事件　　367<br>13.4.3　鼠标与滚轮事件　　368<br>13.4.4　键盘与文本事件　　379<br>13.4.5　复合事件　　384<br>13.4.6　变动事件　　385<br>13.4.7　HTML5事件　　388<br>13.4.8　设备事件　　395<br>13.4.9　触摸与手势事件　　399<br>13.5　内存和性能　　402<br>13.5.1　事件委托　　402<br>13.5.2　移除事件处理程序　　404<br>13.6　模拟事件　　405<br>13.6.1　DOM中的事件模拟　　405<br>13.6.2　IE中的事件模拟　　410<br>13.7　小结　　411<br>第14章　表单脚本　　412<br>14.1　表单的基础知识　　412<br>14.1.1　提交表单　　413<br>14.1.2　重置表单　　414<br>14.1.3　表单字段　　414<br>14.2　文本框脚本　　419<br>14.2.1　选择文本　　420<br>14.2.2　过滤输入　　423<br>14.2.3　自动切换焦点　　426<br>14.2.4　HTML5约束验证API　　427<br>14.3　选择框脚本　　431<br>14.3.1　选择选项　　432<br>14.3.2　添加选项　　434<br>14.3.3　移除选项　　435<br>14.3.4　移动和重排选项　　435<br>14.4　表单序列化　　436<br>14.5　富文本编辑　　438<br>14.5.1　使用contenteditable<br>属性　　438<br>14.5.2　操作富文本　　439<br>14.5.3　富文本选区　　441<br>14.5.4　表单与富文本　　443<br>14.6　小结　　443<br>第15章　使用Canvas绘图　　445<br>15.1　基本用法　　445<br>15.2　2D上下文　　446<br>15.2.1　填充和描边　　446<br>15.2.2　绘制矩形　　447<br>15.2.3　绘制路径　　449<br>15.2.4　绘制文本　　451<br>15.2.5　变换　　453<br>15.2.6　绘制图像　　456<br>15.2.7　阴影　　457<br>15.2.8　渐变　　458<br>15.2.9　模式　　460<br>15.2.10　使用图像数据　　460<br>15.2.11　合成　　462<br>15.3　WebGL　　463<br>15.3.1　类型化数组　　463<br>15.3.2　WebGL上下文　　468<br>15.3.3　支持　　478<br>15.4　小结　　478<br>第16章　HTML5脚本编程　　480<br>16.1　跨文档消息传递　　480<br>16.2　原生拖放　　481<br>16.2.1　拖放事件　　482<br>16.2.2　自定义放置目标　　482<br>16.2.3　dataTransfer对象　　483<br>16.2.4　dropEffect与effectAllowed　　484<br>16.2.5　可拖动　　485<br>16.2.6　其他成员　　485<br>16.3　媒体元素　　486<br>16.3.1　属性　　487<br>16.3.2　事件　　488<br>16.3.3　自定义媒体播放器　　488<br>16.3.4　检测编解码器的支持情况　　489<br>16.3.5　Audio类型　　490<br>16.4　历史状态管理　　491<br>16.5　小结　　492<br>第17章　错误处理与调试　　493<br>17.1　浏览器报告的错误　　493<br>17.1.1　IE　　493<br>17.1.2　Firefox　　494<br>17.1.3　Safari　　496<br>17.1.4　Opera　　497<br>17.1.5　Chrome　　498<br>17.2　错误处理　　499<br>17.2.1　try-catch语句　　500<br>17.2.2　抛出错误　　503<br>17.2.3　错误（error）事件　　505<br>17.2.4　处理错误的策略　　506<br>17.2.5　常见的错误类型　　507<br>17.2.6　区分致命错误和非致命<br>错误　　510<br>17.2.7　把错误记录到服务器　　511<br>17.3　调试技术　　512<br>17.3.1　将消息记录到控制台　　512<br>17.3.2　将消息记录到当前页面　　515<br>17.3.3　抛出错误　　515<br>17.4　常见的IE错误　　516<br>17.4.1　操作终止　　516<br>17.4.2　无效字符　　518<br>17.4.3　未找到成员　　518<br>17.4.4　未知运行时错误　　519<br>17.4.5　语法错误　　519<br>17.4.6　系统无法找到指定资源　　519<br>17.5　小结　　520<br>第18章　JavaScript与XML　　521<br>18.1　浏览器对XML DOM的支持　　521<br>18.1.1　DOM2级核心　　521<br>18.1.2　DOMParser类型　　522<br>18.1.3　XMLSerializer类型　　523<br>18.1.4　IE8及之前版本中的XML　　523<br>18.1.5　跨浏览器处理XML　　527<br>18.2　浏览器对XPath的支持　　529<br>18.2.1　DOM3级XPath　　529<br>18.2.2　IE中的XPath　　534<br>18.2.3　跨浏览器使用XPath　　535<br>18.3　浏览器对XSLT的支持　　537<br>18.3.1　IE中的XSLT　　537<br>18.3.2　XSLTProcessor类型　　541<br>18.3.3　跨浏览器使用XSLT　　543<br>18.4　小结　　544<br>第19章　E4X　　546<br>19.1　E4X的类型　　546<br>19.1.1　XML类型　　546<br>19.1.2　XMLList类型　　547<br>19.1.3　Namespace类型　　548<br>19.1.4　QName类型　　549<br>19.2　一般用法　　550<br>19.2.1　访问特性　　551<br>19.2.2　其他节点类型　　552<br>19.2.3　查询　　553<br>19.2.4　构建和操作XML　　555<br>19.2.5　解析和序列化　　557<br>19.2.6　命名空间　　558<br>19.3　其他变化　　559<br>19.4　全面启用E4X　　560<br>19.5　小结　　561<br>第20章　JSON　　562<br>20.1　语法　　562<br>20.1.1　简单值　　562<br>20.1.2　对象　　563<br>20.1.3　数组　　564<br>20.2　解析与序列化　　565<br>20.2.1　JSON对象　　565<br>20.2.2　序列化选项　　566<br>20.2.3　解析选项　　569<br>20.3　小结　　570<br>第21章　Ajax与Comet　　571<br>21.1　XMLHttpRequest对象　　571<br>21.1.1　XHR的用法　　573<br>21.1.2　HTTP头部信息　　575<br>21.1.3　GET请求　　576<br>21.1.4　POST请求　　577<br>21.2　XMLHttpRequest 2级　　578<br>21.2.1　FormData　　578<br>21.2.2　超时设定　　579<br>21.2.3　overrideMimeType()<br>方法　　580<br>21.3　进度事件　　580<br>21.3.1　load事件　　580<br>21.3.2　progress事件　　581<br>21.4　跨源资源共享　　582<br>21.4.1　IE对CORS的实现　　582<br>21.4.2　其他浏览器对CORS的<br>实现　　584<br>21.4.3　Preflighted Reqeusts　　584<br>21.4.4　带凭据的请求　　585<br>21.4.5　跨浏览器的CORS　　585<br>21.5　其他跨域技术　　586<br>21.5.1　图像Ping　　586<br>21.5.2　JSONP　　587<br>21.5.3　Comet　　588<br>21.5.4　服务器发送事件　　590<br>21.5.5　Web Sockets　　591<br>21.5.6　SSE与Web Sockets　　593<br>21.6　安全　　593<br>21.7　小结　　594<br>第22章　高级技巧　　596<br>22.1　高级函数　　596<br>22.1.1　安全的类型检测　　596<br>22.1.2　作用域安全的构造函数　　597<br>22.1.3　惰性载入函数　　600<br>22.1.4　函数绑定　　602<br>22.1.5　函数柯里化　　604<br>22.2　防篡改对象　　606<br>22.2.1　不可扩展对象　　606<br>22.2.2　密封的对象　　607<br>22.2.3　冻结的对象　　608<br>22.3　高级定时器　　609<br>22.3.1　重复的定时器　　610<br>22.3.2　Yielding Processes　　612<br>22.3.3　函数节流　　614<br>22.4　自定义事件　　616<br>22.5　拖放　　618<br>22.5.1　修缮拖动功能　　620<br>22.5.2　添加自定义事件　　622<br>22.6　小结　　624<br>第23章　离线应用与客户端存储　　626<br>23.1　离线检测　　626<br>23.2　应用缓存　　627<br>23.3　数据存储　　628<br>23.3.1　Cookie　　629<br>23.3.2　IE用户数据　　637<br>23.3.3　Web存储机制　　638<br>23.3.4　IndexedDB　　643<br>23.4　小结　　654<br>第24章　最佳实践　　656<br>24.1　可维护性　　656<br>24.1.1　什么是可维护的代码　　656<br>24.1.2　代码约定　　657<br>24.1.3　松散耦合　　659<br>24.1.4　编程实践　　662<br>24.2　性能　　666<br>24.2.1　注意作用域　　666<br>24.2.2　选择正确方法　　667<br>24.2.3　最小化语句数　　672<br>24.2.4　优化DOM交互　　673<br>24.3　部署　　676<br>24.3.1　构建过程　　676<br>24.3.2　验证　　677<br>24.3.3　压缩　　679<br>24.4　小结　　681<br>第25章　新兴的API　　682<br>25.1　requestAnimationFrame()　　682<br>25.1.1　早期动画循环　　682<br>25.1.2　循环间隔的问题　　683<br>25.1.3　mozRequestAnimation-Frame　　683<br>25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685<br>25.2　Page Visibility API　　686<br>25.3　Geolocation API　　687<br>25.4　File API　　689<br>25.4.1　FileReader类型　　690<br>25.4.2　读取部分内容　　692<br>25.4.3　对象URL　　693<br>25.4.4　读取拖放的文件　　694<br>25.4.5　使用XHR上传文件　　695<br>25.5　Web计时　　696<br>25.6　Web Workers　　697<br>25.6.1　使用Worker　　697<br>25.6.2　Worker全局作用域　　698<br>25.6.3　包含其他脚本　　699<br>25.6.4　Web Workers的未来　　700<br>25.7　小结　　700<br>附录A　ECMAScript Harmony　　701<br>附录B　严格模式　　717<br>附录C　JavaScript库　　723<br>附录D　JavaScript工具　　727</p><h3 id="JavaScript高级程序设计（第4版）-PDF-下载"><a href="#JavaScript高级程序设计（第4版）-PDF-下载" class="headerlink" title="JavaScript高级程序设计（第4版） PDF 下载"></a>JavaScript高级程序设计（第4版） PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Ejf6rmDtITQH0eBtAqjkCA?pwd=8j6a">https://pan.baidu.com/s/1Ejf6rmDtITQH0eBtAqjkCA?pwd=8j6a</a> </p><p>提取码：8j6a</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java并发编程的艺术》</title>
      <link href="/2023/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2023/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/dcxonocjsjnrxrnqdsuhifnylcifmjbx.png" alt="《Java并发编程的艺术》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>并发编程领域的扛鼎之作，作者是阿里和1号店的资深Java技术专家，对并发编程有非常深入的研究，《Java并发编程的艺术》是他们多年一线开发经验的结晶。本书的部分内容在出版早期发表在Java并发编程网和InfoQ等技术社区，得到了非常高的评价。它选取了Java并发编程中最核心的技术进行讲解，从JDK源码、JVM、CPU等多角度全面剖析和讲解了Java并发编程的框架、工具、原理和方法，对Java并发编程进行了最为深入和透彻的阐述。</p><p>《Java并发编程的艺术》内容涵盖Java并发编程机制的底层实现原理、Java内存模型、Java并发编程基础、Java中的锁、并发容器和框架、原子类、并发工具类、线程池、Executor框架等主题，每个主题都做了深入的讲解，同时通过实例介绍了如何应用这些技术。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>方腾飞（花名清英，英文名kiral），</p><p>蚂蚁金服集团技术专家，从事Java开发近10年。5年以上的团队管理、项目管理和敏捷开发经验，崇尚团队合作。曾参与CMS、电子海图、SOC、ITIL、电子商务网站和信贷管理系统等项目。目前在蚂蚁金服网商银行贷款管理团队负责数据采集平台开发工作。与同事合作开发了tala code Review插件，深受阿里数千名工程师拥趸，并开发过开源工具jdbcutil（<a href="https://github.com/kiral/utils%EF%BC%89%E3%80%82%E5%88%9B%E5%8A%9E%E4%BA%86%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BD%91%EF%BC%8C%E7%BB%84%E7%BB%87%E7%BF%BB%E8%AF%91%E4%BA%86%E7%99%BE%E4%BD%99%E7%AF%87%E5%9B%BD%E5%A4%96%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E6%9B%BE%E4%B8%BAInfoQ%E6%92%B0%E5%86%99%E2%80%9C%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91%E2%80%9D%E4%B8%93%E6%A0%8F%EF%BC%8C%E5%9C%A8%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E3%80%8B%E6%9D%82%E5%BF%97%E6%92%B0%E5%86%99%E6%95%8F%E6%8D%B7%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0">https://github.com/kiral/utils）。创办了并发编程网，组织翻译了百余篇国外优秀技术文章，并曾为InfoQ撰写“聊聊并发”专栏，在《程序员》杂志撰写敏捷实践系列文章</a></p><p>魏　鹏，</p><p>阿里巴巴集团技术专家，在阿里巴巴中国网站技术部工作多年，曾担任中国网站交易平台架构师，主导了交易系统服务化工作，设计实现的数据迁移系统高效地完成了阿里巴巴中国网站交易数据到阿里巴巴集团的迁移工作。目前在阿里巴巴共享业务事业部从事Java应用容器Pandora和服务框架HSF的相关工作，其中Java应用容器Pandora是阿里巴巴中间件运行的基础，而服务框架HSF则是阿里巴巴集团实现服务化的主要解决方案，二者在阿里巴巴拥有最为广泛的使用量。个人平时喜欢阅读技术书籍，翻译一些国外优秀文档，喜欢总结、乐于分享，对Java应用容器、多线程编程以及分布式系统感兴趣。</p><p>程晓明，</p><p>1号店资深架构师，从事1号店交易平台系统的开发，技术上关注并发与NIO。因5年前遇到的一个线上故障，解决过程中对Java并发编程产生了浓厚的兴趣，从此开始了漫长的探索之旅：从底层实现机制、内存模型到Java同步。纵观我自己对Java并发的学习过程，是一个从高层到底层再到高层的一个反复迭代的过程，我估计很多读者的学习过程应该与我类似。文章多见诸《IBM developerWorks》、InfoQ和《程序员》杂志。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前　言<br>第1章　并发编程的挑战 1<br>1.1　上下文切换 1<br>1.1.1　多线程一定快吗 1<br>1.1.2　测试上下文切换次数和时长 3<br>1.1.3　如何减少上下文切换 3<br>1.1.4　减少上下文切换实战 4<br>1.2　死锁 5<br>1.3　资源限制的挑战 6<br>1.4　本章小结 7<br>第2章　Java并发机制的底层实现原理 8<br>2.1　volatile的应用 8<br>2.2　synchronized的实现原理与应用 11<br>2.2.1　Java对象头 12<br>2.2.2　锁的升级与对比 13<br>2.3　原子操作的实现原理 16<br>2.4　本章小结 20<br>第3章　Java内存模型 21<br>3.1　Java内存模型的基础 21<br>3.1.1　并发编程模型的两个关键问题 21<br>3.1.2　Java内存模型的抽象结构 22<br>3.1.3　从源代码到指令序列的重排序 23<br>3.1.4　并发编程模型的分类 24<br>3.1.5　happens-before简介 26<br>3.2　重排序 27<br>3.2.1　数据依赖性 28<br>3.2.2　as-if-serial语义 28<br>3.2.3　程序顺序规则 29<br>3.2.4　重排序对多线程的影响 29<br>3.3　顺序一致性 31<br>3.3.1　数据竞争与顺序一致性 31<br>3.3.2　顺序一致性内存模型 32<br>3.3.3　同步程序的顺序一致性效果 34<br>3.3.4　未同步程序的执行特性 35<br>3.4　volatile的内存语义 38<br>3.4.1　volatile的特性 38<br>3.4.2　volatile写-读建立的happens-before关系 39<br>3.4.3　volatile写-读的内存语义 40<br>3.4.4　volatile内存语义的实现 42<br>3.4.5　JSR-133为什么要增强volatile的内存语义 46<br>3.5　锁的内存语义 47<br>3.5.1　锁的释放-获取建立的<br>happens-before关系 47<br>3.5.2　锁的释放和获取的内存语义 48<br>3.5.3　锁内存语义的实现 50<br>3.5.4　concurrent包的实现 54<br>3.6　final域的内存语义 55<br>3.6.1　final域的重排序规则 55<br>3.6.2　写final域的重排序规则 56<br>3.6.3　读final域的重排序规则 57<br>3.6.4　final域为引用类型 58<br>3.6.5　为什么final引用不能从构造函数内“溢出” 59<br>3.6.6　final语义在处理器中的实现 61<br>3.6.7　JSR-133为什么要增强f?inal的语义 62<br>3.7　happens-before 62<br>3.7.1　JMM的设计 62<br>3.7.2　happens-before的定义 64<br>3.7.3　happens-before规则 65<br>3.8　双重检查锁定与延迟初始化 67<br>3.8.1　双重检查锁定的由来 67<br>3.8.2　问题的根源 69<br>3.8.3　基于volatile的解决方案 71<br>3.8.4　基于类初始化的解决方案 72<br>3.9　Java内存模型综述 78<br>3.9.1　处理器的内存模型 78<br>3.9.2　各种内存模型之间的关系 80<br>3.9.3　JMM的内存可见性保证 80<br>3.9.4　JSR-133对旧内存模型的修补 81<br>3.10　本章小结 82<br>第4章　Java并发编程基础 83<br>4.1　线程简介 83<br>4.1.1　什么是线程 83<br>4.1.2　为什么要使用多线程 84<br>4.1.3　线程优先级 85<br>4.1.4　线程的状态 87<br>4.1.5　Daemon线程 90<br>4.2　启动和终止线程 91<br>4.2.1　构造线程 91<br>4.2.2　启动线程 92<br>4.2.3　理解中断 92<br>4.2.4　过期的suspend()、resume()和stop() 93<br>4.2.5　安全地终止线程 95<br>4.3　线程间通信 96<br>4.3.1　volatile和synchronized关键字 96<br>4.3.2　等待&#x2F;通知机制 98<br>4.3.3　等待&#x2F;通知的经典范式 101<br>4.3.4　管道输入&#x2F;输出流 102<br>4.3.5　Thread.join()的使用 103<br>4.3.6　ThreadLocal的使用 105<br>4.4　线程应用实例 106<br>4.4.1　等待超时模式 106<br>4.4.2　一个简单的数据库连接池示例 106<br>4.4.3　线程池技术及其示例 110<br>4.4.4　一个基于线程池技术的简单Web服务器 114<br>4.5　本章小结 118<br>第5章　Java中的锁 119<br>5.1　Lock接口 119<br>5.2　队列同步器 121<br>5.2.1　队列同步器的接口与示例 121<br>5.2.2　队列同步器的实现分析 124<br>5.3　重入锁 136<br>5.4　读写锁 140<br>5.4.1　读写锁的接口与示例 141<br>5.4.2　读写锁的实现分析 142<br>5.5　LockSupport工具 146<br>5.6　Condition接口 147<br>5.6.1　Condition接口与示例 148<br>5.6.2　Condition的实现分析 150<br>5.7　本章小结 154<br>第6章　Java并发容器和框架 155<br>6.1　ConcurrentHashMap的实现原理与使用 155<br>6.1.1　为什么要使用ConcurrentHashMap 155<br>6.1.2　ConcurrentHashMap的结构 156<br>6.1.3　ConcurrentHashMap的初始化 157<br>6.1.4　定位Segment 159<br>6.1.5　ConcurrentHashMap的操作 160<br>6.2　ConcurrentLinkedQueue 161<br>6.2.1　ConcurrentLinkedQueue的结构 162<br>6.2.2　入队列 162<br>6.2.3　出队列 165<br>6.3　Java中的阻塞队列 167<br>6.3.1　什么是阻塞队列 167<br>6.3.2　Java里的阻塞队列 168<br>6.3.3　阻塞队列的实现原理 172<br>6.4　Fork&#x2F;Join框架 175<br>6.4.1　什么是Fork&#x2F;Join框架 175<br>6.4.2　工作窃取算法 176<br>6.4.3　Fork&#x2F;Join框架的设计 177<br>6.4.4　使用Fork&#x2F;Join框架 177<br>6.4.5　Fork&#x2F;Join框架的异常处理 179<br>6.4.6　Fork&#x2F;Join框架的实现原理 179<br>6.5　本章小结 181<br>第7章　Java中的13个原子操作类 182<br>7.1　原子更新基本类型类 182<br>7.2　原子更新数组 184<br>7.3　原子更新引用类型 185<br>7.4　原子更新字段类 187<br>7.5　本章小结 188<br>第8章　Java中的并发工具类 189<br>8.1　等待多线程完成的CountDownLatch 189<br>8.2　同步屏障CyclicBarrier 191<br>8.2.1　CyclicBarrier简介 191<br>8.2.2　CyclicBarrier的应用场景 193<br>8.2.3　CyclicBarrier和CountDownLatch的区别 195<br>8.3　控制并发线程数的Semaphore 196<br>8.4　线程间交换数据的Exchanger 198<br>8.5　本章小结 199<br>第9章　Java中的线程池 200<br>9.1　线程池的实现原理 200<br>9.2　线程池的使用 203<br>9.2.1　线程池的创建 203<br>9.2.2　向线程池提交任务 205<br>9.2.3　关闭线程池 205<br>9.2.4　合理地配置线程池 206<br>9.2.5　线程池的监控 206<br>9.3　本章小结 207<br>第10章　Executor框架 208<br>10.1　Executor框架简介 208<br>10.1.1　Executor框架的两级调度模型 208<br>10.1.2　Executor框架的结构与成员 208<br>10.2　ThreadPoolExecutor详解 213<br>10.2.1　FixedThreadPool详解 213<br>10.2.2　SingleThreadExecutor详解 214<br>10.2.3　CachedThreadPool详解 215<br>10.3　ScheduledThreadPoolExecutor详解 217<br>10.3.1　ScheduledThreadPoolExecutor的运行机制 217<br>10.3.2　ScheduledThreadPoolExecutor的实现 218<br>10.4　FutureTask详解 221<br>10.4.1　FutureTask简介 222<br>10.4.2　FutureTask的使用 222<br>10.4.3　FutureTask的实现 224<br>10.5　本章小结 227<br>第11章　Java并发编程实践 228<br>11.1　生产者和消费者模式 228<br>11.1.1　生产者消费者模式实战 229<br>11.1.2　多生产者和多消费者场景 231<br>11.1.3　线程池与生产消费者模式 234<br>11.2　线上问题定位 234<br>11.3　性能测试 236<br>11.4　异步任务池 238<br>11.5　本章小结 240</p><h3 id="Java并发编程的艺术-PDF-下载"><a href="#Java并发编程的艺术-PDF-下载" class="headerlink" title="Java并发编程的艺术 PDF 下载"></a>Java并发编程的艺术 PDF 下载</h3><hr><p>链接:<a href="https://pan.baidu.com/s/1gQ-AFPpz3m2lzu_O9UauLg?pwd=dwkg">https://pan.baidu.com/s/1gQ-AFPpz3m2lzu_O9UauLg?pwd=dwkg</a> </p><p>提取码:dwkg </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python深度学习》</title>
      <link href="/2023/05/23/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/05/23/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/gvluhmjxgnjunsufyklkcyjlgiylhynr.png" alt="《Python深度学习》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><ul><li><p>深度学习名著重磅升级，涵盖Transformer架构等开创性进展</p></li><li><p>流行深度学习框架Keras之父执笔，文字生动、见解深刻</p></li><li><p>不用一个数学公式，利用直觉自然入门深度学习</p></li></ul><p>近年来，深度学习在自然语言处理、计算机视觉等领域取得了非凡的进展。从机器翻译和文本生成到自动驾驶和虚拟助手，我们受益于深度学习技术的逐渐普及。然而，深度学习还远未发挥全部潜力。欢迎来到深度学习的世界！在这个规模呈爆发式增长的领域，仍有许多“宝藏”等待你去发掘。</p><p>本书由流行深度学习框架Keras之父弗朗索瓦·肖莱执笔，不用数学公式，而用Python代码帮助你直观理解深度学习的核心思想。本书在第1版的基础上进行了大幅更新和增补，以体现深度学习领域的快速发展。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>【作者简介】</p><p>弗朗索瓦·肖莱（François Chollet）</p><p>谷歌公司深度学习科学家，流行深度学习框架Keras之父。Keras的GitHub星标数近6万，用户数量已超100万。此外，他也是TensorFlow框架的贡献者，个人Kaggle竞赛全球排名曾获第17名。利用Keras，他致力于普及深度学习技术和实现通用人工智能。</p><p>【译者简介】</p><p>张亮（hysic）</p><p>毕业于北京大学物理学院，核安全高级工程师，深谙机器学习和数据分析，译有《Python机器学习基础教程》《Python数据处理》等。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　什么是深度学习 1<br>1.1　人工智能、机器学习和深度学习 1<br>1.1.1　人工智能 2<br>1.1.2　机器学习 2<br>1.1.3　从数据中学习规则与表示 3<br>1.1.4　深度学习之“深度” 5<br>1.1.5　用三张图理解深度学习的工作原理 7<br>1.1.6　深度学习已取得的进展 8<br>1.1.7　不要相信短期炒作 9<br>1.1.8　人工智能的未来 10<br>1.2　深度学习之前：机器学习简史 10<br>1.2.1　概率建模 11<br>1.2.2　早期神经网络 11<br>1.2.3　核方法 11<br>1.2.4　决策树、随机森林和梯度提升机 12<br>1.2.5　回到神经网络 13<br>1.2.6　深度学习有何不同 14<br>1.2.7　机器学习现状 14<br>1.3　为什么要用深度学习，为什么是现在 16<br>1.3.1　硬件 17<br>1.3.2　数据 17<br>1.3.3　算法 18<br>1.3.4　新一轮投资热潮 18<br>1.3.5　深度学习的普及 19<br>1.3.6　这种趋势会持续下去吗 20<br>第2章　神经网络的数学基础 21<br>2.1　初识神经网络 21<br>2.2　神经网络的数据表示 25<br>2.2.1　标量（0阶张量） 25<br>2.2.2　向量（1阶张量） 25<br>2.2.3　矩阵（2阶张量） 26<br>2.2.4　3阶张量与更高阶的张量 26<br>2.2.5　关键属性 26<br>2.2.6　在NumPy中操作张量 28<br>2.2.7　数据批量的概念 28<br>2.2.8　现实世界中的数据张量实例 29<br>2.2.9　向量数据 29<br>2.2.10　时间序列数据或序列数据 29<br>2.2.11　图像数据 30<br>2.2.12　视频数据 31<br>2.3　神经网络的“齿轮”：张量运算 31<br>2.3.1　逐元素运算 32<br>2.3.2　广播 33<br>2.3.3　张量积 34<br>2.3.4　张量变形 36<br>2.3.5　张量运算的几何解释 37<br>2.3.6　深度学习的几何解释 40<br>2.4　神经网络的“引擎”：基于梯度的优化 40<br>2.4.1　什么是导数 41<br>2.4.2　张量运算的导数：梯度 42<br>2.4.3　随机梯度下降 44<br>2.4.4　链式求导：反向传播算法 46<br>2.5　回顾第一个例子 51<br>2.5.1　用TensorFlow 从头开始重新实现第一个例子 52<br>2.5.2　完成一次训练步骤 54<br>2.5.3　完整的训练循环 55<br>2.5.4　评估模型 55<br>2.6　本章总结 56<br>第3章　Keras 和TensorFlow 入门 57<br>3.1　TensorFlow 简介 57<br>3.2　Keras 简介 58<br>3.3　Keras 和TensorFlow 简史 59<br>3.4　建立深度学习工作区 60<br>3.4.1　Jupyter笔记本：运行深度学习实验的首选方法 60<br>3.4.2　使用Colaboratory 61<br>3.5　TensorFlow入门 63<br>3.5.1　常数张量和变量 64<br>3.5.2　张量运算：用TensorFlow进行数学运算 66<br>3.5.3　重温GradientTape API 66<br>3.5.4　一个端到端的例子：用TensorFlow编写线性分类器 67<br>3.6　神经网络剖析：了解核心Keras API 71<br>3.6.1　层：深度学习的基础模块 71<br>3.6.2　从层到模型 74<br>3.6.3　编译步骤：配置学习过程 75<br>3.6.4　选择损失函数 77<br>3.6.5　理解fit()方法 77<br>3.6.6　监控验证数据上的损失和指标 78<br>3.6.7　推断：在训练后使用模型 79<br>3.7　本章总结 80<br>第4章　神经网络入门：分类与回归 81<br>4.1　影评分类：二分类问题示例 82<br>4.1.1　IMDB 数据集 82<br>4.1.2　准备数据 83<br>4.1.3　构建模型 84<br>4.1.4　验证你的方法 87<br>4.1.5　利用训练好的模型对新数据进行预测 90<br>4.1.6　进一步实验 90<br>4.1.7　小结 90<br>4.2　新闻分类：多分类问题示例 91<br>4.2.1　路透社数据集 91<br>4.2.2　准备数据 92<br>4.2.3　构建模型 92<br>4.2.4　验证你的方法 93<br>4.2.5　对新数据进行预测 96<br>4.2.6　处理标签和损失的另一种方法 96<br>4.2.7　拥有足够大的中间层的重要性 96<br>4.2.8　进一步实验 97<br>4.2.9　小结 97<br>4.3　预测房价：标量回归问题示例 97<br>4.3.1　波士顿房价数据集 98<br>4.3.2　准备数据 98<br>4.3.3　构建模型 99<br>4.3.4　利用K折交叉验证来验证你的方法 99<br>4.3.5　对新数据进行预测 103<br>4.3.6　小结 103<br>4.4　本章总结 104<br>第5章　机器学习基础 105<br>5.1　泛化：机器学习的目标 105<br>5.1.1　欠拟合与过拟合 105<br>5.1.2　深度学习泛化的本质 110<br>5.2　评估机器学习模型 115<br>5.2.1　训练集、验证集和测试集 115<br>5.2.2　超越基于常识的基准 118<br>5.2.3　模型评估的注意事项 119<br>5.3　改进模型拟合 119<br>5.3.1　调节关键的梯度下降参数 119<br>5.3.2　利用更好的架构预设 121<br>5.3.3　提高模型容量 121<br>5.4　提高泛化能力 123<br>5.4.1　数据集管理 123<br>5.4.2　特征工程 124<br>5.4.3　提前终止 125<br>5.4.4　模型正则化 125<br>5.5　本章总结 132<br>第6章　机器学习的通用工作流程 133<br>6.1　定义任务 134<br>6.1.1　定义问题 134<br>6.1.2　收集数据集 135<br>6.1.3　理解数据 138<br>6.1.4　选择衡量成功的指标 139<br>6.2　开发模型 139<br>6.2.1　准备数据 139<br>6.2.2　选择评估方法 140<br>6.2.3　超越基准 141<br>6.2.4　扩大模型规模：开发一个过拟合的模型 142<br>6.2.5　模型正则化与调节超参数 142<br>6.3　部署模型 143<br>6.3.1　向利益相关者解释你的工作并设定预期 143<br>6.3.2　部署推断模型 143<br>6.3.3　监控模型在真实环境中的性能 146<br>6.3.4　维护模型 146<br>6.4　本章总结 147<br>第7章　深入Keras 148<br>7.1　Keras 工作流程 148<br>7.2　构建Keras 模型的不同方法 149<br>7.2.1　序贯模型 149<br>7.2.2　函数式API 152<br>7.2.3　模型子类化 157<br>7.2.4　混合使用不同的组件 159<br>7.2.5　用正确的工具完成工作 160<br>7.3　使用内置的训练循环和评估循环 160<br>7.3.1　编写自定义指标 161<br>7.3.2　使用回调函数 162<br>7.3.3　编写自定义回调函数 164<br>7.3.4　利用TensorBoard进行监控和可视化 165<br>7.4　编写自定义的训练循环和评估循环 167<br>7.4.1　训练与推断 168<br>7.4.2　指标的低阶用法 169<br>7.4.3　完整的训练循环和评估循环 169<br>7.4.4　利用tf.function加快运行速度 171<br>7.4.5　在fit()中使用自定义训练循环 172<br>7.5　本章总结 174<br>第8章　计算机视觉深度学习入门 175<br>8.1　卷积神经网络入门 176<br>8.1.1　卷积运算 178<br>8.1.2　最大汇聚运算 182<br>8.2　在小型数据集上从头开始训练一个卷积神经网络 184<br>8.2.1　深度学习对数据量很小的问题的适用性 184<br>8.2.2　下载数据 185<br>8.2.3　构建模型 . 187<br>8.2.4　数据预处理 189<br>8.2.5　使用数据增强 193<br>8.3　使用预训练模型 196<br>8.3.1　使用预训练模型做特征提取 197<br>8.3.2　微调预训练模型 204<br>8.4　本章总结 208<br>第9章　计算机视觉深度学习进阶 209<br>9.1　三项基本的计算机视觉任务 209<br>9.2　图像分割示例 210<br>9.3　现代卷积神经网络架构模式 218<br>9.3.1　模块化、层次结构和复用 218<br>9.3.2　残差连接 221<br>9.3.3　批量规范化 224<br>9.3.4　深度可分离卷积 226<br>9.3.5　综合示例：一个类似Xception的迷你模型 227<br>9.4　解释卷积神经网络学到的内容 229<br>9.4.1　中间激活值的可视化 230<br>9.4.2　卷积神经网络滤波器的可视化 235<br>9.4.3　类激活热力图的可视化 241<br>9.5　本章总结 246<br>第10章　深度学习处理时间序列 247<br>10.1　不同类型的时间序列任务 247<br>10.2　温度预测示例 248<br>10.2.1　准备数据 251<br>10.2.2　基于常识、不使用机器学习的基准 254<br>10.2.3　基本的机器学习模型 254<br>10.2.4　一维卷积模型 256<br>10.2.5　第一个RNN 基准 258<br>10.3　理解RNN 259<br>10.4　RNN 的高级用法 265<br>10.4.1　利用循环dropout 降低过拟合 265<br>10.4.2　循环层堆叠 268<br>10.4.3　使用双向RNN 269<br>10.4.4　进一步实验 271<br>10.5　本章总结 272<br>第11章　深度学习处理文本 273<br>11.1　自然语言处理概述 273<br>11.2　准备文本数据 274<br>11.2.1　文本标准化 275<br>11.2.2　文本拆分（词元化） 276<br>11.2.3　建立词表索引 277<br>11.2.4　使用TextVectorization层 278<br>11.3　表示单词组的两种方法：集合和序列 282<br>11.3.1　准备IMDB 影评数据 282<br>11.3.2　将单词作为集合处理：词袋方法 284<br>11.3.3　将单词作为序列处理：序列模型方法 289<br>11.4　Transformer架构 298<br>11.4.1　理解自注意力 298<br>11.4.2　多头注意力 302<br>11.4.3　Transformer编码器 303<br>11.4.4　何时使用序列模型而不是词袋模型 309<br>11.5　超越文本分类：序列到序列学习 310<br>11.5.1　机器翻译示例 312<br>11.5.2　RNN 的序列到序列学习 314<br>11.5.3　使用Transformer 进行序列到序列学习 318<br>11.6　本章总结 323<br>第12章　生成式深度学习 324<br>12.1　文本生成 325<br>12.1.1　生成式深度学习用于序列生成的简史 325<br>12.1.2　如何生成序列数据 326<br>12.1.3　采样策略的重要性 327<br>12.1.4　用Keras 实现文本生成 328<br>12.1.5　带有可变温度采样的文本生成回调函数 331<br>12.1.6　小结 334<br>12.2　DeepDream 334<br>12.2.1　用Keras 实现DeepDream 335<br>12.2.2　小结 341<br>12.3　　神经风格迁移 341<br>12.3.1　内容损失 342<br>12.3.2　风格损失 342<br>12.3.3　用Keras 实现神经风格迁移 343<br>12.3.4　小结 348<br>12.4　用变分自编码器生成图像 348<br>12.4.1　从图像潜在空间中采样 348<br>12.4.2　图像编辑的概念向量 350<br>12.4.3　变分自编码器 350<br>12.4.4　用Keras 实现变分自编码器 352<br>12.4.5　小结 357<br>12.5　生成式对抗网络入门 358<br>12.5.1　简要实现流程 359<br>12.5.2　诸多技巧 360<br>12.5.3　CelebA 数据集 360<br>12.5.4　判别器 361<br>12.5.5　生成器 362<br>12.5.6　对抗网络 364<br>12.5.7　小结 366<br>12.6　本章总结 367<br>第13章　适合现实世界的最佳实践 368<br>13.1　将模型性能发挥到极致 368<br>13.1.1　超参数优化 368<br>13.1.2　模型集成 375<br>13.2　加速模型训练 376<br>13.2.1　使用混合精度加快GPU上的训练速度 377<br>13.2.2　多GPU训练 380<br>13.2.3　TPU训练 382<br>13.3　本章总结 384<br>第14章　总结 385<br>14.1　重点概念回顾 385<br>14.1.1　人工智能的多种方法 385<br>14.1.2　深度学习在机器学习领域中的特殊之处 386<br>14.1.3　如何看待深度学习 386<br>14.1.4　关键的推动技术 387<br>14.1.5　机器学习的通用工作流程 388<br>14.1.6　关键网络架构 388<br>14.1.7　可能性空间 392<br>14.2　深度学习的局限性 394<br>14.2.1　将机器学习模型拟人化的风险 394<br>14.2.2　自动机与智能体 396<br>14.2.3　局部泛化与极端泛化 397<br>14.2.4　智能的目的 399<br>14.2.5　逐步提高泛化能力 400<br>14.3　如何实现更加通用的人工智能 401<br>14.3.1　设定正确目标的重要性：捷径法则 401<br>14.3.2　新目标 402<br>14.4　实现智能：缺失的内容 403<br>14.4.1　智能是对抽象类比的敏感性 404<br>14.4.2　两种抽象 405<br>14.4.3　深度学习所缺失的那一半 407<br>14.5　深度学习的未来 408<br>14.5.1　模型即程序 408<br>14.5.2　将深度学习与程序合成融合 409<br>14.5.3　终身学习和模块化子程序复用 411<br>14.5.4　长期愿景 412<br>14.6　了解快速发展的领域的最新进展 413<br>14.6.1　在Kaggle 上练习解决现实世界的问题 413<br>14.6.2　在arXiv上了解最新进展 414<br>14.6.3　探索Keras 生态系统 414<br>14.7　结束语 414</p><h3 id="Python深度学习-PDF-下载"><a href="#Python深度学习-PDF-下载" class="headerlink" title="Python深度学习 PDF 下载"></a>Python深度学习 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1XjcQeZsDM7QF7bBRlWzNuw?pwd=8p9d">https://pan.baidu.com/s/1XjcQeZsDM7QF7bBRlWzNuw?pwd=8p9d</a></p><p>提取码: 8p9d</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《持续交付2.0：业务引领的DevOps精要》</title>
      <link href="/2023/05/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982.0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81/"/>
      <url>/2023/05/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982.0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1a3aea4bb6854e7de11011ef09cecc2b.png" alt="《持续交付2.0：业务引领的DevOps精要》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书重新定义了“持续交付”，增补了组织管理和系统架构两个维度，并辅助以真实案例，对诸多持续交付原则与实践加以解读，并对持续交付过程中的实践取舍之道加以论述。</p><p>本书分三个部分。第一部分作者根据自己近十年的工作及咨询经历，不断总结、提炼和反思，对原有的持续交付进行了修正，重新定义持续交付为实现组织战略目标的能力，并引入持续交付的能力模型；</p><p>第二部分阐述组织打造持续交付能力所需遵守的原则，包括基础原则、组织原则和架构原则；</p><p>第三部分通过多个互联网公司案例的解读，阐述如何根据组织的当前状况，应用原则，并对最佳实践进行取舍，快速达到组织能力目标。</p><p>本书适合大型互联网公司的技术VP、技术负责人，中小型互联网公司的CTO、技术VP、研发&#x2F;测试&#x2F;运维负责人、主管及骨干，以及组织变革者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>乔梁</p><p>敏思特咨询公司联合创始人，持续交付领域专家，著名敏捷与精益转型导师，腾讯外聘高级管理顾问。拥有多年IT从业经验，曾就职于百度、Nokia等国内外知名软件公司，并先后担任多个互联网公司的高级管理顾问，帮助多个产品线取得业务上的成功突破。曾为华为、上汽等非互联网软件企业提供敏捷转型咨询服务，指导解决组织转型与研发管理方面的相关问题。</p><p>乔梁是国内最早致力于通过敏捷开发与精益理论改善软件价值交付效率的实践者之一，精研各种软件工程方法论，2010年翻译《持续交付》一书，并将其融会贯通，成为持续交付和DevOps理念在国内的首批实践者和布道者，经过八年的管理实践，总结提炼，提出持续交付双环模型，并将工作心得整理成册，取名《持续交付2.0》，将关注点前移至业务价值的持续探索与快速验证方法。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　持续交付2.0 1<br>1.1　软件工程发展概述 1<br>1.1.1　瀑布软件开发方法 1<br>1.1.2　敏捷软件开发方法 2<br>1.1.3　DevOps运动 3<br>1.1.4　持续交付1.0 4<br>1.2　持续交付2.0 7<br>1.2.1　精益思想 8<br>1.2.2　双环模型 9<br>1.2.3　4个核心原则 11<br>1.2.4　持续交付七巧板 12<br>1.3　小结 13<br>第2章　价值探索环 14<br>2.1　探索环的意义 14<br>2.2　探索环的4个关键环节 15<br>2.2.1　提问 16<br>2.2.2　锚定 17<br>2.2.3　共创 19<br>2.2.4　精炼 22<br>2.3　工作原则 24<br>2.3.1　分解并快速试错 24<br>2.3.2　一次只验证一点 25<br>2.3.3　允许失败 26<br>2.4　共创与精炼的常用方法 27<br>2.4.1　装饰窗方法 27<br>2.4.2　最小可行特性法 29<br>2.4.3　特区法 30<br>2.4.4　定向探索法 30<br>2.4.5　稻草人法 31<br>2.4.6　最小可行产品法 32<br>2.5　实施注意事项 32<br>2.6　小结 35<br>第3章　快速验证环 36<br>3.1　验证环的目标 36<br>3.2　验证环的4个关键环节 37<br>3.2.1　构建 37<br>3.2.2　运行 38<br>3.2.3　监测 39<br>3.2.4　决策 39<br>3.3　工作原则 39<br>3.3.1　质量内建 39<br>3.3.2　消除等待 40<br>3.3.3　重复事务自动化 43<br>3.3.4　监测一切 43<br>3.4　小结 44<br>第4章　持续交付2.0的组织文化 45<br>4.1　安全、信任与持续改善 45<br>4.1.1　失败是安全的 45<br>4.1.2　相互信任 45<br>4.1.3　持续改善 46<br>4.2　文化塑造四步法 46<br>4.2.1　行为决定文化 46<br>4.2.2　谷歌的工程师质量文化 48<br>4.2.3　Etsy的持续试验文化 49<br>4.3　行动原则 50<br>4.3.1　价值导向 51<br>4.3.2　快速验证 51<br>4.3.3　持续学习 51<br>4.4　度量原则 55<br>4.4.1　度量指标的4类属性 56<br>4.4.2　度量的目标是改善 57<br>4.5　“改善套路”进行持续改进 57<br>4.6　小结 58<br>第5章　持续交付的软件系统架构 60<br>5.1　“大系统小做”原则 61<br>5.1.1　持续交付架构要求 61<br>5.1.2　系统拆分原则 61<br>5.2　常见架构模式 62<br>5.2.1　微核架构 62<br>5.2.2　微服务架构 63<br>5.2.3　巨石应用 64<br>5.3　架构改造实施模式 66<br>5.3.1　拆迁者模式 67<br>5.3.2　绞杀者模式 68<br>5.3.3　修缮者模式 68<br>5.3.4　数据库的拆分方法 70<br>5.4　小结 70<br>第6章　业务需求协作管理 72<br>6.1　产品版本周期概述 73<br>6.1.1　准备期 73<br>6.1.2　交付期 74<br>6.2　需求拆分的利与弊 75<br>6.2.1　需求拆分的收益 76<br>6.2.2　需求拆分的成本 78<br>6.3　需求拆分方法 79<br>6.3.1　需求的来源 80<br>6.3.2　技术债也是需求 80<br>6.3.3　参与需求拆分的角色 81<br>6.3.4　不平等的INVEST原则 82<br>6.3.5　五大拆分技法 82<br>6.3.6　七大组成部分 84<br>6.4　需求分析与管理工具集 85<br>6.4.1　用户故事地图 85<br>6.4.2　用户故事树 86<br>6.4.3　依赖关系图 87<br>6.4.4　需求管理数字化平台 87<br>6.5　团队协作管理工具 87<br>6.5.1　团队共享日历 88<br>6.5.2　团队回顾 89<br>6.5.3　可视化故事墙 90<br>6.5.4　明确“完成”的定义 90<br>6.5.5　持续集成 91<br>6.5.6　故事验证 91<br>6.6　小结 91<br>第7章　部署流水线原则与工具设计 92<br>7.1　简单的部署流水线 92<br>7.1.1　简单的产品研发流程 92<br>7.1.2　初始部署流水线 93<br>7.1.3　流水线执行状态解析 95<br>7.2　部署流水线的设计与使用 95<br>7.2.1　流水线的设计原则 95<br>7.2.2　团队的协作纪律 97<br>7.3　部署流水线平台的构成 97<br>7.3.1　工具链总体架构 97<br>7.3.2　平台应当具备的基本能力 99<br>7.3.3　工具链建设策略 100<br>7.4　基础支撑服务的云化 100<br>7.4.1　基础支撑服务的协作过程解析 101<br>7.4.2　编译构建管理服务 103<br>7.4.3　自动化测试管理服务 104<br>7.4.4　软件部署管理服务 105<br>7.4.5　基础环境管理服务 106<br>7.5　企业制品库的管理 107<br>7.5.1　制品库的分类 107<br>7.5.2　制品库的管理原则 108<br>7.6　多种多样的部署流水线 108<br>7.6.1　多组件的部署流水线 108<br>7.6.2　个人部署流水线 109<br>7.6.3　部署流水线的不断演进 110<br>7.7　为开发者构建自助式工具 111<br>7.8　小结 113<br>第8章　利于集成的分支策略 114<br>8.1　版本控制系统的使用目的 114<br>8.1.1　集中式版本控制系统 114<br>8.1.2　分布式版本控制系统 115<br>8.1.3　版本控制系统中的基本概念 117<br>8.2　常见分支开发模式 118<br>8.2.1　主干开发，主干发布 118<br>8.2.2　主干开发，分支发布 119<br>8.2.3　分支开发，主干发布 121<br>8.3　分支模式的演化 126<br>8.3.1　三驾马车分支模式 126<br>8.3.2　Gitflow分支模式 127<br>8.3.3　GitHubFlow分支模式 128<br>8.4　分支策略的选择 128<br>8.4.1　版本发布模式 128<br>8.4.2　分支策略与发布周期的关系 132<br>8.5　小结 133<br>第9章　持续集成 134<br>9.1　起源与定义 134<br>9.1.1　原始定义 135<br>9.1.2　一次集成过程 135<br>9.2　六步提交法 136<br>9.2.1　4个关键点 138<br>9.2.2　同步与异步模式 139<br>9.2.3　自查表 140<br>9.3　速度与质量的权衡 141<br>9.3.1　分级构建 142<br>9.3.2　多人同时提交的构建 142<br>9.3.3　云平台的威力 143<br>9.4　在团队中实施持续集成实践 145<br>9.4.1　快速建立团队的持续集成实践 146<br>9.4.2　分支策略与部署流水线 148<br>9.5　常见的实施问题 150<br>9.5.1　工程师的开发习惯 151<br>9.5.2　视而不见的扫描问题 151<br>9.5.3　自动化测试用例的缺乏 151<br>9.6　小结 152<br>第10章　自动化测试策略与方法 153<br>10.1　自动化测试的自身定位 153<br>10.1.1　自动化测试的优势 154<br>10.1.2　自动化测试所需的投入 155<br>10.2　突破传统自动化测试的困境 156<br>10.2.1　传统自动化测试的特点 157<br>10.2.2　自动化测试的分层 157<br>10.2.3　不同类型的测试金字塔 160<br>10.3　自动化测试的实施策略 163<br>10.3.1　增加自动化测试用例的着手点 163<br>10.3.2　提高自动化测试的执行次数 164<br>10.3.3　良好自动化测试的特征 165<br>10.3.4　共享自动化测试的维护职责 166<br>10.3.5　代码测试覆盖率 167<br>10.4　用户验收自动化测试要点 168<br>10.4.1　先搭建分层框架 168<br>10.4.2　测试用例数应保持低位 171<br>10.4.3　为自动化测试用例预留API 171<br>10.4.4　为调试做好准备 171<br>10.4.5　测试数据的准备 171<br>10.5　其他质量检查方法 173<br>10.5.1　差异批注测试方法 173<br>10.5.2　代码规范检查与代码动静态检测 174<br>10.5.3　AI在测试领域的应用 174<br>10.6　小结 175<br>第11章　软件配置管理 176<br>11.1　将一切纳入配置管理 176<br>11.1.1　配置管理目标 176<br>11.1.2　配置管理的范围 177<br>11.1.3　软件配置管理原则 177<br>11.2　软件包的版本管理 181<br>11.2.1　包管理的反模式 181<br>11.2.2　集中式包管理服务 182<br>11.2.3　软件包的元信息 183<br>11.3　包依赖管理 185<br>11.3.1　显式声明依赖 185<br>11.3.2　自动管理依赖 187<br>11.3.3　减少复杂依赖 188<br>11.4　环境基础设施管理 191<br>11.4.1　环境准备的4种状态 191<br>11.4.2　领域专属语言的应用 197<br>11.4.3　环境基础设施即代码 198<br>11.5　软件配置项的管理 199<br>11.5.1　二进制与配置项的分离 199<br>11.5.2　配置信息的版本管理 200<br>11.5.3　配置项的存储组织方式 201<br>11.5.4　配置漂移与治理 202<br>11.6　不可变基础设施与云应用 203<br>11.6.1　实现不可变基础设施 203<br>11.6.2　云原生应用 206<br>11.6.3　优势与挑战 206<br>11.7　数据的版本管理 208<br>11.7.1　数据库结构变更 208<br>11.7.2　数据文件 208<br>11.8　需求与源代码的版本关联 209<br>11.9　小结 209<br>第12章　低风险发布 211<br>12.1　高频发布是一种趋势 211<br>12.1.1　互联网企业的高频发布 212<br>12.1.2　收益与成本共存 214<br>12.2　降低发布风险的方法 215<br>12.2.1　蓝绿部署 215<br>12.2.2　滚动部署 216<br>12.2.3　金丝雀发布与灰度发布 217<br>12.2.4　暗部署 218<br>12.3　高频发布支撑技术 219<br>12.3.1　功能开关技术 220<br>12.3.2　数据迁移技术 222<br>12.3.3　抽象分支方法 225<br>12.3.4　升级替代回滚 226<br>12.4　影响发布频率的因素 227<br>12.5　小结 228<br>第13章　监测与决策 229<br>13.1　生产监测范围 230<br>13.1.1　后台服务的监测 230<br>13.1.2　分发软件的监测 230<br>13.2　数据监测体系 231<br>13.2.1　收集与处理 231<br>13.2.2　数据的标准化 232<br>13.2.3　监测数据体系及其能力衡量 233<br>13.3　问题处理体系 235<br>13.3.1　告警海洋与智能化管理 235<br>13.3.2　问题处理是一个学习过程 236<br>13.4　生产环境测试 237<br>13.4.1　测试活动扁平化趋势 237<br>13.4.2　生产环境中的测试 239<br>13.4.3　混沌工程 239<br>13.5　向东，还是向西 240<br>13.6　小结 241<br>第14章　大型互联网团队的FT化 242<br>14.1　简介 242<br>14.1.1　改进前状态 243<br>14.1.2　改进后状态 244<br>14.2　改进方法论 245<br>14.2.1　指导思想 245<br>14.2.2　改进步骤 245<br>14.3　改进的历程 246<br>14.3.1　架构解耦 246<br>14.3.2　组织解耦 248<br>14.3.3　研发流程再造 250<br>14.3.4　自动化一切 259<br>14.4　小结 260<br>第15章　小团队逆袭之旅 262<br>15.1　背景简介 262<br>15.1.1　改进前的“死亡行军”之旅 264<br>15.1.2　改进后的无缺陷交付 264<br>15.2　改进方法论 265<br>15.2.1　指导思想 265<br>15.2.2　试点团队的选择 265<br>15.3　第一阶段：研发准备期 266<br>15.3.1　功能简介与需求拆分 266<br>15.3.2　架构设计与需求依赖识别 267<br>15.3.3　工作量估算与排期 268<br>15.4　第二阶段：软件交付期 270<br>15.4.1　通过可视化看板改进工作流程 270<br>15.4.2　无缺陷交付 277<br>15.4.3　主干开发与持续集成 278<br>15.4.4　测试活动左移 279<br>15.4.5　代码评审 279<br>15.4.6　关注结果，更要关注过程 280<br>15.5　小结 281<br>第16章　研发推动的DevOps 283<br>16.1　改进的关键点 285<br>16.1.1　改进方法论 285<br>16.1.2　定义改进目标 285<br>16.2　第一阶段：敏捷101 287<br>16.2.1　做个靠谱的计划 287<br>16.2.2　开发阶段启航 291<br>16.2.3　对过程质量的约束 294<br>16.2.4　阶段性改进点 301<br>16.3　第二阶段：DevOps转型 302<br>16.3.1　与运维人员的“冲突” 303<br>16.3.2　高频部署发布中的具体障碍 304<br>16.3.3　整体解决方案的设计 304<br>16.3.4　DevOps阶段的团队改变 308<br>16.4　小结 308<br>附录A　软件工程的三次进化 310<br>附录B　排序法做相对估算 323</p><h3 id="持续交付2-0：业务引领的DevOps精要-PDF-下载"><a href="#持续交付2-0：业务引领的DevOps精要-PDF-下载" class="headerlink" title="持续交付2.0：业务引领的DevOps精要 PDF 下载"></a>持续交付2.0：业务引领的DevOps精要 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1U2alK_9N-AnB5pI-Kt9hZA?pwd=viff">https://pan.baidu.com/s/1U2alK_9N-AnB5pI-Kt9hZA?pwd=viff</a> </p><p>提取码：viff</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> 持续交付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Java虚拟机（第3版）》</title>
      <link href="/2023/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(%E7%AC%AC3%E7%89%88)/"/>
      <url>/2023/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(%E7%AC%AC3%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/e0e32b23ce83f43911565b8216a4c7e7.png" alt="《深入理解Java虚拟机（第3版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>这是一部从工作原理和工程实践两个维度深入剖析JVM的著作，是计算机领域公认的经典，繁体版在台湾也颇受欢迎。</p><p>自2011年上市以来，前两个版本累计印刷36次，销量超过30万册，两家主要网络书店的评论近90000条，内容上近乎零差评，是原创计算机图书领域不可逾越的丰碑。</p><p>第3版在第2版的基础上做了重大修订，内容更丰富、实战性更强：根据新版JDK对内容进行了全方位的修订和升级，围绕新技术和生产实践新增逾10万字，包含近50%的全新内容，并对第2版中含糊、瑕疵和错误内容进行了修正。</p><p>全书一共13章，分为五大部分：</p><p>第一部分（第1章）走近Java</p><p>系统介绍了Java的技术体系、发展历程、虚拟机家族，以及动手编译JDK，了解这部分内容能对学习JVM提供良好的指引。</p><p>第二部分（第2~5章）自动内存管理</p><p>详细讲解了Java的内存区域与内存溢出、垃圾收集器与内存分配策略、虚拟机性能监控与故障排除等与自动内存管理相关的内容，以及10余个经典的性能优化案例和优化方法；</p><p>第三部分（第6~9章）虚拟机执行子系统</p><p>深入分析了虚拟机执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎，以及多个类加载及其执行子系统的实战案例；</p><p>第四部分（第10~11章）程序编译与代码优化</p><p>详细讲解了程序的前、后端编译与优化，包括前端的易用性优化措施，如泛型、主动装箱拆箱、条件编译等的内容的深入分析；以及后端的性能优化措施，如虚拟机的热点探测方法、HotSpot 的即时编译器、提前编译器，以及各种常见的编译期优化技术；</p><p>第五部分（第12~13章）高效并发</p><p>主要讲解了Java实现高并发的原理，包括Java的内存模型、线程与协程，以及线程安全和锁优化。</p><p>全书以实战为导向，通过大量与实际生产环境相结合的案例分析和展示了解决各种Java技术难题的方案和技巧。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>资深Java技术、机器学习和企业级开发技术专家，现任远光软件研究院院长，人工智能博士在读，著有知名畅销书《深入理解Java虚拟机：JVM高级特性与最佳实践》。</p><p>开源技术的积极倡导者和推动者，对计算机科学和相关的多个领域都有深刻的见解，尤其是人工智能、Java开发和敏捷开发等领域。曾受邀在InfoQ和IBM DeveloperWorks等网站撰写技术专栏。</p><p>著作颇丰，著有《深入理解Java虚拟机》《深入理解OSGi》，翻译了《Java虚拟机规范》等著作。其中《深入理解Java虚拟机》第1版出版于2011年，已经出至第2版，不仅销量好，而且口碑更好，累计印刷超过30次，仍长销不衰，是中文计算机图书领域公认的、难得一见的佳作。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　走近Java<br>第1章　走近Java 2<br>1.1　概述 2<br>1.2　Java技术体系 3<br>1.3　Java发展史 4<br>1.4　Java虚拟机家族 12<br>1.4.1　虚拟机始祖：Sun Classic&#x2F;Exact VM 12<br>1.4.2　武林盟主：HotSpot VM 13<br>1.4.3　小家碧玉：Mobile&#x2F;Embedded VM 14<br>1.4.4　天下第二：BEA JRockit&#x2F;IBM J9 VM 15<br>1.4.5　软硬合璧：BEA Liquid VM&#x2F;Azul VM 16<br>1.4.6　挑战者：Apache Harmony&#x2F;Google Android Dalvik VM 17<br>1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18<br>1.4.8　百家争鸣 19<br>1.5　展望Java技术的未来 21<br>1.5.1　无语言倾向 21<br>1.5.2　新一代即时编译器 23<br>1.5.3　向Native迈进 24<br>1.5.4　灵活的胖子 26<br>1.5.5　语言语法持续增强 27<br>1.6　实战：自己编译JDK 29<br>1.6.1　获取源码 29<br>1.6.2　系统需求 31<br>1.6.3　构建编译环境 33<br>1.6.4　进行编译 34<br>1.6.5　在IDE工具中进行源码调试 36<br>1.7　本章小结 39<br>第二部分　自动内存管理<br>第2章　Java内存区域与内存溢出异常 42<br>2.1　概述 42<br>2.2　运行时数据区域 42<br>2.2.1　程序计数器 43<br>2.2.2　Java虚拟机栈 43<br>2.2.3　本地方法栈 44<br>2.2.4　Java堆 44<br>2.2.5　方法区 46<br>2.2.6　运行时常量池 47<br>2.2.7　直接内存 47<br>2.3　HotSpot虚拟机对象探秘 48<br>2.3.1　对象的创建 48<br>2.3.2　对象的内存布局 51<br>2.3.3　对象的访问定位 52<br>2.4　实战：OutOfMemoryError异常 53<br>2.4.1　Java堆溢出 54<br>2.4.2　虚拟机栈和本地方法栈溢出 56<br>2.4.3　方法区和运行时常量池溢出 61<br>2.4.4　本机直接内存溢出 65<br>2.5　本章小结 66<br>第3章　垃圾收集器与内存分配策略 67<br>3.1　概述 67<br>3.2　对象已死？ 68<br>3.2.1　引用计数算法 68<br>3.2.2　可达性分析算法 70<br>3.2.3　再谈引用 71<br>3.2.4　生存还是死亡？ 72<br>3.2.5　回收方法区 74<br>3.3　垃圾收集算法 75<br>3.3.1　分代收集理论 75<br>3.3.2　标记-清除算法 77<br>3.3.3　标记-复制算法 78<br>3.3.4　标记-整理算法 79<br>3.4　HotSpot的算法细节实现 81<br>3.4.1　根节点枚举 81<br>3.4.2　安全点 82<br>3.4.3　安全区域 83<br>3.4.4　记忆集与卡表 84<br>3.4.5　写屏障 85<br>3.4.6　并发的可达性分析 87<br>3.5　经典垃圾收集器 89<br>3.5.1　Serial收集器 90<br>3.5.2　ParNew收集器 92<br>3.5.3　Parallel Scavenge收集器 93<br>3.5.4　Serial Old收集器 94<br>3.5.5　Parallel Old收集器 95<br>3.5.6　CMS收集器 96<br>3.5.7　Garbage First收集器 98<br>3.6　低延迟垃圾收集器 104<br>3.6.1　Shenandoah收集器 105<br>3.6.2　ZGC收集器 112<br>3.7　选择合适的垃圾收集器 121<br>3.7.1　Epsilon收集器 121<br>3.7.2　收集器的权衡 121<br>3.7.3　虚拟机及垃圾收集器日志 122<br>3.7.4　垃圾收集器参数总结 127<br>3.8　实战：内存分配与回收策略 129<br>3.8.1　对象优先在Eden分配 130<br>3.8.2　大对象直接进入老年代 131<br>3.8.3　长期存活的对象将进入老年代 132<br>3.8.4　动态对象年龄判定 134<br>3.8.5　空间分配担保 135<br>3.9　本章小结 137<br>第4章　虚拟机性能监控、故障处理工具 138<br>4.1　概述 138<br>4.2　基础故障处理工具 138<br>4.2.1　jps：虚拟机进程状况工具 141<br>4.2.2　jstat：虚拟机统计信息监视工具 142<br>4.2.3　jinfo：Java配置信息工具 143<br>4.2.4　jmap：Java内存映像工具 144<br>4.2.5　jhat：虚拟机堆转储快照分析工具 145<br>4.2.6　jstack：Java堆栈跟踪工具 146<br>4.2.7　基础工具总结 148<br>4.3　可视化故障处理工具 151<br>4.3.1　JHSDB：基于服务性代理的调试工具 152<br>4.3.2　JConsole：Java监视与管理控制台 157<br>4.3.3　VisualVM：多合-故障处理工具 164<br>4.3.4　Java Mission Control：可持续在线的监控工具 171<br>4.4　HotSpot虚拟机插件及工具 175<br>4.5　本章小结 180<br>第5章　调优案例分析与实战 181<br>5.1　概述 181<br>5.2　案例分析 181<br>5.2.1　大内存硬件上的程序部署策略 182<br>5.2.2　集群间同步导致的内存溢出 184<br>5.2.3　堆外内存导致的溢出错误 185<br>5.2.4　外部命令导致系统缓慢 187<br>5.2.5　服务器虚拟机进程崩溃 187<br>5.2.6　不恰当数据结构导致内存占用过大 188<br>5.2.7　由Windows虚拟内存导致的长时间停顿 189<br>5.2.8　由安全点导致长时间停顿 190<br>5.3　实战：Eclipse运行速度调优 192<br>5.3.1　调优前的程序运行状态 193<br>5.3.2　升级JDK版本的性能变化及兼容问题 196<br>5.3.3　编译时间和类加载时间的优化 200<br>5.3.4　调整内存设置控制垃圾收集频率 203<br>5.3.5　选择收集器降低延迟 206<br>5.4　本章小结 209<br>第三部分　虚拟机执行子系统<br>第6章　类文件结构 212<br>6.1　概述 212<br>6.2　无关性的基石 212<br>6.3　Class类文件的结构 214<br>6.3.1　魔数与Class文件的版本 215<br>6.3.2　常量池 218<br>6.3.3　访问标志 224<br>6.3.4　类索引、父类索引与接口索引集合 225<br>6.3.5　字段表集合 226<br>6.3.6　方法表集合 229<br>6.3.7　属性表集合 230<br>6.4　字节码指令简介 251<br>6.4.1　字节码与数据类型 251<br>6.4.2　加载和存储指令 253<br>6.4.3　运算指令 254<br>6.4.4　类型转换指令 255<br>6.4.5　对象创建与访问指令 256<br>6.4.6　操作数栈管理指令 256<br>6.4.7　控制转移指令 257<br>6.4.8　方法调用和返回指令 257<br>6.4.9　异常处理指令 258<br>6.4.10　同步指令 258<br>6.5　公有设计，私有实现 259<br>6.6　Class文件结构的发展 260<br>6.7　本章小结 261<br>第7章　虚拟机类加载机制 262<br>7.1　概述 262<br>7.2　类加载的时机 263<br>7.3　类加载的过程 267<br>7.3.1　加载 267<br>7.3.2　验证 268<br>7.3.3　准备 271<br>7.3.4　解析 272<br>7.3.5　初始化 277<br>7.4　类加载器 279<br>7.4.1　类与类加载器 280<br>7.4.2　双亲委派模型 281<br>7.4.3　破坏双亲委派模型 285<br>7.5　Java模块化系统 287<br>7.5.1　模块的兼容性 288<br>7.5.2　模块化下的类加载器 290<br>7.6　本章小结 292<br>第8章　虚拟机字节码执行引擎 293<br>8.1　概述 293<br>8.2　运行时栈帧结构 294<br>8.2.1　局部变量表 294<br>8.2.2　操作数栈 299<br>8.2.3　动态连接 300<br>8.2.4　方法返回地址 300<br>8.2.5　附加信息 301<br>8.3　方法调用 301<br>8.3.1　解析 301<br>8.3.2　分派 303<br>8.4　动态类型语言支持 315<br>8.4.1　动态类型语言 316<br>8.4.2　Java与动态类型 317<br>8.4.3　java.lang.invoke包 318<br>8.4.4　invokedynamic指令 321<br>8.4.5　实战：掌控方法分派规则 324<br>8.5　基于栈的字节码解释执行引擎 326<br>8.5.1　解释执行 327<br>8.5.2　基于栈的指令集与基于寄存器的指令集 328<br>8.5.3　基于栈的解释器执行过程 329<br>8.6　本章小结 334<br>第9章　类加载及执行子系统的案例与实战 335<br>9.1　概述 335<br>9.2　案例分析 335<br>9.2.1　Tomcat：正统的类加载器架构 335<br>9.2.2　OSGi：灵活的类加载器架构 338<br>9.2.3　字节码生成技术与动态代理的实现 341<br>9.2.4　Backport工具：Java的时光机器 345<br>9.3　实战：自己动手实现远程执行功能 348<br>9.3.1　目标 348<br>9.3.2　思路 349<br>9.3.3　实现 350<br>9.3.4　验证 355<br>9.4　本章小结 356<br>第四部分　程序编译与代码优化<br>第10章　前端编译与优化 358<br>10.1　概述 358<br>10.2　Javac编译器 359<br>10.2.1　Javac的源码与调试 359<br>10.2.2　解析与填充符号表 362<br>10.2.3　注解处理器 363<br>10.2.4　语义分析与字节码生成 364<br>10.3　Java语法糖的味道 367<br>10.3.1　泛型 367<br>10.3.2　自动装箱、拆箱与遍历循环 375<br>10.3.3　条件编译 377<br>10.4　实战：插入式注解处理器 378<br>10.4.1　实战目标 379<br>10.4.2　代码实现 379<br>10.4.3　运行与测试 385<br>10.4.4　其他应用案例 386<br>10.5　本章小结 386<br>第11章　后端编译与优化 388<br>11.1　概述 388<br>11.2　即时编译器 389<br>11.2.1　解释器与编译器 389<br>11.2.2　编译对象与触发条件 392<br>11.2.3　编译过程 397<br>11.2.4　实战：查看及分析即时编译结果 398<br>11.3　提前编译器 404<br>11.3.1　提前编译的优劣得失 405<br>11.3.2　实战：Jaotc的提前编译 408<br>11.4　编译器优化技术 411<br>11.4.1　优化技术概览 411<br>11.4.2　方法内联 415<br>11.4.3　逃逸分析 417<br>11.4.4　公共子表达式消除 420<br>11.4.5　数组边界检查消除 421<br>11.5　实战：深入理解Graal编译器 423<br>11.5.1　历史背景 423<br>11.5.2　构建编译调试环境 424<br>11.5.3　JVMCI编译器接口 426<br>11.5.4　代码中间表示 429<br>11.5.5　代码优化与生成 432<br>11.6　本章小结 436<br>第五部分　高效并发<br>第12章　Java内存模型与线程 438<br>12.1　概述 438<br>12.2　硬件的效率与一致性 439<br>12.3　Java内存模型 440<br>12.3.1　主内存与工作内存 441<br>12.3.2　内存间交互操作 442<br>12.3.3　对于volatile型变量的特殊规则 444<br>12.3.4　针对long和double型变量的特殊规则 450<br>12.3.5　原子性、可见性与有序性 450<br>12.3.6　先行发生原则 452<br>12.4　Java与线程 455<br>12.4.1　线程的实现 455<br>12.4.2　Java线程调度 458<br>12.4.3　状态转换 460<br>12.5　Java与协程 461<br>12.5.1　内核线程的局限 461<br>12.5.2　协程的复苏 462<br>12.5.3　Java的解决方案 464<br>12.6　本章小结 465<br>第13章　线程安全与锁优化 466<br>13.1　概述 466<br>13.2　线程安全 466<br>13.2.1　Java语言中的线程安全 467<br>13.2.2　线程安全的实现方法 471<br>13.3　锁优化 479<br>13.3.1　自旋锁与自适应自旋 479<br>13.3.2　锁消除 480<br>13.3.3　锁粗化 481<br>13.3.4　轻量级锁 481<br>13.3.5　偏向锁 483<br>13.4　本章小结 485<br>附录A　在Windows系统下编译OpenJDK 6 486<br>附录B　展望Java技术的未来（2013年版） 493<br>附录C　虚拟机字节码指令表 499<br>附录D　对象查询语言（OQL）简介 506<br>附录E　JDK历史版本轨迹 512</p><h3 id="深入理解Java虚拟机（第3版）-PDF-下载"><a href="#深入理解Java虚拟机（第3版）-PDF-下载" class="headerlink" title="深入理解Java虚拟机（第3版） PDF 下载"></a>深入理解Java虚拟机（第3版） PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1516g8be4qA8OxZFXxA60Bw?pwd=zn83">https://pan.baidu.com/s/1516g8be4qA8OxZFXxA60Bw?pwd=zn83</a> </p><p>提取码：zn83</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习入门：基于Python的理论与实现》</title>
      <link href="/2023/05/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/05/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/QGDBW3TF02QM72D625UDAUEN26GTDMA8.png" alt="《深度学习入门：基于Python的理论与实现》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是深度学习真正意义上的入门书，深入浅出地剖析了深度学习的原理和相关技术。书中使用Python3，尽量不依赖外部库或工具，从基本的数学知识出发，带领读者从零创建一个经典的深度学习网络，使读者在此过程中逐步理解深度学习。书中不仅介绍了深度学习和神经网络的概念、特征等基础知识，对误差反向传播法、卷积神经网络等也有深入讲解，此外还介绍了深度学习相关的实用技巧，自动驾驶、图像生成、强化学习等方面的应用，以及为什么加深层可以提高识别精度等“为什么”的问题。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>作者简介：</p><p>斋藤康毅</p><p>东京工业大学毕业，并完成东京大学研究生院课程。现从事计算机视觉与机器学习相关的研究和开发工作。是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。</p><p>译者简介：</p><p>陆宇杰</p><p>众安科技NLP算法工程师。主要研究方向为自然语言处理及其应用，对图像识别、机器学习、深度学习等领域有密切关注。Python爱好者。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　Python入门　　1<br>1.1 Python是什么　　1<br>1.2 Python的安装　　2<br>1.2.1　Python版本　　2<br>1.2.2　使用的外部库　　2<br>1.2.3　Anaconda发行版　　3<br>1.3 Python解释器　　4<br>1.3.1　算术计算　　4<br>1.3.2　数据类型　　5<br>1.3.3　变量　　5<br>1.3.4　列表　　6<br>1.3.5　字典　　7<br>1.3.6　布尔型　　7<br>1.3.7　if 语句　　8<br>1.3.8　for 语句　　8<br>1.3.9　函数　　9<br>1.4 Python脚本文件　　9<br>1.4.1　保存为文件　　9<br>1.4.2　类　　10<br>1.5 NumPy　　11<br>1.5.1　导入NumPy　　11<br>1.5.2　生成NumPy数组　　12<br>1.5.3　NumPy 的算术运算　　12<br>1.5.4　NumPy的N维数组　　13<br>1.5.5　广播　　14<br>1.5.6　访问元素　　15<br>1.6 Matplotlib　　16<br>1.6.1　绘制简单图形　　16<br>1.6.2　pyplot 的功能　　17<br>1.6.3　显示图像　　18<br>1.7 小结　　19<br>第2章　感知机　　21<br>2.1 感知机是什么　　21<br>2.2 简单逻辑电路　　23<br>2.2.1　与门　　23<br>2.2.2　与非门和或门　　23<br>2.3 感知机的实现　　25<br>2.3.1　简单的实现　　25<br>2.3.2　导入权重和偏置　　26<br>2.3.3　使用权重和偏置的实现　　26<br>2.4 感知机的局限性　　28<br>2.4.1　异或门　　28<br>2.4.2　线性和非线性　　30<br>2.5 多层感知机　　31<br>2.5.1　已有门电路的组合　　31<br>2.5.2　异或门的实现　　33<br>2.6 从与非门到计算机　　35<br>2.7 小结　　36<br>第3章　神经网络　　37<br>3.1 从感知机到神经网络　　37<br>3.1.1　神经网络的例子　　37<br>3.1.2　复习感知机　　38<br>3.1.3　激活函数登场　　40<br>3.2 激活函数　　42<br>3.2.1　sigmoid 函数　　42<br>3.2.2　阶跃函数的实现　　43<br>3.2.3　阶跃函数的图形　　44<br>3.2.4　sigmoid 函数的实现　　45<br>3.2.5　sigmoid 函数和阶跃函数的比较　　46<br>3.2.6　非线性函数　　48<br>3.2.7　ReLU函数　　49<br>3.3 多维数组的运算　　50<br>3.3.1　多维数组　　50<br>3.3.2　矩阵乘法　　51<br>3.3.3　神经网络的内积　　55<br>3.4　　3 层神经网络的实现　　56<br>3.4.1　符号确认　　57<br>3.4.2　各层间信号传递的实现　　58<br>3.4.3　代码实现小结　　62<br>3.5 输出层的设计　　63<br>3.5.1　恒等函数和softmax 函数　　64<br>3.5.2　实现softmax 函数时的注意事项　　66<br>3.5.3　softmax 函数的特征　　67<br>3.5.4　输出层的神经元数量　　68<br>3.6 手写数字识别　　69<br>3.6.1　MNIST数据集　　70<br>3.6.2　神经网络的推理处理　　73<br>3.6.3　批处理　　75<br>3.7 小结　　79<br>第4章　神经网络的学习　　81<br>4.1 从数据中学习　　81<br>4.1.1　数据驱动　　82<br>4.1.2　训练数据和测试数据　　84<br>4.2 损失函数　　85<br>4.2.1　均方误差　　85<br>4.2.2　交叉熵误差　　87<br>4.2.3　mini-batch 学习　　88<br>4.2.4　mini-batch 版交叉熵误差的实现　　91<br>4.2.5　为何要设定损失函数　　92<br>4.3 数值微分　　94<br>4.3.1　导数　　94<br>4.3.2　数值微分的例子　　96<br>4.3.3　偏导数　　98<br>4.4 梯度　　100<br>4.4.1　梯度法　　102<br>4.4.2　神经网络的梯度　　106<br>4.5 学习算法的实现　　109<br>4.5.1　2 层神经网络的类　　110<br>4.5.2　mini-batch 的实现　　114<br>4.5.3　基于测试数据的评价　　116<br>4.6 小结　　118<br>第5章　误差反向传播法　　121<br>5.1 计算图　　121<br>5.1.1　用计算图求解　　122<br>5.1.2　局部计算　　124<br>5.1.3　为何用计算图解题　　125<br>5.2 链式法则　　126<br>5.2.1　计算图的反向传播　　127<br>5.2.2　什么是链式法则　　127<br>5.2.3　链式法则和计算图　　129<br>5.3 反向传播　　130<br>5.3.1　加法节点的反向传播　　130<br>5.3.2　乘法节点的反向传播　　132<br>5.3.3　苹果的例子　　133<br>5.4 简单层的实现　　135<br>5.4.1　乘法层的实现　　135<br>5.4.2　加法层的实现　　137<br>5.5 激活函数层的实现　　139<br>5.5.1　ReLU层　　139<br>5.5.2　Sigmoid 层　　141<br>5.6 AffineSoftmax层的实现　　144<br>5.6.1　Affine层　　144<br>5.6.2　批版本的Affine层　　148<br>5.6.3　Softmax-with-Loss 层　　150<br>5.7 误差反向传播法的实现　　154<br>5.7.1　神经网络学习的全貌图　　154<br>5.7.2　对应误差反向传播法的神经网络的实现　　155<br>5.7.3　误差反向传播法的梯度确认　　158<br>5.7.4　使用误差反向传播法的学习　　159<br>5.8 小结　　161<br>第6章　与学习相关的技巧　　163<br>6.1 参数的更新　　163<br>6.1.1　探险家的故事　　164<br>6.1.2　SGD　　164<br>6.1.3　SGD的缺点　　166<br>6.1.4　Momentum　　168<br>6.1.5　AdaGrad　　170<br>6.1.6　Adam　　172<br>6.1.7　使用哪种更新方法呢　　174<br>6.1.8　基于MNIST数据集的更新方法的比较　　175<br>6.2 权重的初始值　　176<br>6.2.1　可以将权重初始值设为0 吗　　176<br>6.2.2　隐藏层的激活值的分布　　177<br>6.2.3　ReLU的权重初始值　　181<br>6.2.4　基于MNIST数据集的权重初始值的比较　　183<br>6.3 Batch Normalization　　184<br>6.3.1　Batch Normalization 的算法　　184<br>6.3.2　Batch Normalization 的评估　　186<br>6.4 正则化　　188<br>6.4.1　过拟合　　189<br>6.4.2　权值衰减　　191<br>6.4.3　Dropout　　192<br>6.5 超参数的验证　　195<br>6.5.1　验证数据　　195<br>6.5.2　超参数的最优化　　196<br>6.5.3　超参数最优化的实现　　198<br>6.6 小结　　200<br>第7章　卷积神经网络　　201<br>7.1 整体结构　　201<br>7.2 卷积层　　202<br>7.2.1　全连接层存在的问题　　203<br>7.2.2　卷积运算　　203<br>7.2.3　填充　　206<br>7.2.4　步幅　　207<br>7.2.5　3 维数据的卷积运算　　209<br>7.2.6　结合方块思考　　211<br>7.2.7　批处理　　213<br>7.3 池化层　　214<br>7.4 卷积层和池化层的实现　　216<br>7.4.1　4 维数组　　216<br>7.4.2　基于im2col 的展开　　217<br>7.4.3　卷积层的实现　　219<br>7.4.4　池化层的实现　　222<br>7.5 CNN的实现　　224<br>7.6 CNN的可视化　　228<br>7.6.1　第1 层权重的可视化　　228<br>7.6.2　基于分层结构的信息提取　　230<br>7.7 具有代表性的CNN　　231<br>7.7.1　LeNet　　231<br>7.7.2　AlexNet　　232<br>7.8 小结　　233<br>第8章　深度学习　　235<br>8.1 加深网络　　235<br>8.1.1　向更深的网络出发　　235<br>8.1.2　进一步提高识别精度　　238<br>8.1.3　加深层的动机　　240<br>8.2 深度学习的小历史　　242<br>8.2.1　ImageNet　　243<br>8.2.2　VGG　　244<br>8.2.3　GoogLeNet　　245<br>8.2.4　ResNet　　246<br>8.3 深度学习的高速化　　248<br>8.3.1　需要努力解决的问题　　248<br>8.3.2　基于GPU的高速化　　249<br>8.3.3　分布式学习　　250<br>8.3.4　运算精度的位数缩减　　252<br>8.4 深度学习的应用案例　　253<br>8.4.1　物体检测　　253<br>8.4.2　图像分割　　255<br>8.4.3　图像标题的生成　　256<br>8.5 深度学习的未来　　258<br>8.5.1　图像风格变换　　258<br>8.5.2　图像的生成　　259<br>8.5.3　自动驾驶　　261<br>8.5.4　Deep Q-Network（强化学习）　　262<br>8.6 小结　　264<br>附录A　Softmax-with-Loss 层的计算图　　267<br>A.1 正向传播　　268<br>A.2 反向传播　　270<br>A.3 小结　　277<br>参考文献　　279</p><h3 id="深度学习入门：基于Python的理论与实现-PDF-下载"><a href="#深度学习入门：基于Python的理论与实现-PDF-下载" class="headerlink" title="深度学习入门：基于Python的理论与实现 PDF 下载"></a>深度学习入门：基于Python的理论与实现 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1B2DuBSu97N5ko2PRXd5Tag?pwd=dkex">https://pan.baidu.com/s/1B2DuBSu97N5ko2PRXd5Tag?pwd=dkex</a> </p><p>提取码: dkex </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Jenkins 2权威指南》</title>
      <link href="/2023/05/19/Jenkins%202%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/19/Jenkins%202%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/DCC8A35F0B25E6C033260746B89DAF45.png" alt="《Jenkins 2权威指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>设计、实现并且执行具有一定灵活性、可控性以及易于维护性的持续交付流水线，对于以前版本的Jenkins来说是不可能实现的。通过这本实用的书籍，构建管理人员、开发人员、测试人员以及其他专业人员将会学到如何利用Jenkins 2的新特性来定义流水线即代码、集成其他关键技术，以及创建自动化的、可靠的流水线，以便简化和加速DevOps环境的建设。</p><p>作者Brent Laster向你展示了Jenkins 2与这个流行的开源自动化平台基于Web的传统版本有着很大的不同。如果你熟悉Jenkins并且想利用这些新技术来改造老旧流水线或者构建现代的自动化持续交付环境，那么这本书适合你。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>郝树伟</p><p>《Jenkins权威指南》第一译者，阿里云高级研发工程师，主要负责开源集成和DevOps相关产品的研发，在CI&#x2F;CD领域有丰富经验，在Jenkins开源社区与相关书籍翻译、汉化方面有较多贡献和经验。</p><p>石雪峰</p><p>Jenkins全球推广大使、Certified Jenkins Engineer、Jenkins中文社区核心成员、Jenkins的狂热爱好者。目前就职于京东商城前台工程效率团队，负责公司级持续交付和DevOps平台体系建设。</p><p>雷涛</p><p>Jenkins全球推广大使、Certified Jenkins Engineer、DevOps标准核心编写专家。目前就职于百度工程效率部，曾先后就职于新浪网、摩托罗拉、诺基亚、爱立信、乐视致新等国内外知名企业，专注于互联网、电信、金融、无人驾驶汽车等行业的软件工程效率提升，DevOps解决方案，持续交付，ASPICE&#x2F;ISO 26262研发过程落地等领域。</p><p>李华强</p><p>乐融致新高级配置经理，软件配置管理（SCM）领域的一名老兵，先后就职于北电网络、爱立信、飞维美地、乐视、乐融等多家企业，从事与SCM、DevOps相关的工作。Jenkins的忠实粉丝、最佳实践的推广者，Jenkins官方Certified Jenkins Engineer（CJE）和Certified CloudBees Jenkins Platform Engineer（CCJE）认证者。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 Jenkins 2简介 1<br>Jenkins 2是什么 2<br>Jenkinsfile 3<br>声明式流水线 5<br>Blue Ocean界面 6<br>Jenkins 2的全新任务类型 7<br>做出转变的原因 10<br>DevOps理念的转变 10<br>装配流水线 11<br>可恢复性 11<br>可配置性 11<br>共享工作空间 11<br>专业知识 12<br>访问逻辑 12<br>流水线源管理 12<br>竞争 12<br>迎接挑战 13<br>兼容性 13<br>流水线兼容性 13<br>插件兼容性 15<br>检查兼容性 20<br>总结 21<br>第2章 基础知识 23<br>语法：脚本式流水线和声明式流水线 24<br>如何选择脚本式语法和声明式语法 25<br>系统（system）：主节点（master）、节点（node）、代理节点（agent）和执行器（executor）26<br>主节点 27<br>节点 27<br>代理节点 27<br>执行器 28<br>创建节点 29<br>结构：使用Jenkins DSL 31<br>节点 32<br>阶段 34<br>步骤 34<br>支持环境：开发一个流水线脚本 36<br>创建一个流水线项目 36<br>编辑器 38<br>使用代码片段生成器 39<br>运行一条流水线 43<br>回放 49<br>总结 52<br>第3章 流水线执行流程 53<br>触发任务 53<br>在其他项目构建后构建 54<br>周期性构建 54<br>使用GitHub钩子触发器进行GitSCM轮询 57<br>SCM轮询 57<br>静默期 58<br>远程触发构建 58<br>用户输入 58<br>输入 59<br>参数 62<br>多个输入参数的返回值 68<br>参数与声明式流水线 69<br>流程控制选项 74<br>超时（timeout） 74<br>重试（retry） 76<br>睡眠（sleep） 76<br>等待直到（waitUntil） 76<br>处理并发 78<br>使用lock步骤对资源加锁 78<br>使用milestone来控制并发构建 80<br>在多分支流水线中限制并发 82<br>并行地运行任务 82<br>有条件的执行功能 92<br>构建后处理 94<br>脚本式流水线构建后处理 94<br>声明式流水线与构建后处理 96<br>总结 97<br>第4章 通知与报告 99<br>通知 99<br>电子邮件 100<br>协作服务 110<br>报告 120<br>发布HTML报告 120<br>总结 123<br>第5章 访问与安全 125<br>安全加固Jenkins 125<br>启用安全性 126<br>其他全局安全配置 129<br>Jenkins中的凭证 133<br>凭证范围 134<br>凭证域 135<br>凭证提供者 135<br>凭证存储 136<br>管理凭证 136<br>选择凭证提供者 136<br>选择凭证类型 137<br>通过提供者指定凭证类型 138<br>创建和管理凭证 139<br>上下文链接 141<br>添加一个新域或者凭证 141<br>使用新域和凭证 144<br>高级凭证：基于角色的访问权限 145<br>基本用途 146<br>管理角色 147<br>分配角色 152<br>角色策略宏 155<br>在流水线中使用凭证 157<br>用户名和密码 157<br>SSH密钥 158<br>令牌凭证 159<br>控制脚本安全性 160<br>脚本检查 160<br>脚本批准 161<br>Groovy沙箱 162<br>Jenkins凭证与Vault配合使用 164<br>方法 164<br>安装 165<br>创建一个策略 165<br>身份验证 166<br>在Jenkins中使用Vault 168<br>总结 171<br>第6章 扩展你的流水线 173<br>可信库和不可信库 173<br>内部库与外部库 174<br>内部库 174<br>外部库 176<br>从代码仓库获取库 178<br>Modern SCM 178<br>Legacy SCM 178<br>在流水线脚本中使用库 179<br>从源码版本控制中自动下载库 180<br>加载库到脚本中 180<br>Jenkins项目中的库范围 182<br>库结构 183<br>样本库例程 183<br>共享库代码的结构 184<br>使用第三方库 195<br>直接加载代码 196<br>从外部SCM加载代码 196<br>回放外部代码和库 198<br>深入研究可信与不可信代码 200<br>总结 203<br>第7章 声明式流水线 205<br>动机 206<br>不直观 206<br>掌握Groovy 206<br>其他必需的装配 206<br>结构 207<br>代码块 208<br>部分 208<br>指令 209<br>步骤 209<br>条件 210<br>构建代码块 210<br>Pipeline 211<br>Agent 212<br>Environment 215<br>Tools 216<br>Options 219<br>Triggers 222<br>Parameters 224<br>Libraries 227<br>Stages 228<br>Post 231<br>处理非声明式的代码 232<br>检查你的插件 233<br>创建一个共享库 233<br>在pipeline代码块之外放置代码 233<br>script语句 234<br>在一个阶段中使用 parallel234<br>脚本检查与错误报告 235<br>声明式流水线与Blue Ocean接口 238<br>总结 238<br>第8章 理解项目类型 241<br>通用项目选项 241<br>基础设置 241<br>源码管理 247<br>构建触发器 249<br>构建环境 256<br>构建 266<br>构建后操作 266<br>项目类型 266<br>自由风格类型项目 267<br>Maven项目类型 267<br>流水线项目类型 270<br>外部任务项目类型 272<br>多配置项目类型 275<br>Ivy项目 280<br>文件夹 282<br>多分支流水线项目 287<br>GitHub组织项目 292<br>Bitbucket团队&#x2F;项目 296<br>总结 299<br>第9章 Blue Ocean用户界面 301<br>第一部分：管理已有的流水线 302<br>主界面 302<br>项目详情页面 305<br>运行页面 316<br>第二部分：使用Blue Ocean编辑器 325<br>不依赖现有Jenkinsfile创建一个全新的流水线 326<br>使用编辑器 330<br>编辑已有的流水线 340<br>导入和编辑已有的流水线 344<br>使用非GitHub仓库支持流水线 354<br>总结 356<br>第10章 转换 357<br>通用的准备 358<br>逻辑和准确性 358<br>项目类型 358<br>系统 358<br>访问 358<br>全局配置 359<br>插件 359<br>共享库 359<br>将自由风格类型的流水线转换为脚本式流水线 360<br>源码 364<br>编译 369<br>单元测试 373<br>集成测试 377<br>迁移流水线接下来的部分 380<br>从Jenkins流水线项目转换为Jenkinsfile 385<br>方法 388<br>最后的步骤 395<br>从脚本式流水线转换为声明式流水线 397<br>样本流水线 397<br>转换 399<br>完成转换 402<br>可用于转换的通用指南 403<br>总结 405<br>第11章 操作系统环境集成（shell、工作空间、环境和文件） 407<br>使用shell的步骤 407<br>sh步骤 408<br>bat步骤 413<br>powershell步骤 414<br>使用环境变量 415<br>withEnv步骤 416<br>使用工作空间 418<br>创建自定义工作空间 418<br>清理工作空间 420<br>文件和目录步骤 422<br>使用文件 422<br>使用目录 423<br>使用文件和目录的更多操作 424<br>总结 425<br>第12章 集成分析工具 427<br>SonarQube调查 427<br>使用个人规则 428<br>质量门和配置文件 432<br>扫描程序 434<br>将SonarQube与Jenkins一起使用 434<br>全局配置 434<br>在自由风格类型项目中使用SonarQube 436<br>在流水线项目中使用SonarQube 436<br>利用SonarQube分析的结果 437<br>在Jenkins中集成SonarQube的输出 441<br>代码覆盖率：与JaCoCo集成 442<br>关于JaCoCo 442<br>JaCoCo与流水线集成 443<br>在Jenkins中集成JaCoCo的输出 445<br>总结 446<br>第13章 集成制品管理 447<br>发布和获取制品 447<br>安装和全局配置 448<br>在脚本式流水线中使用Artifactory 449<br>执行其他任务 454<br>下载指定文件到指定目录 454<br>上传指定文件到指定路径 454<br>设置构建保留策略 455<br>构建提升 455<br>声明式流水线集成 455<br>Artifactory与Jenkins输出集成 456<br>制品归档和指纹 457<br>总结 462<br>第14章 集成容器 465<br>配置成一个云 465<br>全局配置 466<br>使用Docker镜像作为代理节点 469<br>在流水线中使用云镜像 473<br>在声明式流水线中动态创建的代理节点 477<br>Docker流水线全局变量 480<br>全局变量 480<br>Docker应用全局变量方法 481<br>Docker镜像全局变量方法 487<br>Docker容器全局变量方法 491<br>通过shell运行Docker 492<br>总结 493<br>第15章 其他接口 495<br>使用命令行接口 496<br>直接使用SSH接口 496<br>使用CLI客户端 499<br>使用Jenkins REST API 501<br>过滤结果 502<br>启动构建 504<br>使用脚本控制台 506<br>总结 508<br>第16章 故障处理 509<br>深入流水线步骤 509<br>处理序列化错误 512<br>连续传递风格 513<br>序列化流水线 513<br>NotSerializableException 513<br>处理非序列化错误 514<br>识别引发错误的脚本行 517<br>处理流水线异常 518<br>在声明式流水线中使用非声明式代码 518<br>未授权代码（脚本和方法授权） 522<br>不支持的操作 523<br>系统日志 523<br>时间戳 525<br>流水线耐用性设置 526<br>总结 527<br>关于作者 529<br>封面介绍 529<br>关于译者 530</p><h3 id="Jenkins-2权威指南-PDF-下载"><a href="#Jenkins-2权威指南-PDF-下载" class="headerlink" title="Jenkins 2权威指南 PDF 下载"></a>Jenkins 2权威指南 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1MjjGZ16iWq4MthUmeOe7uw?pwd=cg1r">https://pan.baidu.com/s/1MjjGZ16iWq4MthUmeOe7uw?pwd=cg1r</a> </p><p>提取码：cg1r</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kong网关：入门、实战与进阶》</title>
      <link href="/2023/05/19/Kong%E7%BD%91%E5%85%B3%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%81%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/05/19/Kong%E7%BD%91%E5%85%B3%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%81%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/9873662DB6DD82154A4484E46FD188A3.png" alt="《Kong网关：入门、实战与进阶》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>这是一本关于Kong网关开发和运维的集大成之作。作者基于自己在该领域的丰富实践经验，从零开始，不仅循序渐进地讲解了Kong网关的核心概念、使用方法、工作原理、工程实践和源码，而且还将微服务设计、分布式架构、DevOps等相关技术融入其中，帮助读者打通Kong网关的整个技术体系，轻松跨越从理论到项目实战的鸿沟。</p><p>全书共16章，分为4篇，具体内容如下。</p><p>入门篇（第1~4章）</p><p>首先对网关层和Kong网关做了整体性介绍，然后有针对性地讲解了Nginx、OpenResty和Lua语言等必备知识，为之后深入学习打下基础。</p><p>基础篇（第5~8章）</p><p>这部分围绕Kong网关的日常配置和操作展开，具体包括Kong网关配置文件、部署方案、命令行向导、代理、鉴权、负载均衡策略和健康检查机制等内容。</p><p>进阶篇（第9~12章）</p><p>主要介绍了Kong网关区别于其他传统网关的插件机制，以及Kong网关在整个架构体系中与其他系统之间的交互和联动。</p><p>应用篇（第13~16章）</p><p>主要结合当前日益成熟的云原生环境，给出Kong网关在不同场景下的整体解决方案，如与微服务、Service Mesh、Kubernetes、Serverless的结合等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>孔庆雍</p><p>毕业于同济大学，曾就职于华为、中国移动、数禾科技等多家公司，任职期间参与了多个大型系统设计、研发工作。现任上海珞瑾数据信息有限公司CTO、首席架构师，在现公司主导了内部自研DevOps平台的搭建及底层架构设计与规划。敏捷开发思想践行者，擅长利用技术推进项目管理与产品交付。</p><p>在企业级SaaS服务、大规模分布式架构、微服务治理、网关层设计研发等领域积累了丰富的经验，在现公司主导研发的酒店管理系统已累计覆盖10万家门店，日均请求量超1亿。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>入门篇<br>第1章 全面了解Kong网关 2<br>1.1 网关简介 2<br>1.1.1 网关的由来 3<br>1.1.2 网关的作用 3<br>1.2 Kong网关简介 6<br>1.2.1 Kong网关的发展历程 6<br>1.2.2 Kong网关与传统网关对比 6<br>1.2.3 其他主流网关 7<br>1.3 Kong网关基础组件 12<br>1.3.1 Kong服务器 12<br>1.3.2 数据库 13<br>1.3.3 Kong管理GUI 14<br>1.4 Kong网关安装指南 14<br>1.4.1 在Mac环境中安装Kong网关 15<br>1.4.2 在Linux环境中安装Kong网关 15<br>1.4.3 在Docker环境中安装Kong网关 15<br>1.5 使用Kong网关搭建Web应用 16<br>1.5.1 示例项目介绍 16<br>1.5.2 后端服务路由 18<br>1.5.3 静态页面代理 20<br>1.6 本章小结 24<br>第2章 Nginx必备知识 25<br>2.1 Nginx安装 25<br>2.1.1 在Mac环境中安装Nginx 25<br>2.1.2 在Linux环境中安装Nginx 26<br>2.1.3 在Docker环境中安装Nginx 26<br>2.2 Nginx详解 26<br>2.2.1 Nginx文件的目录结构 26<br>2.2.2 命令行参数 28<br>2.2.3 配置文件 29<br>2.2.4 依赖库 32<br>2.2.5 Nginx的工作原理 33<br>2.2.6 Nginx优化指南 35<br>2.3 项目实践 37<br>2.3.1 从Kong切换到Nginx 37<br>2.3.2 添加黑白名单 39<br>2.3.3 添加限流 39<br>2.3.4 从Nginx切换到Kong 41<br>2.3.5 小结 41<br>2.4 本章小结 42<br>第3章 Lua必备知识 43<br>3.1 Lua入门与规范 43<br>3.1.1 基础知识 43<br>3.1.2 安装指南 44<br>3.1.3 解释器 45<br>3.1.4 语法规范 46<br>3.2 数据类型 47<br>3.3 操作符 52<br>3.4 表达式语句 54<br>3.4.1 赋值语句 54<br>3.4.2 控制语句 55<br>3.5 Lua库 58<br>3.6 本章小结 62<br>第4章 OpenResty必备知识 63<br>4.1 OpenResty入门安装 63<br>4.1.1 在Mac环境中安装OpenResty 63<br>4.1.2 在Linux环境中安装OpenResty 64<br>4.1.3 在Docker环境中安装OpenResty 64<br>4.2 OpenResty详解 64<br>4.2.1 OpenResty服务器的目录结构 64<br>4.2.2 Resty CLI 65<br>4.2.3 OpenResty包管理工具 67<br>4.3 OpenResty工作原理 69<br>4.4 OpenResty性能优化 71<br>4.4.1 避免使用阻塞函数 72<br>4.4.2 巧用table组件 72<br>4.4.3 使用缓存 73<br>4.4.4 火焰图 73<br>4.5 项目实践 75<br>4.6 本章小结 82<br>基础篇<br>第5章 Kong网关配置与部署 84<br>5.1 Kong启动项配置 84<br>5.1.1 配置项加载流程 85<br>5.1.2 配置项详解 86<br>5.1.3 环境变量 89<br>5.1.4 配置文件示例 89<br>5.2 注入Nginx指令 90<br>5.2.1 注入单个Nginx指令 91<br>5.2.2 通过文件方式注入Nginx指令 92<br>5.3 个性化使用场景 92<br>5.3.1 自定义Nginx模板文件 93<br>5.3.2 在OpenResty实例中嵌入Kong 93<br>5.4 Kong网关部署 94<br>5.4.1 无数据库部署模式 94<br>5.4.2 数据库部署模式 97<br>5.4.3 混合部署模式 100<br>5.5 本章小结 102<br>第6章 Kong网关命令行 103<br>6.1 通用标志参数 104<br>6.2 Kong网关命令行详解 104<br>6.2.1 kong check 104<br>6.2.2 kong config 106<br>6.2.3 kong health 109<br>6.2.4 kong hybrid 109<br>6.2.5 kong migrations 110<br>6.2.6 kong prepare 112<br>6.2.7 kong quit 113<br>6.2.8 kong reload 113<br>6.2.9 kong restart 114<br>6.2.10 kong start 114<br>6.2.11 kong stop 115<br>6.2.12 kong version 116<br>6.3 本章小结 116<br>第7章 Kong网关代理及鉴权 117<br>7.1 Kong网关代理基础知识 117<br>7.1.1 Kong网关术语简介 117<br>7.1.2 Kong网关代理环境配置 118<br>7.2 Kong网关代理示例 118<br>7.3 路由匹配规则 121<br>7.3.1 通用匹配规则 121<br>7.3.2 paths属性 123<br>7.3.3 hosts属性 126<br>7.3.4 methods属性 128<br>7.3.5 headers属性（hosts除外） 129<br>7.3.6 sources &amp; destinations属性 129<br>7.3.7 snis属性 129<br>7.4 路由匹配优先级 130<br>7.4.1 优先级策略 130<br>7.4.2 后备路由策略 131<br>7.5 Kong网关代理行为 132<br>7.5.1 超时机制 132<br>7.5.2 错误重试机制 133<br>7.5.3 插件执行策略 133<br>7.5.4 响应内容 133<br>7.6 配置SSL协议 134<br>7.7 代理WebSocket流量 135<br>7.8 代理gRPC流量 138<br>7.9 Kong网关鉴权 140<br>7.9.1 通用鉴权流程 140<br>7.9.2 匿名接入流程 142<br>7.9.3 多重认证策略 143<br>7.10 本章小结 144<br>第8章 Kong网关负载均衡策略与健康检查 145<br>8.1 负载均衡 145<br>8.1.1 负载均衡简介 145<br>8.1.2 负载均衡解决方案 146<br>8.1.3 Kong网关中的负载均衡 146<br>8.2 基于DNS的负载均衡 146<br>8.2.1 A记录（包含AAAA记录） 147<br>8.2.2 SRV记录 147<br>8.2.3 DNS 记录优先级 147<br>8.2.4 其他注意事项 148<br>8.3 环状负载均衡器 148<br>8.3.1 基础概念 148<br>8.3.2 负载均衡策略 150<br>8.3.3 其他注意事项 151<br>8.4 负载均衡特性使用场景 151<br>8.4.1 蓝绿发布 151<br>8.4.2 金丝雀发布 155<br>8.5 健康检查 157<br>8.5.1 健康检查标准 157<br>8.5.2 健康检查类型 159<br>8.5.3 健康检查配置 160<br>8.6 本章小结 162<br>进阶篇<br>第9章 Kong网关插件 164<br>9.1 Kong网关插件简介 164<br>9.1.1 Kong网关插件概念 164<br>9.1.2 Kong网关插件原理 165<br>9.2 Kong官方插件 166<br>9.2.1 鉴权类插件 166<br>9.2.2 安全类插件 177<br>9.2.3 流量类插件 179<br>9.2.4 分析监控类插件 195<br>9.2.5 内容转换类插件 197<br>9.2.6 日志类插件 204<br>9.2.7 其他插件 210<br>9.3 自定义Kong网关插件 210<br>9.3.1 自定义插件开发流程和插件生命周期管理详解 210<br>9.3.2 插件开发套件 240<br>9.3.3 Go插件开发向导 241<br>9.3.4 自定义插件实例 243<br>9.4 本章小结 245<br>第10章 Kong网关日志 246<br>10.1 Kong网关日志简介 246<br>10.1.1 Kong网关日志分类 246<br>10.1.2 Kong网关日志级别 248<br>10.2 Kong网关结合日志平台 249<br>10.2.1 ELK方案简介 249<br>10.2.2 Kong网关结合ELK 253<br>10.2.3 日志系统使用场景 256<br>10.3 自定义日志 261<br>10.3.1 Kong网关定制日志 262<br>10.3.2 ELK定制日志 264<br>10.3.3 小结 265<br>10.4 本章小结 266<br>第11章 Kong网关运维 267<br>11.1 资源选型 267<br>11.1.1 服务器资源 267<br>11.1.2 数据库资源 268<br>11.1.3 弹性伸缩 269<br>11.1.4 性能参数 269<br>11.2 Kong网关监控 270<br>11.2.1 监控平台选型 270<br>11.2.2 搭建监控平台 271<br>11.2.3 Kong网关监控平台配置 272<br>11.2.4 Kong网关监控平台指标详解 278<br>11.2.5 Kong监控平台指标测试 279<br>11.2.6 Kong监控平台的预警功能 281<br>11.3 Kong网关运维 284<br>11.3.1 数据备份 284<br>11.3.2 软&#x2F;硬件维护 286<br>11.3.3 突发事件处理 288<br>11.4 本章小结 288<br>第12章 Kong网关安全与集群高可用 289<br>12.1 Kong网关安全配置 289<br>12.1.1 网络层访问限制 289<br>12.1.2 Kong API 回路 290<br>12.1.3 自定义Nginx配置 291<br>12.2 Kong集群 292<br>12.2.1 Kong集群简介 292<br>12.2.2 Kong集群缓存 293<br>12.3 Kong网关高可用 298<br>12.3.1 架构设计 298<br>12.3.2 引入HAProxy层 300<br>12.3.3 高可用方案测试 301<br>12.4 本章小结 308<br>应用篇<br>第13章 Kong网关结合微服务架构 310<br>13.1 微服务简介 310<br>13.1.1 微服务的优点 311<br>13.1.2 单体应用和微服务 311<br>13.1.3 微服务12要素 313<br>13.2 单体应用向微服务迁移 313<br>13.2.1 采用微服务的注意事项 314<br>13.2.2 迁移细节 314<br>13.3 使用CI&#x2F;CD流程促进微服务开发 316<br>13.3.1 CI&#x2F;CD流程基础组件 316<br>13.3.2 构建CI&#x2F;CD流程 318<br>13.4 基于Kong打造DevOps平台 320<br>13.4.1 场景描述 320<br>13.4.2 设计思路 321<br>13.4.3 DevOps平台使用指南 325<br>13.4.4 DevOps平台源码解析 329<br>13.4.5 DevOps平台扩展 335<br>13.5 本章小结 336<br>第14章 Kong网关结合Kubernetes架构方案 337<br>14.1 Kubernetes详解 337<br>14.1.1 Kubernetes简介 337<br>14.1.2 Kubernetes发展史 338<br>14.1.3 Kubernetes基本概念和术语 340<br>14.1.4 Kubernetes的HelloWorld示例 342<br>14.2 Kubernetes与Kong网关结合 350<br>14.2.1 概念描述 350<br>14.2.2 使用Kubernetes安装Kong 358<br>14.3 Kubernetes实战 359<br>14.3.1 安装Kong网关 359<br>14.3.2 使用Kong网关 360<br>14.3.3 配置Kong网关插件 361<br>14.4 本章小结 363<br>第15章 Service Mesh实践之Kuma 364<br>15.1 Service Mesh简介 364<br>15.2 Kuma简介 366<br>15.2.1 为什么使用Kuma 366<br>15.2.2 Kuma与其他Service Mesh方案的比较 366<br>15.2.3 Kuma系统组件 367<br>15.2.4 Kuma部署示例 368<br>15.3 Kuma策略概述 369<br>15.3.1 策略配置项描述 369<br>15.3.2 使用策略 370<br>15.3.3 策略匹配规则 371<br>15.4 Kuma内置策略详解 372<br>15.4.1 安全类策略 372<br>15.4.2 流量控制类策略 376<br>15.4.3 观测类策略 382<br>15.5 Kuma实战 388<br>15.5.1 适配Kuma架构 388<br>15.5.2 启动mTSL和TrafficPermission 390<br>15.6 本章小结 391<br>第16章 Serverless架构 392<br>16.1 Serverless简介 392<br>16.1.1 系统架构演化 392<br>16.1.2 部署方式演化 393<br>16.1.3 Serverless内核 395<br>16.2 Serverless实践 396<br>16.2.1 搭建开发环境 396<br>16.2.2 Web应用服务 402<br>16.3 本章小结 407<br>附录A Docker安装指南 408<br>附录B KONGA安装指南 412<br>附录C 数据库明细 417<br>附录D Admin API 422</p><h3 id="Kong网关：入门、实战与进阶-PDF-下载"><a href="#Kong网关：入门、实战与进阶-PDF-下载" class="headerlink" title="Kong网关：入门、实战与进阶 PDF 下载"></a>Kong网关：入门、实战与进阶 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1aSmiqNJZzFwMUko0RAIeZA?pwd=ox4u">https://pan.baidu.com/s/1aSmiqNJZzFwMUko0RAIeZA?pwd=ox4u</a> </p><p>提取码：ox4u</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> Kong </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python核心编程（第三版）》</title>
      <link href="/2023/05/19/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/19/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/F5IJPIEI1HLE85SBUSJ47UZ6GBJPQTX2.png" alt="《Python核心编程（第三版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是Python开发者的完全指南——针对 Python 2.5全面升级</p><p>·学习专业的Python风格、最佳实践和好的编程习惯；</p><p>·加强对Python对象、内存模型和Python面向对象特性的深入理解；</p><p>·构建更有效的Web、CGI、互联网、网络和其他客户端&#x2F;服务器架构应用程序及软件；</p><p>·学习如何使用Python中的Tkinter和其他工具来开发自己的GUI应用程序及软件；</p><p>·通过用C等语言编写扩展来提升Python应用程序的性能，或者通过使用多线程增强I&#x2F;0相关的应用程序的能力；</p><p>·学习Python中有关数据库的API，以及如何在Python中使用各种不同的数据库系统，包括MySQL、Postgres和 SQLite。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1部分　Python核心<br>第1章　欢迎来到Python世界<br>1.1　什么是Python<br>1.2　起源<br>1.3　特点<br>1.3.1　高级<br>1.3.2　面向对象<br>1.3.3　可升级<br>1.3.4　可扩展<br>1.3.5　可移植性<br>1.3.6　易学<br>1.3.7　易读<br>1.3.8　易维护<br>1.3.9　健壮性<br>1.3.10　高效的快速原型开发工具<br>1.3.11　内存管理器<br>1.3.12　解释性和（字节）编译性<br>1.4　下载和安装Python<br>1.5　运行Python<br>1.5.1　命令行上的交互式解释器<br>1.5.2　从命令行启动脚本<br>1.5.3　集成开发环境<br>1.5.4　其他的集成开发环境和执行环境<br>1.6　Python文档<br>1.7　比较Python（Python与其他语言的比较）<br>1.8　其他实现<br>1.9　练习<br>第2章　快速入门<br>2.1　程序输出，print语句及“Hello World!”<br>2.2　程序输入和raw_input（）内建函数<br>2.3　注释<br>2.4　操作符<br>2.5　变量和赋值<br>2.6　数字<br>2.7　字符串<br>2.8　列表和元组<br>2.9　字典<br>2.10　代码块及缩进对齐<br>2.11　if语句<br>2.12　while循环<br>2.13　for循环和range（）内建函数<br>2.14　列表解析<br>2.15　文件和内建函数open（）、file（）<br>2.16　错误和异常<br>2.17　函数<br>2.17.1　如何定义函数<br>2.17.2　如何调用函数<br>2.17.3　默认参数<br>2.18　类<br>2.19　模块<br>2.19.1　如何导入模块<br>2.19.2　如何访问一个模块函数或访问一个模块变量<br>2.20　实用的函数<br>2.21　练习<br>第3章　Python基础<br>3.1　语句和语法<br>3.1.1　注释（#）<br>3.1.2　继续（\）<br>3.1.3　多个语句构成代码组（:）<br>3.1.4　代码组由不同的缩进分隔<br>3.1.5　同一行书写多个语句（;）<br>3.1.6　模块<br>3.2　变量赋值<br>3.2.1　赋值操作符<br>3.2.2　增量赋值<br>3.2.3　多重赋值<br>3.2.4　“多元”赋值<br>3.3　标识符<br>3.3.1　合法的Python标识符<br>3.3.2　关键字<br>3.3.3　内建<br>3.3.4　专用下划线标识符<br>3.4　基本风格指南<br>3.4.1　模块结构和布局<br>3.4.2　在主程序中书写测试代码<br>3.5　内存管理<br>3.5.1　变量定义<br>3.5.2　动态类型<br>3.5.3　内存分配<br>3.5.4　引用计数<br>3.5.5　垃圾收集<br>3.6　第一个Python程序<br>3.7　相关模块和开发工具<br>3.8　练习<br>第4章　Python对象<br>4.1　Python 对象<br>4.2　标准类型<br>4.3　其他内建类型<br>4.3.1　类型对象和type类型对象<br>4.3.2　None–Python的Null对象<br>4.4　内部类型<br>4.4.1　代码对象<br>4.4.2　帧对象<br>4.4.3　跟踪记录对象<br>4.4.4　切片对象<br>4.4.5　省略对象<br>4.4.6　XRange 对象<br>4.5　标准类型操作符<br>4.5.1　对象值的比较<br>4.5.2　对象身份比较<br>4.5.3　布尔类型<br>4.6　标准类型内建函数<br>4.6.1　type（）<br>4.6.2　cmp（）<br>4.6.3　str（）和repr（）（及&#96;&#96;操作符）<br>4.6.4　type（）和isinstance（）<br>4.6.5　Python类型操作符和内建函数总结<br>4.7　类型工厂函数<br>4.8　标准类型的分类<br>4.8.1　存储模型<br>4.8.2　更新模型<br>4.8.3　访问模型<br>4.9　不支持的类型<br>4.10　练习<br>第5章　数字<br>5.1　数字简介<br>5.1.1　如何创建数值对象并用其赋值（数字对象）<br>5.1.2　如何更新数字对象<br>5.1.3　如何删除数字对象<br>5.2　整型<br>5.2.1　布尔型<br>5.2.2　标准整型<br>5.2.3　长整型<br>5.2.4　整型和长整型的统一<br>5.3　双精度浮点型<br>5.4　复数<br>5.5　操作符<br>5.5.1　混合模式操作符<br>5.5.2　标准类型操作符<br>5.5.3　算术操作符<br>5.5.4　*位操作符（只适用于整型）<br>5.6　内建函数与工厂函数<br>5.6.1　标准类型函数<br>5.6.2　数字类型函数<br>5.6.3　仅用于整型的函数<br>5.7　其他数字类型<br>5.7.1　布尔“数”<br>5.7.2　十进制浮点型<br>5.8　相关模块<br>5.9　练习<br>第6章　序列：字符串、列表和元组<br>6.1　序列<br>6.1.1　标准类型操作符<br>6.1.2　序列类型操作符<br>6.1.3　内建函数（BIF）<br>6.2　字符串<br>6.3　字符串和操作符<br>6.3.1　标准类型操作符<br>6.3.2　序列操作符切片（[]和[:]）<br>6.4　只适用于字符串的操作符<br>6.4.1　格式化操作符（％）<br>6.4.2　字符串模板: 更简单的替代品<br>6.4.3　原始字符串操作符（r&#x2F;R）<br>6.4.4　Unicode字符串操作符（u&#x2F;U）<br>6.5　内建函数<br>6.5.1　标准类型函数<br>6.5.2　序列类型函数<br>6.5.3　字符串类型函数<br>6.6　字符串内建函数<br>6.7　字符串的独特特性<br>6.7.1　特殊字符串和控制字符<br>6.7.2　三引号<br>6.7.3　字符串不变性<br>6.8　Unicode<br>6.8.1　术语<br>6.8.2　什么是Unicode<br>6.8.3　怎样使用Unicode<br>6.8.4　Codec是什么<br>6.8.5　编码解码<br>6.8.6　把Unicode应用到实际应用中<br>6.8.7　从现实中得来的教训<br>6.8.8　Python的Unicode支持<br>6.9　相关模块<br>6.10　字符串关键点总结<br>6.11　列表<br>6.12　操作符<br>6.12.1　标准类型操作符<br>6.12.2　序列类型操作符<br>6.12.3　列表类型操作符和列表解析<br>6.13　内建函数<br>6.13.1　标准类型函数<br>6.13.2　序列类型函数<br>6.13.3　列表类型内建函数<br>6.14　列表类型的内建函数<br>6.15　列表的特殊特性<br>6.16　元组<br>6.17　元组操作符和内建函数<br>6.17.1　标准类型操作符、序列类型操作符和内建函数<br>6.17.2　元组类型操作符和内建函数、内建方法<br>6.18　元组的特殊特性<br>6.18.1　不可变性给元组带来了什么影响<br>6.18.2　元组也不是那么“不可变”<br>6.18.3　默认集合类型<br>6.18.4　单元素元组<br>6.18.5　字典的关键字<br>6.19　相关模块<br>6.20　*拷贝Python对象、浅拷贝和深拷贝<br>6.21　序列类型小结<br>6.22　练习<br>第7章　映像和集合类型<br>7.1　映射类型：字典<br>7.1.1　如何创建字典和给字典赋值<br>7.1.2　如何访问字典中的值<br>7.1.3　如何更新字典<br>7.1.4　如何删除字典元素和字典<br>7.2　映射类型操作符<br>7.2.1　标准类型操作符<br>7.2.2　映射类型操作符<br>7.3　映射类型的内建函数和工厂函数<br>7.3.1　标准类型函数[type（）、str（）和cmp（）]<br>7.3.2　映射类型相关的函数<br>7.4　映射类型内建方法<br>7.5　字典的键<br>7.5.1　不允许一个键对应多个值<br>7.5.2　键必须是可哈希的<br>7.6　集合类型<br>7.6.1　如何创建集合类型和给集合赋值<br>7.6.2　如何访问集合中的值<br>7.6.3　如何更新集合<br>7.6.4　如何删除集合中的成员和集合<br>7.7　集合类型操作符<br>7.7.1　标准类型操作符（所有的集合类型）<br>7.7.2　集合类型操作符（所有的集合类型）<br>7.7.3　集合类型操作符（仅适用于可变集合）<br>7.8　内建函数<br>7.8.1　标准类型函数<br>7.8.2　集合类型工厂函数<br>7.9　集合类型内建方法<br>7.9.1　方法（所有的集合方法）<br>7.9.2　方法（仅适用于可变集合）<br>7.9.3　操作符和内建方法比较<br>7.10　集合类型总结表<br>7.11　相关模块<br>7.12　练习<br>第8章　条件和循环<br>8.1　if语句<br>8.1.1　多重条件表达式<br>8.1.2　单一语句的代码块<br>8.2　else语句<br>8.3　elif（即else-if）语句<br>8.4　条件表达式（即“三元操作符”）<br>8.5　while语句<br>8.5.1　一般语法<br>8.5.2　计数循环<br>8.5.3　无限循环<br>8.6　for语句<br>8.6.1　一般语法<br>8.6.2　用于序列类型<br>8.6.3　用于迭代器类型<br>8.6.4　range（）内建函数<br>8.6.5　xrange（） 内建函数<br>8.6.6　与序列相关的内建函数<br>8.7　break语句<br>8.8　continue语句<br>8.9　pass语句<br>8.10　再谈else语句<br>8.11　迭代器和iter（）函数<br>8.11.1　什么是迭代器<br>8.11.2　为什么要迭代器<br>8.11.3　如何迭代<br>8.11.4　使用迭代器<br>8.11.5　可变对象和迭代器<br>8.11.6　如何创建迭代器<br>8.12　列表解析<br>8.13　生成器表达式<br>8.14　相关模块<br>8.15　练习<br>第9章　文件和输入输出<br>9.1　文件对象<br>9.2　文件内建函数（open（）和file（））<br>9.2.1　工厂函数file（）<br>9.2.2　通用换行符支持（UNS）<br>9.3　文件内建方法<br>9.3.1　输入<br>9.3.2　输出<br>9.3.3　文件内移动<br>9.3.4　文件迭代<br>9.3.5　其他<br>9.3.6　文件方法杂项<br>9.4　文件内建属性<br>9.5　标准文件<br>9.6　命令行参数<br>9.7　文件系统<br>9.8　文件执行<br>9.9　永久存储模块<br>9.9.1　pickle和marshal模块<br>9.9.2　DBM风格的模块<br>9.9.3　shelve模块<br>9.10　相关模块<br>9.11　练习<br>第10章　错误和异常<br>10.1　什么是异常<br>10.1.1　错误<br>10.1.2　异常<br>10.2　Python 中的异常<br>10.3　检测和处理异常<br>10.3.1　try-except语句<br>10.3.2　包装内建函数<br>10.3.3　带有多个except的try语句<br>10.3.4　处理多个异常的except语句<br>10.3.5　捕获所有异常<br>10.3.6　“异常参数”<br>10.3.7　在应用使用我们封装的函数<br>10.3.8　else子句<br>10.3.9　finally子句<br>10.3.10　try-finally语句<br>10.3.11　try-except-else-finally：厨房一锅端<br>10.4　上下文管理<br>10.4.1　with语句<br>10.4.2　*上下文管理协议<br>10.5　*字符串作为异常<br>10.6　触发异常<br>10.7　断言<br>10.8　标准异常<br>10.9　*创建异常<br>10.10　（现在）为什么用异常<br>10.11　到底为什么要异常<br>10.12　异常和sys模块<br>10.13　相关模块<br>10.14　练习<br>第11章　函数和函数式编程<br>11.1　什么是函数？<br>11.1.1　函数vs过程<br>11.1.2　返回值与函数类型<br>11.2　调用函数<br>11.2.1　函数操作符<br>11.2.2　关键字参数<br>11.2.3　默认参数<br>11.2.4　参数组<br>11.3　创建函数<br>11.3.1　def语句<br>11.3.2　声明与定义比较<br>11.3.3　前向引用<br>11.3.4　函数属性<br>11.3.5　内部&#x2F;内嵌函数<br>11.3.6　*函数（与方法）装饰器<br>11.4　传递函数<br>11.5　Formal Arguments<br>11.5.1　位置参数<br>11.5.2　默认参数<br>11.6　可变长度的参数<br>11.6.1　非关键字可变长参数（元组）<br>11.6.2　关键字变量参数（字典）<br>11.6.3　调用带有可变长参数对象函数<br>11.7　函数式编程<br>11.7.1　匿名函数与lambda<br>11.7.2　内建函数apply（）、filter（）、map（）、reduce（）<br>11.7.3　偏函数应用<br>11.8　变量作用域<br>11.8.1　全局变量与局部变量<br>11.8.2　globa语句<br>11.8.3　作用域的数字<br>11.8.4　闭包<br>11.8.5　作用域和lambda<br>11.8.6　变量作用域和名称空间<br>11.9　<em>递归<br>11.10　生成器<br>11.10.1　简单的生成器特性<br>11.10.2　加强的生成器特性<br>11.11　练习<br>第12章　模块<br>12.1　什么是模块<br>12.2　模块和文件<br>12.2.1　模块名称空间<br>12.2.2　搜索路径和路径搜索<br>12.3　名称空间<br>12.3.1　名称空间与变量作用域比较<br>12.3.2　名称查找、确定作用域、覆盖<br>12.3.3　无限制的名称空间<br>12.4　导入模块<br>12.4.1　import语句<br>12.4.2　from-import语句<br>12.4.3　多行导入<br>12.4.4　扩展的import语句（as）<br>12.5　模块导入的特性<br>12.5.1　载入时执行模块<br>12.5.2　导入（import）和加载（load）<br>12.5.3　导入到当前名称空间的名称<br>12.5.4　被导入到导入者作用域的名字<br>12.5.5　关于__future__<br>12.5.6　警告框架<br>12.5.7　从ZIP文件中导入模块<br>12.5.8　“新的”导入钩子<br>12.6　模块内建函数<br>12.6.1　__import__（）<br>12.6.2　globals（）和locals（）<br>12.6.3　reload（）<br>12.7　包<br>12.7.1　目录结构<br>12.7.2　使用from-import导入包<br>12.8　模块的其他特性<br>12.8.1　自动载入的模块<br>12.8.2　阻止属性导入<br>12.8.3　不区分大小的导入<br>12.8.4　源代码编码<br>12.8.5　导入循环<br>12.8.6　模块执行<br>12.9　相关模块<br>12.10　练习<br>第13章　面向对象编程<br>13.1　引言<br>13.2　面向对象编程<br>13.2.1　面向对象设计与面向对象编程的关系<br>13.2.2　现实中的问题<br>13.2.3　<em>常用术语<br>13.3　类<br>13.3.1　创建类<br>13.3.2　声明与定义<br>13.4　类属性<br>13.4.1　类的数据属性<br>13.4.2　Methods<br>13.4.3　决定类的属性<br>13.4.4　特殊的类属性<br>13.5　实例<br>13.5.1　初始化：通过调用类对象来创建实例<br>13.5.2　__init__（）“构造器”方法<br>13.5.3　__new__（）“构造器”方法<br>13.5.4　__del__（）“解构器”方法<br>13.6　实例属性<br>13.6.1　“实例化”实例属性（或创建一个更好的构造器）<br>13.6.2　查看实例属性<br>13.6.3　特殊的实例属性<br>13.6.4　建类型属性<br>13.6.5　实例属性vs类属性<br>13.7　绑定和方法调用<br>13.7.1　调用绑定方法<br>13.7.2　调用非绑定方法<br>13.8　静态方法和类方法<br>13.8.1　staticmethod（）和classmethod（）内建函数<br>13.8.2　使用函数修饰符<br>13.9　组合<br>13.10　子类和派生<br>13.11　继承<br>13.11.1　__bases__类属性<br>13.11.2　通过继承覆盖方法<br>13.11.3　从标准类型派生<br>13.11.4　多重继承<br>13.12　类、实例和其他对象的内建函数<br>13.12.1　issubclass（）<br>13.12.2　isinstance（）<br>13.12.3　hasattr（）、getattr（）、setattr（）、delattr（）<br>13.12.4　dir（）<br>13.12.5　super（）<br>13.12.6　vars（）<br>13.13　用特殊方法定制类<br>13.13.1　简单定制（RoundFloat2）<br>13.13.2　数值定制（Time60）<br>13.13.3　迭代器（RandSeq和AnyIter）<br>13.13.4　<em>多类型定制（NumStr）<br>13.14　私有化<br>13.15　<em>授权<br>13.15.1　包装<br>13.15.2　实现授权<br>13.16　新式类的高级特性（Python 2.2+）<br>13.16.1　新式类的通用特性<br>13.16.2　__slots__类属性<br>13.16.3　<strong>getattribute__（）特殊方法<br>13.16.4　描述符<br>13.16.5　元类和__metaclass</strong><br>13.17　相关模块和文档<br>13.18　练习<br>第14章　执行环境<br>14.1　可调用对象<br>14.1.1　函数<br>14.1.2　方法<br>14.1.3　类<br>14.1.4　类的实例<br>14.2　代码对象<br>14.3　可执行的对象声明和内建函数<br>14.3.1　callable（）<br>14.3.2　compile（）<br>14.3.3　eval（）<br>14.3.4　exec<br>14.3.5　input（）<br>14.3.6　使用Python在运行时生成和执行Python代码<br>14.4　执行其他（Python）程序<br>14.4.1　导入<br>14.4.2　execfile（）<br>14.4.3　将模块作为脚本执行<br>14.5　执行其他（非Python）程序<br>14.5.1　os.system（）<br>14.5.2　os.popen（）<br>14.5.3　os.fork（）、os.exec</em>（）、os.wait</em>（）<br>14.5.4　os.spawn</em>（）<br>14.5.5　subprocess 模块<br>14.5.6　相关函数<br>14.6　受限执行<br>14.7　结束执行<br>14.7.1　sys.exit（） and SystemExit<br>14.7.2　sys.exitfunc（）<br>14.7.3　os._exit（） 函数<br>14.7.4　os.kill（） Function<br>14.8　各种操作系统接口<br>14.9　相关模块<br>14.10　练习<br>第2部分　高级主题<br>第15章　正则表达式<br>15.1　引言&#x2F;动机<br>15.2　正则表达式使用的特殊符号和字符<br>15.2.1　用管道符号（|）匹配多个正则表达式模式<br>15.2.2　匹配任意一个单个的字符（.）<br>15.2.3　从字符串的开头或结尾或单词边界开始匹配（^&#x2F;$ &#x2F;\b &#x2F;\B ）<br>15.2.4　创建字符类（[]）<br>15.2.5　指定范围（-）和否定（^）<br>15.2.6　使用闭包操作符（</em>，+，?，{}）实现多次出现&#x2F;重复匹配<br>15.2.7　特殊字符表示、字符集<br>15.2.8　用圆括号（（））组建组<br>15.3　正则表达式和Python语言<br>15.3.1　re模块：核心函数和方法<br>15.3.2　使用compile（）编译正则表达式<br>15.3.3　匹配对象和group（）、groups（）方法<br>15.3.4　用match（）匹配字符串<br>15.3.5　search（）在一个字符串中查找一个模式（搜索与匹配的比较）<br>15.3.6　匹配多个字符串（|）<br>15.3.7　匹配任意单个字符（.）<br>15.3.8　创建字符集合（[]）<br>15.3.9　重复、特殊字符和子组<br>15.3.10　从字符串的开头或结尾匹配及在单词边界上的匹配<br>15.3.11　用findall（）找到每个出现的匹配部分<br>15.3.12　用sub（）（和subn（））进行搜索和替换<br>15.3.13　用split（）分割（分隔模式）<br>15.4　正则表达式示例<br>15.4.1　匹配一个字符串<br>15.4.2　搜索与匹配的比较，“贪婪”匹配<br>15.5　练习<br>第16章　网络编程<br>16.1　引言<br>16.1.1　什么是客户端&#x2F;服务器架构<br>16.1.2　客户端&#x2F;服务器网络编程<br>16.2　套接字：通信端点<br>16.2.1　什么是套接字<br>16.2.2　套接字地址：主机与端口<br>16.2.3　面向连接与无连接<br>16.3　Python中的网络编程<br>16.3.1　socket（）模块函数<br>16.3.2　套接字对象（内建）方法<br>16.3.3　创建一个TCP服务器<br>16.3.4　创建TCP客户端<br>16.3.5　运行我们的客户端与TCP服务器<br>16.3.6　创建一个UDP服务器<br>16.3.7　创建一个UDP客户端<br>16.3.8　执行UDP服务器和客户端<br>16.3.9　Socket模块属性<br>16.4　*SocketServer模块<br>16.4.1　创建一个SocketServerTCP服务器<br>16.4.2　创建SocketServerTCP客户端<br>16.4.3　执行TCP服务器和客户端<br>16.5　Twisted框架介绍<br>16.5.1　创建一个Twisted Reactor TCP服务器<br>16.5.2　创建一个Twisted Reactor TCP客户端<br>16.5.3　执行TCP服务器和客户端<br>16.6　相关模块<br>16.7　练习<br>第17章　网络客户端编程<br>17.1　什么是因特网客户端<br>17.2　文件传输<br>17.2.1　文件传输网际协议<br>17.2.2　文件传输协议（FTP）<br>17.2.3　Python和FTP<br>17.2.4　ftplib.FTP类方法<br>17.2.5　交互式FTP示例<br>17.2.6　客户端FTP程序举例<br>17.2.7　FTP的其他方面<br>17.3　网络新闻<br>17.3.1　Usenet与新闻组<br>17.3.2　网络新闻传输协议（NNTP）<br>17.3.3　Python和NNTP<br>17.3.4　nntplib.NNTP类方法<br>17.3.5　交互式NNTP举例<br>17.3.6　客户端程序NNTP举例<br>17.3.7　NNTP的其他方面<br>17.4　电子邮件<br>17.4.1　电子邮件系统组件和协议<br>17.4.2　发送电子邮件<br>17.4.3　Python和SMTP<br>17.4.4　smtplib.SMTP类方法<br>17.4.5　交互式SMTP示例<br>17.4.6　SMTP的其他方面<br>17.4.7　接收电子邮件<br>17.4.8　POP和IMAP<br>17.4.9　Python和POP3<br>17.4.10　交互式POP3举例<br>17.4.11　poplib.POP3类方法<br>17.4.12　客户端程序SMTP和POP3举例<br>17.5　相关模块<br>17.5.1　电子邮件<br>17.5.2　其他网络协议<br>17.6　练习<br>第18章　多线程编程<br>18.1　引言&#x2F;动机<br>18.2　线程和进程<br>18.2.1　什么是进程<br>18.2.2　什么是线程<br>18.3　Python、线程和全局解释器锁<br>18.3.1　全局解释器锁（GIL）<br>18.3.2　退出线程<br>18.3.3　在Python中使用线程<br>18.3.4　没有线程支持的情况<br>18.3.5　Python的threading模块<br>18.4　thread模块<br>18.5　threading模块<br>18.5.1　Thread类<br>18.5.2　斐波那契、阶乘和累加和<br>18.5.3　threading模块中的其他函数<br>18.5.4　生产者-消费者问题和Queue模块<br>18.6　相关模块<br>18.7　练习<br>第19章　图形用户界面编程<br>19.1　简介<br>19.1.1　什么是Tcl、Tk和Tkinter<br>19.1.2　安装和使用Tkinter　533<br>19.1.3　客户端&#x2F;服务器架构　534<br>19.2　Tkinter与Python编程　534<br>19.2.1　Tkinter模块：把Tk引入你的程序<br>19.2.2　GUI程序开发简介<br>19.2.3　顶层窗口：Tkinter.Tk（）<br>19.2.4　Tk组件<br>19.3　Tkinter举例<br>19.3.1　标签组件<br>19.3.2　按钮组件<br>19.3.3　标签和按钮组件<br>19.3.4　标签、按钮和进度条组件<br>19.3.5　偏函数应用举例<br>19.3.6　中级Tkinter范例<br>19.4　其他GUI简介<br>19.4.1　Tk Interface eXtensions （Tix）<br>19.4.2　Python MegaWidgets （PMW）<br>19.4.3　wxWidgets和wxPython<br>19.4.4　GTK+和PyGTK<br>19.5　相关模块和其他GUI<br>19.6　练习<br>第20章　Web编程<br>20.1　介绍<br>20.1.1　Web应用：客户端&#x2F;服务器计算<br>20.1.2　因特网<br>20.2　使用Python进行Web应用：创建一个简单的Web客户端<br>20.2.1　统一资源定位符<br>20.2.2　urlparse模块<br>20.2.3　urllib模块<br>20.2.4　urllib2模块<br>20.3　高级Web客户端<br>20.4　CGI：帮助Web服务器处理客户端数据<br>20.4.1　CGI介绍<br>20.4.2　CGI应用程序<br>20.4.3　cgi模块<br>20.5　建立CGI应用程序<br>20.5.1　建立Web服务器<br>20.5.2　建立表单页<br>20.5.3　生成结果页<br>20.5.4　生成表单和结果页面<br>20.5.5　全面交互的Web站点<br>20.6　在CGI中使用Unicode编码<br>20.7　高级CGI<br>20.7.1　Mulitipart表单提交和文件的上传<br>20.7.2　多值字段<br>20.7.3　cookie<br>20.7.4　使用高级CGI<br>20.8　Web（HTTP）服务器<br>20.9　相关模块<br>20.10　练习<br>第21章　数据库编程<br>21.1　介绍<br>21.1.1　持久存储<br>21.1.2　基本的数据库操作和SQL语言<br>21.1.3　数据库和Python<br>21.2　Python数据库应用程序程序员接口（DB-API）<br>21.2.1　模块属性<br>21.2.2　连接对象<br>21.2.3　游标对象<br>21.2.4　类型对象和构造器<br>21.2.5　关系数据库<br>21.2.6　数据库和Python：接口程序<br>21.2.7　使用数据库接口程序举例<br>21.3　对象-关系管理器（ORM）<br>21.3.1　考虑对象，而不是SQL<br>21.3.2　Python和ORM<br>21.3.3　雇员数据库举例<br>21.3.4　总结<br>21.4　相关模块<br>21.5　练习<br>第22章　扩展Python　623<br>22.1　引言&#x2F;动机<br>22.1.1　什么是扩展<br>22.1.2　为什么要扩展Python<br>22.2　创建Python扩展<br>22.2.1　创建您的应用程序代码<br>22.2.2　用样板来包装你的代码<br>22.2.3　编译<br>22.2.4　导入和测试<br>22.2.5　引用计数<br>22.2.6　线程和全局解释器锁（GIL）<br>22.3　相关话题<br>22.4　练习<br>第23章　其他话题<br>23.1　Web服务<br>23.2　用Win32的COM来操作微软Office<br>23.2.1　客户端COM编程<br>23.2.2 微软Excel<br>23.2.3　微软Word　第1部分　Python核心<br>23.2.4　微软PowerPoint<br>23.2.5　微软Outlook<br>23.2.6　中等规模的例子<br>23.3　用Jython写Python和Java的程序<br>23.3.1　什么是Jython<br>23.3.2　Swing GUI开发（Java或者Python!）<br>23.4　练习<br>23.2.4　微软PowerPoint<br>23.2.5　微软Outlook<br>23.2.6　中等规模的例子<br>23.3　用Jython写Python和Java的程序<br>23.3.1　什么是Jython<br>23.3.2　Swing GUI开发（Java或者Python!）<br>23.4　练习</p><h3 id="Python核心编程（第三版）-PDF-下载地址"><a href="#Python核心编程（第三版）-PDF-下载地址" class="headerlink" title="Python核心编程（第三版） PDF 下载地址:"></a>Python核心编程（第三版） PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1HMIaAUXX_vJaCdTpNDtUfA?pwd=u62u">https://pan.baidu.com/s/1HMIaAUXX_vJaCdTpNDtUfA?pwd=u62u</a> </p><p>提取码: u62u </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python程序设计 人工智能案例实践》</title>
      <link href="/2023/05/19/Python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/05/19/Python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/GQ56ZXG5HPWS5N53DMH0LE4ZGIBDOOAM.png" alt="《Python程序设计 人工智能案例实践》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>通过学习本书提供的500多个实际示例，读者将学会使用交互式IPython解释器和Jupyter Notebook并快速掌握Python编码方法。在学习完第1<del>5章的Python基础知识以及第6和7章的一些关键内容之后，读者将能够处理第11</del>16章中有关人工智能案例的重要实操内容，包括自然语言处理，用于情感分析的Twitter数据挖掘，使用IBM Watson 的认知计算，利用分类和回归进行的有监督机器学习，通过聚类进行的无监督机器学习，基于深度学习和卷积神经网络的计算机视觉，基于递归神经网络的深度学习，基于Hadoop、Spark和NoSQL数据库的大数据处理，物联网等。读者还将直接或间接使用基于云的服务，如Twitter、Google Translate、IBM Watson、Microsoft Azure、OpenMapQuest、PubNub等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>保罗·戴特尔（Paul Deitel）</p><p>Deitel＆Associates公司首席执行官兼首席技术官，毕业于麻省理工学院，拥有38年的计算经验。保罗是世界上最有经验的编程语言培训师之一，自1992年以来一直针对软件开发人员教授专业课程。他服务过的国际客户包括思科、IBM、西门子、Oracle、戴尔、富达、美国国家航空航天局肯尼迪航天中心等。他也是国际上最畅销的编程语言经典图书的撰写者，如C++ How to program、C How to program、Java How to program、Visual C# How to Program，等等。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　Python基础知识快速入门<br>第1章　Python及大数据概述2<br>1.1　简介2<br>1.2　快速回顾面向对象技术的基础知识3<br>1.3　Python5<br>1.4　Python库7<br>1.4.1　Python标准库7<br>1.4.2　数据科学库8<br>1.5　试用IPython和Jupyter Notebook9<br>1.5.1　使用IPython交互模式作为计算器10<br>1.5.2　使用IPython 解释器执行Python程序11<br>1.5.3　在Jupyter Notebook中编写和执行代码12<br>1.6　云和物联网16<br>1.6.1　云16<br>1.6.2　物联网17<br>1.7　大数据有多大18<br>1.7.1　大数据分析22<br>1.7.2　数据科学和大数据正在带来改变：用例23<br>1.8　案例研究：大数据移动应用程序24<br>1.9　数据科学入门：人工智能——计算机科学与数据科学的交叉学科26<br>1.10　小结28<br>第2章　Python程序设计概述29<br>2.1　简介29<br>2.2　变量和赋值语句30<br>2.3　算术运算31<br>2.4　print函数、单引号和双引号34<br>2.5　三引号字符串36<br>2.6　从用户处获取输入37<br>2.7　决策：if语句和比较运算符39<br>2.8　对象和动态类型43<br>2.9　数据科学入门：基础的描述性统计44<br>2.10　小结46<br>第3章　控制语句48<br>3.1　简介48<br>3.2　控制语句概述49<br>3.3　if语句49<br>3.4　if…else和if…elif…else语句50<br>3.5　while语句53<br>3.6　for语句54<br>3.6.1　可迭代对象、列表和迭代器55<br>3.6.2　内置函数range55<br>3.7　增强赋值56<br>3.8　序列控制迭代和格式化字符串56<br>3.9　边界值控制的迭代57<br>3.10　内置函数range：深入讨论59<br>3.11　使用Decimal类型处理货币金额59<br>3.12　break和continue语句63<br>3.13　布尔运算符and、or和not63<br>3.14　数据科学入门：集中趋势度量—均值、中值和众数66<br>3.15　小结67<br>第4章　函数69<br>4.1　简介69<br>4.2　函数定义70<br>4.3　多参数函数72<br>4.4　随机数生成74<br>4.5　案例研究：一个运气游戏76<br>4.6　Python标准库79<br>4.7　math模块中的函数80<br>4.8　在IPython中使用制表符自动补全81<br>4.9　默认参数值82<br>4.10　关键字参数83<br>4.11　不定长参数列表83<br>4.12　方法：属于对象的函数84<br>4.13　作用域规则85<br>4.14　import：深入讨论87<br>4.15　向函数传递参数：深入讨论88<br>4.16　递归91<br>4.17　函数式编程93<br>4.18　数据科学入门：离中趋势度量95<br>4.19　小结96<br>第5章　序列：列表和元组97<br>5.1　简介97<br>5.2　列表98<br>5.3　元组102<br>5.4　序列解包104<br>5.5　序列切片106<br>5.6　使用del声明108<br>5.7　将列表传递给函数109<br>5.8　列表排序110<br>5.9　序列搜索111<br>5.10　列表的其他方法113<br>5.11　使用列表模拟堆栈115<br>5.12　列表推导式116<br>5.13　生成器表达式118<br>5.14　过滤、映射和归约118<br>5.15　其他的序列处理函数120<br>5.16　二维列表122<br>5.17　数据科学入门：模拟和静态可视化124<br>5.17.1　掷600、60,000、6,000,000次骰子的图例124<br>5.17.2　实现掷骰子中不同点数出现次数和百分比的可视化126<br>5.18　小结132<br>第二部分　Python数据结构、字符串和文件<br>第6章　字典和集合136<br>6.1　简介136<br>6.2　字典137<br>6.2.1　创建字典137<br>6.2.2　遍历字典138<br>6.2.3　基本的字典操作138<br>6.2.4　字典的keys和values方法140<br>6.2.5　字典的比较141<br>6.2.6　示例：学生成绩字典142<br>6.2.7　示例：单词计数143<br>6.2.8　字典的update方法144<br>6.2.9　字典推导式145<br>6.3　集合146<br>6.3.1　集合的比较147<br>6.3.2　集合的数学运算148<br>6.3.3　集合的可变运算符和方法150<br>6.3.4　集合推导式151<br>6.4　数据科学入门：动态可视化151<br>6.4.1　动态可视化的工作原理152<br>6.4.2　实现动态可视化154<br>6.5　小结156<br>第7章　使用NumPy进行面向数组的编程158<br>7.1　简介158<br>7.2　从现有数据创建数组159<br>7.3　数组属性160<br>7.4　用特定值填充数组162<br>7.5　从范围创建数组162<br>7.6　列表与数组的性能比较：引入%timeit164<br>7.7　数组运算符165<br>7.8　NumPy计算方法167<br>7.9　通用函数168<br>7.10　索引和切片170<br>7.11　视图：浅拷贝171<br>7.12　视图：深拷贝173<br>7.13　重塑和转置174<br>7.14　数据科学入门：pandas Series和DataFrame176<br>7.14.1　Series177<br>7.14.2　DataFrame181<br>7.15　小结188<br>第8章　字符串：深入讨论190<br>8.1　简介190<br>8.2　格式化字符串191<br>8.2.1　表示类型191<br>8.2.2　字段宽度和对齐方式193<br>8.2.3　数字格式化193<br>8.2.4　字符串的format方法194<br>8.3　拼接和重复字符串195<br>8.4　去除字符串中的空白字符196<br>8.5　字符大小写转换196<br>8.6　字符串的比较运算符197<br>8.7　查找子字符串197<br>8.8　替换子字符串199<br>8.9　字符串拆分和连接199<br>8.10　字符串测试方法201<br>8.11　原始字符串202<br>8.12　正则表达式介绍202<br>8.12.1　re模块与fullmatch函数203<br>8.12.2　替换子字符串和拆分字符串207<br>8.12.3　其他搜索功能、访问匹配207<br>8.13　数据科学入门：pandas、正则表达式和数据治理210<br>8.14　小结214<br>第9章　文件和异常215<br>9.1　简介215<br>9.2　文件216<br>9.3　文本文件处理217<br>9.3.1　向文本文件中写入数据：with语句的介绍217<br>9.3.2　从文本文件中读取数据218<br>9.4　更新文本文件220<br>9.5　使用JSON进行序列化221<br>9.6　关注安全：pickle序列化和反序列化224<br>9.7　关于文件的附加说明224<br>9.8　处理异常225<br>9.8.1　被零除和无效输入226<br>9.8.2　try语句226<br>9.8.3　在一条except子句中捕获多个异常229<br>9.8.4　一个函数或方法引发了什么异常229<br>9.8.5　try子句的语句序列中应该书写什么代码229<br>9.9　finally子句229<br>9.10　显式地引发一个异常231<br>9.11　（选学）堆栈展开和回溯232<br>9.12　数据科学入门：使用CSV文件234<br>9.12.1　Python标准库模块csv234<br>9.12.2　将CSV文件数据读入pandas DataFrame中236<br>9.12.3　读取泰坦尼克号灾难数据集237<br>9.12.4　用泰坦尼克号灾难数据集做简单的数据分析238<br>9.12.5　乘客年龄直方图239<br>9.13　小结240<br>第三部分　Python高级主题<br>第10章　面向对象编程242<br>10.1　简介242<br>10.2　自定义Account类244<br>10.2.1　试用Account类245<br>10.2.2　Account类的定义246<br>10.2.3　组合：对象引用作为类的成员248<br>10.3　属性访问控制248<br>10.4　用于数据访问的property249<br>10.4.1　试用Time类249<br>10.4.2　Time类的定义251<br>10.4.3　Time类定义的设计说明254<br>10.5　模拟“私有”属性255<br>10.6　案例研究：洗牌和分牌模拟257<br>10.6.1　试用Card类和DeckOfCards类257<br>10.6.2　Card类：引入类属性258<br>10.6.3　DeckOfCards类260<br>10.6.4　利用Matplotlib显示扑克牌图像262<br>10.7　继承：基类和子类265<br>10.8　构建继承层次结构：引入多态性267<br>10.8.1　基类CommissionEmployee267<br>10.8.2　子类SalariedCommission-Employee270<br>10.8.3　以多态方式处理Commission-Employee和SalariedComm-issionEmployee273<br>10.8.4　关于基于对象和面向对象编程的说明274<br>10.9　鸭子类型和多态性274<br>10.10　运算符重载276<br>10.10.1　试用Complex类277<br>10.10.2　Complex类的定义278<br>10.11　异常类层次结构和自定义异常279<br>10.12　具名元组280<br>10.13　Python 3.7的新数据类简介281<br>10.13.1　创建Card数据类282<br>10.13.2　使用Card数据类284<br>10.13.3　数据类相对于具名元组的优势286<br>10.13.4　数据类相对于传统类的优势286<br>10.14　使用文档字符串和doctest进行单元测试286<br>10.15　命名空间和作用域290<br>10.16　数据科学入门：时间序列和简单线性回归293<br>10.17　小结300<br>第四部分　人工智能、云和大数据案例研究<br>第11章　自然语言处理304<br>11.1　简介304<br>11.2　TextBlob305<br>11.2.1　创建一个TextBlob对象307<br>11.2.2　将文本标记为句子和单词307<br>11.2.3　词性标注308<br>11.2.4　提取名词短语309<br>11.2.5　使用TextBlob的默认情感分析器进行情感分析309<br>11.2.6　使用NaiveBayesAnalyzer进行情感分析310<br>11.2.7　语言检测与翻译311<br>11.2.8　变形：复数化和单数化312<br>11.2.9　拼写检查和拼写校正313<br>11.2.10　规范化：词干提取和词形还原314<br>11.2.11　词频314<br>11.2.12　从WordNet中获取单词定义、同义词和反义词315<br>11.2.13　删除停用词317<br>11.2.14　n元318<br>11.3　使用柱状图和词云可视化词频319<br>11.3.1　使用pandas可视化词频319<br>11.3.2　使用词云可视化词频321<br>11.4　使用Textatistic库进行可读性评估324<br>11.5　使用spaCy命名实体识别326<br>11.6　使用spaCy进行相似性检测327<br>11.7　其他NLP库和工具328<br>11.8　机器学习和深度学习自然语言应用328<br>11.9　自然语言数据集329<br>11.10　小结329<br>第12章　Twitter数据挖掘331<br>12.1　简介331<br>12.2　Twitter API概况333<br>12.3　创建一个Twitter账户334<br>12.4　获取Twitter凭据，创建应用程序334<br>12.5　什么是推文336<br>12.6　Tweepy339<br>12.7　通过Tweepy进行Twitter身份验证340<br>12.8　获取一个Twitter账户的相关信息341<br>12.9　Tweepy Cursor简介：获得一个账户的关注者和朋友343<br>12.9.1　确定一个账户的关注者343<br>12.9.2　确定一个账户的关注对象345<br>12.9.3　获取一个用户的最新推文345<br>12.10　搜索最新的推文346<br>12.11　热门话题发现：Twitter热门话题API348<br>12.11.1　有热门话题的地点348<br>12.11.2　获取热门话题列表349<br>12.11.3　根据热门话题创建词云351<br>12.12　推文分析前的清理或预处理352<br>12.13　Twitter流API353<br>12.13.1　创建StreamListener的子类353<br>12.13.2　启动流处理356<br>12.14　推文情感分析357<br>12.15　地理编码和映射361<br>12.15.1　获取和映射推文362<br>12.15.2　tweetutilities.py中的实用函数366<br>12.15.3　LocationListener类367<br>12.16　存储推文的方法368<br>12.17　Twitter和时间序列369<br>12.18　小结369<br>第13章　IBM Watson和认知计算370<br>13.1　简介370<br>13.2　IBM云账户和云控制台372<br>13.3　Watson服务372<br>13.4　额外的服务和工具375<br>13.5　Watson开发者云Python SDK377<br>13.6　案例研究：旅行者翻译伴侣APP377<br>13.6.1　准备工作378<br>13.6.2　运行APP379<br>13.6.3　SimpleLanguageTranslator.py脚本代码分析380<br>13.7　Watson资源390<br>13.8　小结391<br>第14章　机器学习：分类、回归和聚类392<br>14.1　简介392<br>14.1.1　scikit-learn393<br>14.1.2　机器学习的类别394<br>14.1.3　scikit-learn中内置的数据集396<br>14.1.4　典型的数据科学研究的步骤396<br>14.2　案例研究：用k近邻算法和Digits数据集进行分类（第1部分）397<br>14.2.1　k近邻算法398<br>14.2.2　加载数据集399<br>14.2.3　可视化数据402<br>14.2.4　拆分数据以进行训练和测试404<br>14.2.5　创建模型405<br>14.2.6　训练模型405<br>14.2.7　预测数字类别406<br>14.3　案例研究：利用k近邻算法和Digits数据集进行分类（第2部分）407<br>14.3.1　模型准确性指标407<br>14.3.2　k折交叉验证410<br>14.3.3　运行多个模型以找到最佳模型411<br>14.3.4　超参数调整413<br>14.4　案例研究：时间序列和简单线性回归413<br>14.5　案例研究：基于加利福尼亚房价数据集的多元线性回归418<br>14.5.1　加载数据集418<br>14.5.2　使用pandas探索数据420<br>14.5.3　可视化特征422<br>14.5.4　拆分数据以进行训练和测试426<br>14.5.5　训练模型426<br>14.5.6　测试模型427<br>14.5.7　可视化预测房价和期望房价427<br>14.5.8　回归模型指标428<br>14.5.9　选择最佳模型429<br>14.6　案例研究：无监督学习（第1部分）—降维430<br>14.7　案例研究：无监督学习（第2部分）—k均值聚类433<br>14.7.1　加载Iris数据集435<br>14.7.2　探索Iris数据集：使用pandas进行描述性统计436<br>14.7.3　使用Seaborn的pairplot可视化数据集438<br>14.7.4　使用KMeans估计器440<br>14.7.5　主成分分析降维442<br>14.7.6　选择最佳聚类估计器444<br>14.8　小结445<br>第15章　深度学习447<br>15.1　简介447<br>15.1.1　深度学习应用449<br>15.1.2　深度学习演示450<br>15.1.3　Keras资源450<br>15.2　Keras内置数据集450<br>15.3　自定义Anaconda环境451<br>15.4　神经网络452<br>15.5　张量454<br>15.6　用于视觉的卷积神经网络：使用MNIST数据集进行多分类455<br>15.6.1　加载MNIST数据集457<br>15.6.2　数据探索457<br>15.6.3　数据准备459<br>15.6.4　创建神经网络模型461<br>15.6.5　训练和评价模型468<br>15.6.6　保存和加载模型472<br>15.7　用TensorBoard可视化神经网络的训练过程473<br>15.8　ConvnetJS：基于浏览器的深度学习训练和可视化476<br>15.9　针对序列的递归神经网络：使用IMDb数据集进行情感分析477<br>15.9.1　加载IMDb影评数据集478<br>15.9.2　数据探索478<br>15.9.3　数据准备480<br>15.9.4　创建神经网络481<br>15.9.5　训练和评价模型483<br>15.10　调整深度学习模型484<br>15.11　在ImageNet上预训练的CNN模型485<br>15.12　小结486<br>第16章　大数据：Hadoop、Spark、NoSQL和IoT488<br>16.1　简介488<br>16.2　关系数据库和结构化查询语言492<br>16.2.1　books数据库493<br>16.2.2　SELECT查询497<br>16.2.3　WHERE子句497<br>16.2.4　ORDER BY子句498<br>16.2.5　从多个表中合并数据：INNER JOIN499<br>16.2.6　INSERT INTO语句500<br>16.2.7　UPDATE语句501<br>16.2.8　DELETE FROM语句502<br>16.3　NoSQL和NewSQL大数据数据库简述502<br>16.3.1　NoSQL键-值数据库503<br>16.3.2　NoSQL文档数据库503<br>16.3.3　NoSQL列式数据库504<br>16.3.4　NoSQL图数据库504<br>16.3.5　NewSQL数据库505<br>16.4　案例研究：MongoDB JSON文档数据库506<br>16.4.1　创建MongoDB Atlas集群506<br>16.4.2　将推文存入MongoDB中507<br>16.5　Hadoop515<br>16.5.1　概述516<br>16.5.2　通过MapReduce汇总Romeo-AndJuliet.txt中的单词长度518<br>16.5.3　在Microsoft Azure HDInsight中创建Apache Hadoop集群518<br>16.5.4　Hadoop流520<br>16.5.5　实现映射器520<br>16.5.6　实现归约器521<br>16.5.7　准备运行MapReduce示例522<br>16.5.8　运行MapReduce作业523<br>16.6　Spark525<br>16.6.1　概述525<br>16.6.2　Docker和Jupyter Docker堆栈526<br>16.6.3　使用Spark的单词计数529<br>16.6.4　Microsoft Azure上的Spark单词计数532<br>16.7　Spark流：使用pyspark-notebookDocker堆栈计算Twitter主题标签535<br>16.7.1　将推文流式传输到套接字535<br>16.7.2　总结推文主题标签，介绍Spark SQL538<br>16.8　物联网和仪表板543<br>16.8.1　发布和订阅545<br>16.8.2　使用Freeboard仪表板可视化PubNub示例实时流545<br>16.8.3　用Python模拟一个连接互联网的恒温器547<br>16.8.4　使用freeboard.io创建仪表板549<br>16.8.5　创建一个Python PubNub订阅服务器550<br>16.9　小结554<br>索引556</p><h3 id="Python程序设计-人工智能案例实践-PDF-下载地址"><a href="#Python程序设计-人工智能案例实践-PDF-下载地址" class="headerlink" title="Python程序设计 人工智能案例实践 PDF 下载地址:"></a>Python程序设计 人工智能案例实践 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1HsVD-Pc4mTAsmrbFWFwKEg?pwd=e9hm">https://pan.baidu.com/s/1HsVD-Pc4mTAsmrbFWFwKEg?pwd=e9hm</a> </p><p>提取码: e9hm </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python编程：从入门到实践》</title>
      <link href="/2023/05/19/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/05/19/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/031C7413E5CDC918603FDAB290074F33.png" alt="《Python编程：从入门到实践》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是针对所有层次Python读者而作的Python入门书。全书分两部分：第一部分介绍用Python编程所必须了解的基本概念，包括Matplotlib等强大的Python库和工具，以及列表、字典、if语句、类、文件与异常、代码测试等内容；第二部分将理论付诸实践，讲解如何开发三个项目，包括简单的2D游戏、利用数据生成交互式的信息图以及创建和定制简单的Web应用，并帮助读者解决常见编程问题和困惑。第2版进行了全面修订，简化了Python安装流程，新增了f字符串、get()方法等内容，并且在项目中使用了Plotly库以及新版本的Django和Bootstrap，等等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>埃里克·马瑟斯（Eric Matthes）</p><p>高中科学和数学老师，现居住在阿拉斯加，在当地讲授Python入门课程。他从5岁开始就一直在编写程序。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 基础知识<br>第1章 起步　　2<br>1.1 搭建编程环境　　2<br>1.1.1 Python版本　　2<br>1.1.2 运行Python代码片段　　2<br>1.1.3 Sublime Text简介　　3<br>1.2 在不同操作系统中搭建Python编程环境　　3<br>1.2.1 在Windows系统中搭建Python编程环境　　4<br>1.2.2 在macOS系统中搭建Python编程环境　　5<br>1.2.3 在Linux 系统中搭建Python编程环境　　7<br>1.3 运行Hello World 程序　　8<br>1.3.1 配置Sublime Text以使用正确的Python版本　　8<br>1.3.2 运行程序hello_world.py　　8<br>1.4 解决安装问题　　9<br>1.5 从终端运行Python程序　　9<br>1.5.1 在Windows系统中从终端运行Python 程序　　10<br>1.5.2 在Linux和macOS系统中从终端运行Python程序　　10<br>1.6 小结　　11<br>第2章 变量和简单数据类型　　12<br>2.1 运行hello_world.py时发生的情况　　12<br>2.2 变量　　13<br>2.2.1 变量的命名和使用　　13<br>2.2.2 使用变量时避免命名错误　　14<br>2.2.3 变量是标签　　15<br>2.3 字符串　　16<br>2.3.1 使用方法修改字符串的大小写　　17<br>2.3.3 使用制表符或换行符来添加空白　　18<br>2.3.4 删除空白　　19<br>2.3.5 使用字符串时避免语法错误　　20<br>2.4 数　　21<br>2.4.1 整数　　22<br>2.4.2 浮点数　　22<br>2.4.3 整数和浮点数　　23<br>2.4.4 数中的下划线　　23<br>2.4.5 同时给多个变量赋值　　24<br>2.4.6 常量　　24<br>2.5 注释　　25<br>2.5.1 如何编写注释　　25<br>2.5.2 该编写什么样的注释　　25<br>2.6 Python之禅　　26<br>2.7 小结　　27<br>第3章 列表简介　　28<br>3.1 列表是什么　　28<br>3.1.1 访问列表元素　　29<br>3.1.2 索引从0而不是1开始　　29<br>3.1.3 使用列表中的各个值　　30<br>3.2 修改、添加和删除元素　　31<br>3.2.1 修改列表元素　　31<br>3.2.2 在列表中添加元素　　31<br>3.2.3 从列表中删除元素　　32<br>3.3 组织列表　　36<br>3.3.1 使用方法sort()对列表永久排序　　37<br>3.3.2 使用函数sorted()对列表临时排序　　37<br>3.3.3 倒着打印列表　　38<br>3.3.4 确定列表的长度　　38<br>3.4 使用列表时避免索引错误　　39<br>3.5 小结　　41<br>第4章 操作列表　　42<br>4.1 遍历整个列表　　42<br>4.1.1 深入研究循环　　43<br>4.1.2 在for 循环中执行更多操作　　44<br>4.1.3 在for 循环结束后执行一些操作　　45<br>4.2 避免缩进错误　　45<br>4.2.1 忘记缩进　　46<br>4.2.2 忘记缩进额外的代码行　　46<br>4.2.3 不必要的缩进　　47<br>4.2.4 循环后不必要的缩进　　47<br>4.2.5 遗漏了冒号　　48<br>4.3 创建数值列表　　49<br>4.3.1 使用函数range()　　49<br>4.3.2 使用range()创建数字列表　　50<br>4.3.3 对数字列表执行简单的统计计算　　51<br>4.3.4 列表解析　　52<br>4.4 使用列表的一部分　　53<br>4.4.1 切片　　53<br>4.4.2 遍历切片　　54<br>4.4.3 复制列表　　55<br>4.5 元组　　57<br>4.5.1 定义元组　　57<br>4.5.2 遍历元组中的所有值　　58<br>4.5.3 修改元组变量　　59<br>4.6 设置代码格式　　60<br>4.6.1 格式设置指南　　60<br>4.6.2 缩进　　60<br>4.6.3 行长　　60<br>4.6.4 空行　　61<br>4.6.5 其他格式设置指南　　61<br>4.7 小结　　62<br>第5章 if语句　　63<br>5.1 一个简单示例　　63<br>5.2 条件测试　　64<br>5.2.1 检查是否相等　　64<br>5.2.2 检查是否相等时忽略大小写　　64<br>5.2.3 检查是否不相等　　65<br>5.2.4 数值比较　　66<br>5.2.5 检查多个条件　　66<br>5.2.6 检查特定值是否包含在列表中　　68<br>5.2.8 布尔表达式　　68<br>5.3 if语句　　69<br>5.3.1 简单的if语句　　69<br>5.3.2 if-else语句　　70<br>5.3.3 if-elif-else结构　　71<br>5.3.4 使用多个elif代码块　　72<br>5.3.5 省略else代码块　　73<br>5.3.6 测试多个条件　　73<br>5.4 使用if语句处理列表　　76<br>5.4.1 检查特殊元素　　76<br>5.4.2 确定列表不是空的　　77<br>5.4.3 使用多个列表　　77<br>5.5 设置if语句的格式　　79<br>5.6 小结　　80<br>第6章 字典　　81<br>6.1 一个简单的字典　　81<br>6.2 使用字典　　82<br>6.2.1 访问字典中的值　　82<br>6.2.2 添加键值对　　83<br>6.2.3 先创建一个空字典　　83<br>6.2.4 修改字典中的值　　84<br>6.2.5 删除键值对　　85<br>6.2.6 由类似对象组成的字典　　86<br>6.2.7 使用get()来访问值　　87<br>6.3 遍历字典　　88<br>6.3.1 遍历所有键值对　　88<br>6.3.2 遍历字典中的所有键　　90<br>6.3.3 按特定顺序遍历字典中的所有键　　92<br>6.3.4 遍历字典中的所有值　　92<br>6.4 嵌套　　94<br>6.4.1 字典列表　　94<br>6.4.2 在字典中存储列表　　97<br>6.4.3 在字典中存储字典　　98<br>6.5 小结　　100<br>第7章 用户输入和while循环　　101<br>7.1 函数input()的工作原理　　101<br>7.1.1 编写清晰的程序　　102<br>7.1.2 使用int()来获取数值输入　　102<br>7.1.3 求模运算符　　104<br>7.2 while循环简介　　105<br>7.2.1 使用while循环　　105<br>7.2.2 让用户选择何时退出　　105<br>7.2.3 使用标志　　107<br>7.2.4 使用break退出循环　　108<br>7.2.5 在循环中使用continue　　109<br>7.2.6 避免无限循环　　109<br>7.3 使用while循环处理列表和字典　　111<br>7.3.1 在列表之间移动元素　　111<br>7.3.2 删除为特定值的所有列表元素　　112<br>7.3.3 使用用户输入来填充字典　　112<br>7.4 小结　　114<br>第8章 函数　　115<br>8.1 定义函数　　115<br>8.1.1 向函数传递信息　　116<br>8.1.2 实参和形参　　116<br>8.2 传递实参　　117<br>8.2.1 位置实参　　117<br>8.2.2 关键字实参　　119<br>8.2.3 默认值　　119<br>8.2.4 等效的函数调用　　120<br>8.2.5 避免实参错误　　121<br>8.3 返回值　　122<br>8.3.1 返回简单值　　122<br>8.3.2 让实参变成可选的　　123<br>8.3.3 返回字典　　124<br>8.3.4 结合使用函数和while循环　　125<br>8.4 传递列表　　127<br>8.4.1 在函数中修改列表　　128<br>8.4.2 禁止函数修改列表　　130<br>8.5 传递任意数量的实参　　131<br>8.5.1 结合使用位置实参和任意数量实参　　132<br>8.5.2 使用任意数量的关键字实参　　134<br>8.6.1 导入整个模块　　134<br>8.6.2 导入特定的函数　　135<br>8.6.3 使用as给函数指定别名　　136<br>8.6.4 使用as给模块指定别名　　136<br>8.6.5 导入模块中的所有函数　　137<br>8.7 函数编写指南　　137<br>8.8 小结　　138<br>第9章 类　　140<br>9.1 创建和使用类　　140<br>9.1.1 创建Dog类　　141<br>9.1.2 根据类创建实例　　142<br>9.2 使用类和实例　　144<br>9.2.1 Car类　　145<br>9.2.2 给属性指定默认值　　145<br>9.2.3 修改属性的值　　146<br>9.3 继承　　149<br>9.3.1 子类的方法__init__()　　149<br>9.3.2 给子类定义属性和方法　　151<br>9.3.3 重写父类的方法　　152<br>9.3.4 将实例用作属性　　152<br>9.3.5 模拟实物　　154<br>9.4 导入类　　155<br>9.4.1 导入单个类　　155<br>9.4.2 在一个模块中存储多个类　　157<br>9.4.3 从一个模块中导入多个类　　158<br>9.4.4 导入整个模块　　158<br>9.4.5 导入模块中的所有类　　159<br>9.4.6 在一个模块中导入另一个模块　　159<br>9.4.7 使用别名　　160<br>9.4.8 自定义工作流程　　160<br>9.5 Python标准库　　161<br>9.6 类编码风格　　162<br>9.7 小结　　163<br>第10章 文件和异常　　164<br>10.1 从文件中读取数据　　164<br>10.1.1 读取整个文件　　164<br>10.1.2 文件路径　　166<br>10.1.3 逐行读取　　167<br>10.1.4 创建一个包含文件各行内容的列表　　168<br>10.1.5 使用文件的内容　　168<br>10.1.6 包含一百万位的大型文件　　170<br>10.2 写入文件　　171<br>10.2.1 写入空文件　　171<br>10.2.2 写入多行　　172<br>10.2.3 附加到文件　　173<br>10.3 异常　　174<br>10.3.1 处理ZeroDivisionError异常　　174<br>10.3.2 使用try-except 代码块　　174<br>10.3.3 使用异常避免崩溃　　175<br>10.3.4 else代码块　　176<br>10.3.5 处理FileNotFoundError异常　　177<br>10.3.6 分析文本　　178<br>10.3.7 使用多个文件　　179<br>10.3.8 静默失败　　180<br>10.3.9 决定报告哪些错误　　181<br>10.4 存储数据　　182<br>10.4.1 使用json.dump()和json.load()　　182<br>10.4.2 保存和读取用户生成的数据　　183<br>10.4.3 重构　　185<br>10.5 小结　　187<br>第11章 测试代码　　188<br>11.1 测试函数　　188<br>11.1.1 单元测试和测试用例　　189<br>11.1.2 可通过的测试　　189<br>11.1.3 未通过的测试　　191<br>11.1.4 测试未通过时怎么办　　192<br>11.1.5 添加新测试　　193<br>11.2 测试类　　194<br>11.2.1 各种断言方法　　194<br>11.2.2 一个要测试的类　　195<br>11.2.3 测试AnonymousSurvey类　　197<br>11.2.4 方法setUp()　　198<br>11.3 小结　　200<br>第二部分 项 目<br>项目1 外星人入侵　　202<br>第12章 武装飞船　　203<br>12.1 规划项目　　203<br>12.2 安装Pygame　　204<br>12.3 开始游戏项目　　204<br>12.3.1 创建Pygame窗口及响应用户输入　　204<br>12.3.2 设置背景色　　206<br>12.3.3 创建设置类　　207<br>12.4 添加飞船图像　　208<br>12.4.1 创建Ship类　　209<br>12.4.2 在屏幕上绘制飞船　　210<br>12.5 重构：方法_check_events()和__update_screen()　　211<br>12.5.1 方法_check_events()　　211<br>12.5.2 方法_update_screen()　　212<br>12.6 驾驶飞船　　213<br>12.6.1 响应按键　　213<br>12.6.2 允许持续移动　　214<br>12.6.3 左右移动　　215<br>12.6.4 调整飞船的速度　　216<br>12.6.5 限制飞船的活动范围　　218<br>12.6.6 重构_check_events()　　218<br>12.6.7 按Q键退出　　219<br>12.6.8 在全屏模式下运行游戏　　219<br>12.7 简单回顾　　220<br>12.7.1 alien_invasion.py　　220<br>12.7.2 settings.py　　220<br>12.7.3 ship.py　　220<br>12.8 射击　　221<br>12.8.1 添加子弹设置　　221<br>12.8.2 创建Bullet类　　221<br>12.8.3 将子弹存储到编组中　　223<br>12.8.4 开火　　223<br>12.8.5 删除消失的子弹　　225<br>12.8.6 限制子弹数量　　225<br>12.8.7 创建方法_update_bullets()　　227<br>第13章 外星人来了　　228<br>13.1 项目回顾　　228<br>13.2 创建第一个外星人　　229<br>13.2.1 创建Alien类　　229<br>13.2.2 创建Alien实例　　230<br>13.3 创建一群外星人　　232<br>13.3.1 确定一行可容纳多少个外星人　　232<br>13.3.2 创建一行外星人　　232<br>13.3.3 重构_create_fleet()　　234<br>13.3.4 添加行　　234<br>13.4 让外星人群移动　　237<br>13.4.1 向右移动外星人群　　237<br>13.4.2 创建表示外星人移动方向的设置　　238<br>13.4.3 检查外星人是否撞到了屏幕边缘　　238<br>13.4.4 向下移动外星人群并改变移动方向　　239<br>13.5 射杀外星人　　240<br>13.5.1 检测子弹与外星人的碰撞　　241<br>13.5.3 生成新的外星人群　　242<br>13.5.4 提高子弹的速度　　243<br>13.5.5 重构_update_bullets()　　243<br>13.6 结束游戏　　244<br>13.6.1 检测外星人和飞船碰撞　　244<br>13.6.2 响应外星人和飞船碰撞　　245<br>13.6.3 有外星人到达屏幕底端　　247<br>13.6.4 游戏结束　　248<br>13.7 确定应运行游戏的哪些部分　　248<br>13.8 小结　　249<br>第14章 记分　　250<br>14.1 添加Play按钮　　250<br>14.1.1 创建Button类　　250<br>14.1.2 在屏幕上绘制按钮　　252<br>14.1.3 开始游戏　　253<br>14.1.4 重置游戏　　254<br>14.1.5 将Play按钮切换到非活动状态　　254<br>14.1.6 隐藏鼠标光标　　255<br>14.2 提高等级　　256<br>14.2.1 修改速度设置　　256<br>14.2.2 重置速度　　258<br>14.3 记分　　258<br>14.3.1 显示得分　　259<br>14.3.2 创建记分牌　　260<br>14.3.3 在外星人被消灭时更新得分　　261<br>14.3.4 重置得分　　262<br>14.3.5 将消灭的每个外星人都计入得分　　262<br>14.3.6 提高分数　　263<br>14.3.7 舍入得分　　264<br>14.3.8 最高得分　　265<br>14.3.9 显示等级　　267<br>14.3.10 显示余下的飞船数　　269<br>14.4 小结　　272<br>项目2 数据可视化　　273<br>第15章 生成数据　　274<br>15.1 安装Matplotlib　　274<br>15.2 绘制简单的折线图　　275<br>15.2.1 修改标签文字和线条粗细　　277<br>15.2.3 使用内置样式　　278<br>15.2.4 使用scatter()绘制散点图并设置样式　　279<br>15.2.5 使用scatter()绘制一系列点　　280<br>15.2.6 自动计算数据　　281<br>15.2.7 自定义颜色　　282<br>15.2.8 使用颜色映射　　283<br>15.2.9 自动保存图表　　284<br>15.3 随机漫步　　284<br>15.3.1 创建RandomWalk类　　284<br>15.3.2 选择方向　　285<br>15.3.3 绘制随机漫步图　　286<br>15.3.4 模拟多次随机漫步　　287<br>15.3.5 设置随机漫步图的样式　　288<br>15.4 使用Plotly模拟掷骰子　　292<br>15.4.1 安装Plotly　　292<br>15.4.2 创建Die类　　293<br>15.4.3 掷骰子　　293<br>15.4.4 分析结果　　294<br>15.4.5 绘制直方图　　294<br>15.4.6 同时掷两个骰子　　296<br>15.4.7 同时掷两个面数不同的骰子　　298<br>15.5 小结　　300<br>第16章 下载数据　　301<br>16.1 CSV文件格式　　301<br>16.1.1 分析CSV文件头　　302<br>16.1.2 打印文件头及其位置　　302<br>16.1.3 提取并读取数据　　303<br>16.1.4 绘制温度图表　　304<br>16.1.5 模块datetime　　305<br>16.1.6 在图表中添加日期　　306<br>16.1.7 涵盖更长的时间　　307<br>16.1.8 再绘制一个数据系列　　308<br>16.1.9 给图表区域着色　　309<br>16.1.10 错误检查　　310<br>16.1.11 自己动手下载数据　　313<br>16.2 制作全球地震散点图：JSON格式　　315<br>16.2.2 查看JSON数据　　315<br>16.2.3 创建地震列表　　317<br>16.2.4 提取震级　　317<br>16.2.5 提取位置数据　　318<br>16.2.6 绘制震级散点图　　319<br>16.2.7 另一种指定图表数据的方式　　320<br>16.2.8 定制标记的尺寸　　321<br>16.2.9 定制标记的颜色　　322<br>16.2.10 其他渐变　　323<br>16.2.11 添加鼠标指向时显示的文本　　324<br>16.3 小结　　325<br>第17章 使用API　　326<br>17.1 使用Web API　　326<br>17.1.1 Git 和GitHub　　326<br>17.1.2 使用API调用请求数据　　327<br>17.1.3 安装Requests　　327<br>17.1.4 处理API响应　　328<br>17.1.5 处理响应字典　　329<br>17.1.6 概述最受欢迎的仓库　　331<br>17.1.7 监视API的速率限制　　332<br>17.2 使用Plotly可视化仓库　　332<br>17.2.1 改进Plotly图表　　334<br>17.2.2 添加自定义工具提示　　336<br>17.2.3 在图表中添加可单击的链接　　337<br>17.2.4 深入了解Plotly和GitHub API　　338<br>17.3 Hacker News API　　338<br>17.4 小结　　341<br>项目3 Web 应用程序　　342<br>第18章 从Django 入手　　343<br>18.1 建立项目　　343<br>18.1.1 制定规范　　343<br>18.1.2 建立虚拟环境　　344<br>18.1.3 激活虚拟环境　　344<br>18.1.4 安装Django　　345<br>18.1.5 在Django中创建项目　　345<br>18.1.6 创建数据库　　346<br>18.1.7 查看项目　　346<br>18.2 创建应用程序　　348<br>18.2.1 定义模型　　348<br>18.2.2 激活模型　　349<br>18.2.3 Django管理网站　　351<br>18.2.4 定义模型Entry　　353<br>18.2.5 迁移模型Entry　　354<br>18.2.6 向管理网站注册Entry　　354<br>18.2.7 Django shell　　355<br>18.3 创建页面：学习笔记主页　　357<br>18.3.1 映射URL　　358<br>18.3.2 编写视图　　359<br>18.3.3 编写模板　　360<br>18.4 创建其他页面　　361<br>18.4.1 模板继承　　361<br>18.4.2 显示所有主题的页面　　363<br>18.4.3 显示特定主题的页面　　366<br>18.5 小结　　369<br>第19章 用户账户　　370<br>19.1 让用户输入数据　　370<br>19.1.1 添加新主题　　370<br>19.1.2 添加新条目　　374<br>19.1.3 编辑条目　　378<br>19.2 创建用户账户　　381<br>19.2.1 应用程序users　　381<br>19.2.2 将users添加到settings.py 中　　381<br>19.2.3 包含users的URL　　382<br>19.2.4 登录页面　　382<br>19.2.5 注销　　384<br>19.2.6 注册页面　　386<br>19.3 让用户拥有自己的数据　　388<br>19.3.1 使用@login_required限制访问　　388<br>19.3.2 将数据关联到用户　　390<br>19.3.3 只允许用户访问自己的主题　　393<br>19.3.4 保护用户的主题　　393<br>19.3.5 保护页面edit_entry　　394<br>19.3.6 将新主题关联到当前用户　　396<br>第20章 设置应用程序的样式并部署　　397<br>20.1.1 应用程序django-bootstrap4　　398<br>20.1.3 修改base.html　　399<br>20.1.4 使用jumbotron设置主页的样式　　403<br>20.1.5 设置登录页面的样式　　404<br>20.1.6 设置显示所有主题的页面的样式　　405<br>20.1.7 设置显示单个主题的页面中的条目样式　　406<br>20.2 部署“学习笔记”　　407<br>20.2.1 建立Heroku账户　　408<br>20.2.2 安装Heroku CLI　　408<br>20.2.3 安装必要的包　　408<br>20.2.4 创建文件requirements.txt　　409<br>20.2.6 为部署到Heroku而修改settings.py　　410<br>20.2.7 创建启动进程的Procfile　　410<br>20.2.8 使用Git 跟踪项目文件　　410<br>20.2.9 推送到Heroku　　412<br>20.2.10 在Heroku上建立数据库　　414<br>20.2.12 确保项目的安全　　416<br>20.2.13 提交并推送修改　　416<br>20.2.14 在Heroku 上设置环境变量　　417<br>20.2.15 创建自定义错误页面　　418<br>20.2.16 继续开发　　420<br>20.2.17 设置SECRET_KEY　　421<br>20.2.18 将项目从Heroku删除　　421<br>20.3 小结　　422<br>附录A 安装与故障排除　　423<br>附录B 文本编辑器与IDE　　428<br>附录C 寻求帮助　　432<br>附录D 使用Git 进行版本控制　　436<br>后记　　445</p><h3 id="Python编程：从入门到实践-PDF-下载地址"><a href="#Python编程：从入门到实践-PDF-下载地址" class="headerlink" title="Python编程：从入门到实践 PDF 下载地址:"></a>Python编程：从入门到实践 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Y3kieRXl42PGLymLpxszAw?pwd=k4fy">https://pan.baidu.com/s/1Y3kieRXl42PGLymLpxszAw?pwd=k4fy</a> </p><p>提取码：k4fy</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python高性能编程》</title>
      <link href="/2023/05/19/Python%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/19/Python%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/EHSJKJIKVBS3BNBQJNOVZB066ZN13RBX.png" alt="《Python高性能编程》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书共有12章，围绕如何进行代码优化和加快实际应用的运行速度进行详细讲解。本书主要包含以下主题：计算机内部结构的背景知识、列表和元组、字典和集合、迭代器和生成器、矩阵和矢量计算、并发、集群和工作队列等。最后，通过一系列真实案例展现了在应用场景中需要注意的问题。</p><p>本书适合初级和中级Python程序员、有一定Python语言基础想要得到进阶和提高的读者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Micha Gorelick在bitly公司从事与数据打交道的工作，并负责建立</p><p>了快速前进实验室（Fast Forward Labs），研究从机器学习到高性</p><p>能流算法领域的问题。</p><p>Ian Ozsvald是ModelInsight.io的数据科学家和教师，有着超过十</p><p>年的Python经验。他在PyCon和PyData会议上教授Python编程，</p><p>这几年一直在英国从事关于数据科学和高性能计算方面的咨询工</p><p>作。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 理解高性能Python 1<br>1.1 基本的计算机系统 1<br>1.1.1 计算单元 2<br>1.1.2 存储单元 5<br>1.1.3 通信层 6<br>1.2 将基本的元素组装到一起 8<br>1.3 为什么使用Python 12<br>第2章 通过性能分析找到瓶颈 15<br>2.1 高效地分析性能 16<br>2.2 Julia集合的介绍 17<br>2.3 计算完整的Julia集合 20<br>2.4 计时的简单方法——打印和修饰 24<br>2.5 用UNIX的time命令进行简单的计时 27<br>2.6 使用cProfile模块 28<br>2.7 用runsnakerun对cProfile的输出进行可视化 33<br>2.8 用line_profiler进行逐行分析 34<br>2.9 用memory_profiler诊断内存的用量 39<br>2.10 用heapy调查堆上的对象 45<br>2.11 用dowser实时画出变量的实例 47<br>2.12 用dis模块检查CPython字节码 49<br>2.13 在优化期间进行单元测试保持代码的正确性 53<br>2.14 确保性能分析成功的策略 56<br>2.15 小结 57<br>第3章 列表和元组 58<br>3.1 一个更有效的搜索 61<br>3.2 列表和元组 63<br>3.2.1 动态数组：列表 64<br>3.2.2 静态数组：元组 67<br>3.3 小结 68<br>第4章 字典和集合 69<br>4.1 字典和集合如何工作 72<br>4.1.1 插入和获取 73<br>4.1.2 删除 76<br>4.1.3 改变大小 76<br>4.1.4 散列函数和熵 76<br>4.2 字典和命名空间 80<br>4.3 小结 83<br>第5章 迭代器和生成器 84<br>5.1 无穷数列的迭代器 87<br>5.2 生成器的延迟估值 89<br>5.3 小结 93<br>第6章 矩阵和矢量计算 94<br>6.1 问题介绍 95<br>6.2 Python列表还不够吗 99<br>6.3 内存碎片 103<br>6.3.1 理解perf 105<br>6.3.2 根据perf输出做出抉择 106<br>6.3.3 使用numpy 107<br>6.4 用numpy解决扩散问题 110<br>6.4.1 内存分配和就地操作 113<br>6.4.2 选择优化点：找到需要被修正的地方 116<br>6.5 numexpr：让就地操作更快更简单 120<br>6.6 告诫故事：验证你的“优化”（scipy） 121<br>6.7 小结 123<br>第7章 编译成C 126<br>7.1 可能获得哪种类型的速度提升 127<br>7.2 JIT和AOT编译器的对比 129<br>7.3 为什么类型检查有助代码更快运行 129<br>7.4 使用C编译器 130<br>7.5 复习Julia集的例子 131<br>7.6 Cython 131<br>7.6.1 使用Cython编译纯Python版本 132<br>7.6.2 Cython注解来分析代码块 134<br>7.6.3 增加一些类型注解 136<br>7.7 Shed Skin 140<br>7.7.1 构建扩展模块 141<br>7.7.2 内存拷贝的开销 144<br>7.8 Cython和numpy 144<br>7.9 Numba 148<br>7.10 Pythran 149<br>7.11 PyPy 151<br>7.11.1 垃圾收集的差异 152<br>7.11.2 运行PyPy并安装模块 152<br>7.12 什么时候使用每种工具 154<br>7.12.1 其他即将出现的项目 155<br>7.12.2 一个图像处理单元（GPU）的注意点 156<br>7.12.3 一个对未来编译器项目的展望 157<br>7.13 外部函数接口 157<br>7.13.1 ctypes 158<br>7.13.2 cffi 160<br>7.13.3 f2py 163<br>7.13.4 CPython模块 166<br>7.14 小结 170<br>第8章 并发 171<br>8.1 异步编程介绍 172<br>8.2 串行爬虫 175<br>8.3 gevent 177<br>8.4 tornado 182<br>8.5 AsyncIO 185<br>8.6 数据库的例子 188<br>8.7 小结 191<br>第9章 multiprocessing模块 193<br>9.1 multiprocessing模块综述 196<br>9.2 使用蒙特卡罗方法来估算Pi 198<br>9.3 使用多进程和多线程来估算Pi 199<br>9.3.1 使用Python对象 200<br>9.3.2 并行系统中的随机数 207<br>9.3.3 使用numpy 207<br>9.4 寻找素数 210<br>9.5 使用进程间通信来验证素数 221<br>9.5.1 串行解决方案 225<br>9.5.2 Naïve Pool解决方案 225<br>9.5.3 Less Naïve Pool解决方案 226<br>9.5.4 使用Manager.Value作为一个标记 227<br>9.5.5 使用Redis作为一个标记 229<br>9.5.6 使用RawValue作为一个标记 232<br>9.5.7 使用mmap作为一个标记 232<br>9.5.8 使用mmap作为一个标记的终极效果 234<br>9.6 用multiprocessing来共享numpy数据 236<br>9.7 同步文件和变量访问 243<br>9.7.1 文件锁 243<br>9.7.2 给Value加锁 247<br>9.8 小结 249<br>第10章 集群和工作队列 251<br>10.1 集群的益处 252<br>10.2 集群的缺陷 253<br>10.2.1 糟糕的集群升级策略造成华尔街损失4.62亿美元 254<br>10.2.2 Skype的24小时全球中断 255<br>10.3 通用的集群设计 255<br>10.4 怎样启动一个集群化的解决方案 256<br>10.5 使用集群时避免痛苦的方法 257<br>10.6 三个集群化解决方案 258<br>10.6.1 为简单的本地集群使用Parallel Python模块 259<br>10.6.2 使用IPython Parallel来支持研究 260<br>10.7 为鲁棒生产集群的NSQ 265<br>10.7.1 队列 265<br>10.7.2 发布者&#x2F;订阅者 266<br>10.7.3 分布式素数计算器 268<br>10.8 看一下其他的集群化工具 271<br>10.9 小结 272<br>第11章 使用更少的RAM 273<br>11.1 基础类型的对象开销高 274<br>11.2 理解集合中的RAM使用 278<br>11.3 字节和Unicode的对比 280<br>11.4 高效地在RAM中存储许多文本 281<br>11.5 使用更少RAM的窍门 290<br>11.6 概率数据结构 291<br>11.6.1 使用1字节的Morris计数器来做近似计数 292<br>11.6.2 K最小值 295<br>11.6.3 布隆过滤器 298<br>11.6.4 LogLog计数器 303<br>11.6.5 真实世界的例子 307<br>第12章 现场教训 311<br>12.1 自适应实验室（Adaptive Lab）的社交媒体分析（SoMA） 311<br>12.1.1 自适应实验室（Adaptive Lab）使用的Python 312<br>12.1.2 SoMA的设计 312<br>12.1.3 我们的开发方法论 313<br>12.1.4 维护SoMA 313<br>12.1.5 对工程师同行的建议 313<br>12.2 使用RadimRehurek.com让深度学习飞翔 314<br>12.2.1 最佳时机 314<br>12.2.2 优化方面的教训 316<br>12.2.3 总结 318<br>12.3 在Lyst.com的大规模产品化的机器学习 318<br>12.3.1 Python在Lyst的地位 319<br>12.3.2 集群设计 319<br>12.3.3 在快速前进的初创公司中做代码评估 319<br>12.3.4 构建推荐引擎 319<br>12.3.5 报告和监控 320<br>12.3.6 一些建议 320<br>12.4 在Smesh的大规模社交媒体分析 321<br>12.4.1 Python在Smesh中的角色 321<br>12.4.2 平台 321<br>12.4.3 高性能的实时字符串匹配 322<br>12.4.4 报告、监控、调试和部署 323<br>12.5 PyPy促成了成功的Web和数据处理系统 324<br>12.5.1 先决条件 325<br>12.5.2 数据库 325<br>12.5.3 Web应用 326<br>12.5.4 OCR和翻译 326<br>12.5.5 任务分发和工作者 327<br>12.5.6 结论 327<br>12.6 在Lanyrd.com中的任务队列 327<br>12.6.1 Python在Lanyrd中的角色 328<br>12.6.2 使任务队列变高性能 328<br>12.6.3 报告、监控、调试和部署 328<br>12.6.4 对开发者同行的建议 329</p><h3 id="Python高性能编程-PDF-下载地址"><a href="#Python高性能编程-PDF-下载地址" class="headerlink" title="Python高性能编程 PDF 下载地址:"></a>Python高性能编程 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1KEKmLyxrB3v1utpKL8l2BQ?pwd=tjsm">https://pan.baidu.com/s/1KEKmLyxrB3v1utpKL8l2BQ?pwd=tjsm</a> </p><p>提取码: tjsm </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站所有文档密码</title>
      <link href="//mima/"/>
      <url>//mima/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">  <script id="hbeData" type="hbeData" data-hmacdigest="8db921aceeece298fa0ee0c99b8d3229beacb72c92e02fe4c1e252f461de7186">7c351404e46fa1c7280678d51bf9554c54ebb642ef2fdc7f9d2e4e83b89517e84c2b4fa42deb4a15a5e466b16087a1cb77ef0bc6c5672c6fa7950d637c05b9f18ee4bb8c88dc6442955d25749c1de471a0aacf3a752a169658acd879372ae5a669d756844de2c7c154cc10a9038bf4f72217f859aeab3eaffbd4379fa0d1b1fd324da80ab45781acb4f43cd8f467c2aa223ab9b684cc7ea3313a51551eb5b97debd6d71e067781a937932c4ac84c69a4e307af4c80ba5a1a768ed2e3be20e59d3c684778afe7a20d5f0eafae7338aa9b16557b54c07be3cea4f2ee8d5690a128e9e5aedf5c4fe18f249e2500953adf8bb6777996ea50c338fb04d4e2661aa8f7798536c6cc5bedc6b8ea654bc1ff6aead4d0775a8dfb00c39d1a39668187b3c13d6259d800878d07d3a3e81547653401df1c05b1b0c84fb84c6f7d5ee5778b0ee4895602215ca19f8e46f1142bb607d0ab5c2fc1e6861d086da9eca8f72011d65bbae25bd7d57ac243548014f56aabea40c4133db7893eb69dc67faffe84ca0669108db026bdb7766221fb8c4d1a477d4ba99fa188741adb17f05896200f41f31a049104e53c40d1cdcbe80b04ec70b802413a48b31d317ecaf6cd7b9a2a8b894ef70619db14193b21aa9e4f12b8a09195fa8327e64261539f58030f3983d068c98c43fb9fb1f3a489a9c937fa40a0b706f7a861a2aa9e29cfc5a5ca9434a25da38a7e6455bd0be779aa0637930737bf3bd62a5d67d4c81ee2750c8d00426cce0dc134ad106059ae742b8da21864298d4369dbd6e15c7eba1ccd398b264a653206f591d9987da0ad189727fd5b6c3636d3577c424bf58ed3a317148fa95e5e9aca0309c1a12d6b2eb42066d7494b3c54a55d2514939eb08773d890152c8d7a79076c9f566d2fbe2413eecd912bd26e92b4ba6ccbd988757fea94f2db39202d91607c4079e5cccead49d816606bf109d696790e9854abaf34fcb2d24bdbc921c30dbb0604615b63e4392cebbbd271be5e3fff1654ec45ca81e4f390762882245fbe09adb42362474bb6d336ad0ade506b429dd52409dba3999059b24b05c77290ce41568ca886eccb6c7f604d5261d005f2fea5a00c33dcfe002becdf9bda7adf88be3a8350e23a304ba1165d0ea9fa1bf9008a317cb879794a0f61764fcda6a68fe2218ebda838a6242c2fc91409a93f1d0925c8258e752026682ab2c9efcf376ef38c60699c1417e4150ebcc540285661f43f10520c23128aa3de1b9aabfae3bd2a399539567909ac11b09adab08ae744cd9ef2831e3b39a9cb6355b1b9981500f0433b29489740b775c3859f64d1472a0fefebee360eb20657321c77911976a6990d42e3c2f68114121ac8fbf39be5175ebeeb001a8ed72a9fcd1d901d213ce56e05fefc7f846516092b115f7fb4ca471896a7553ca2fd86923ff7381703e5af202d68117a603a830642b3d228d8d769e6dcf2bb96450d83e993da403ea330b26faf1df65e5e140d0d5fc6973491cd91d0b2da53c631ae501c3a19b5a94a1723204d1755e3616b4d8e3e4a87722e87cd73880d48d14cd515ddaa54bf797de4cef3b39458600c08cb1f297c146f986740cb6c937d81391ef600cb84e57382c78c563acd2d1703d74341f65d1e2f34f86abf93b566acfdd09a1f45611289d4ef66373882e75780ac555f6d1b18bc978f29c7005b7e14671a67abd408b9149eac26befbdc182fa1626ae7349ae6ee3858d3371e21cc5d3c75614b3245bed02bab7c19de59f5c93987471d9628c509516aa3e15bbd3fb7de6c8d9dbc0bebf70d92b69205e2721bbd0d520177c3245fc62a5eeee2e04f9ad967149bf0888d4104c8428b5a33357cbf6ade56afe98e6ff4451d9d4a18ee4ba40a90b887f1bf00b3b12b6f124e908a7ab2a751665570d88a8f8bbb8c94159643b896e23ffa24542b4ffa576387f30e791b58dc61aa5711c74d37a667bcf8dcc3a36cfbb08b3135aea050fcc854d2eaab35941f85164d8c3fd9461130ea4639ddc88b5e41144d319447fc32b1775ef4a73bf1614e4c73233ad4575849ccad5f03f58d5a3ddcefd516695517f03e898737ac02abb21236f78688450f30ddd0339ee8f65e7c63df1ebefbf53904c9b624e185e22242f7941fb71028d62e44dab5068af8af4ae14c8ba2226eb084e4c1eb550e3547dd666824f2884c7a725d72f2e8dde649d24bbc382eccfae035c953936eba6650c79ced5e70afb93b1e10b1ddd64017ef419046bd05785caf1c84c2232c325c21dbcba87defd4ea6cc58683b8a030bddf935bcb8e4d0c22b43cf0b4f42d6a1e4c6f3372e1185a05e3f82bff3ca98538aa42203ee0abf8b977f547cc4fec7bbd86aaa4cbafe15e4ec33bb2482f015717a0ec7f4b9f376a36a83ff2925e492598a705e74ed6a0678e73b5141dfd51811e56a877d59f934daf9b842f947d64f39510fed315af39446a0fc4ce0e3ed78036b8d0b44543867992bf1782727659cfaaf83890f15a84eaa63c184bd1dc89ff5c0a27b7e86c8a1ed806d6f188a117b9f46d9ace1ef33efce69fe85bba37f7dae34ed230757b66944c24c5e8e24d35a5893845aa1cba0d8df2dd803197535e3379f57ba70eb6b1c388d47d0d6cc0ffda70e7278845724db5134f70005fa40e541bbe8bbc6324d5aa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 此文章需要要密码才可以查看.">您好, 此文章需要要密码才可以查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> PDF密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《pytest测试实战》</title>
      <link href="/2023/05/19/pytest%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/19/pytest%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/6E7FFAC4BE6AA9069DB81181D116D110.png" alt="《pytest测试实战》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>pytest是动态编程语言Python专用的测试框架，它具有易于上手、功能强大、第三方插件丰富、效率高、可扩展性好、兼容性强等特点。《pytest测试实战》深入浅出地讲解了pytest的使用方法，尤其是具有特色的fixture的用法。作者通过丰富的测试实例，手把手教读者编写简洁、易于维护的测试代码和插件，让你轻松掌握这个业界最受欢迎的Python测试工具。</p><p>第1章介绍pytest的安装，同时会介绍Tasks项目的数据结构部分（名为Task的namedtuple），并用它作为测试示例。我们会学习如何指定测试文件运行，以及pytest常用的命令行命令，包括重新运行失败测试、遇到失败即停止所有测试、控制堆栈跟踪、控制日志输出，等等。</p><p>第2章将使用pip在本地安装Tasks项目，学习在Python项目中如何组织测试目录，这样才能针对实际项目编写测试用例。这一章的所有示例都依赖外部程序，包括数据库写入。</p><p>第2章的重点是测试函数，你将学习在pytest中高效使用断言语句。这一章还会讲解marker标记功能的用法，marker标记可以将测试进行归类或分组，方便一起运行，也可以将某些测试标记为skip（跳过不执行），marker标记还可以告诉pytest我们知道某些测试是一定会失败的。如果希望运行指定的测试子集，除了使用marker，还可以将测试代码组织成测试目录、测试模块、测试类，然后运行。</p><p>并非所有的测试代码都要放到测试函数中。第3章介绍如何将测试数据、启动逻辑、销毁逻辑放入fixture（pytest定义的一种测试脚手架）。设置系统（或子系统、系统单元）是软件测试的重要环节，第3章将介绍用一个简单的fixture完成这方面的工作（包括对数据库进行初始化，写入数据以备测试之用）。Fixture模块的功能非常强大，你可以利用它简化测试代码，从而提高代码的可读性和可维护性。Fixture像测试函数一样，也有参数。利用参数，你只需要编写一份代码，就可以针对TinyDB和MongoDB（或其他Tasks项目支持的数据库）开展测试。</p><p>第4章介绍pytest内置的fixture以满足测试中常见的一些需求，包括生成和销毁临时目录、截取输出流（通过日志判定结果）、使用monkey patch、检查是否发出警告，等等。</p><p>第5章讲解如何在pytest中添加命令行选项，如何改进打印输出，如何打包分发自己编写的插件，如何共享定制化的pytest（包括fixture）。这一章开发的插件可以改善Tasks项目测试失败时的输出呈现方式。你还将学习测试自己的测试插件（元测试）。读完这一章，想必你已经等不及编写自己的插件了。附录C收集了一些热门的社区插件，可供参考。</p><p>第6章讲解通过pytest.ini文件修改默认配置，自定义pytest的运行方式。pytest.ini文件可以存放某些命令选项，从而减少你重复输入命令的次数；利用它还可以指定pytest忽略某些测试目录，或者指定pytest的最低版本，等等。使用tox.ini和setup.cfg文件也可以实现同样的功能。</p><p>第7章（最后一章）介绍pytest与其他工具的结合使用。我们将借助tox让Tasks项目在多个Python版本上运行；学习如何测试Tasks项目的CLI部分，而不必mock系统的其余部分；借助coverage.py检查Tasks项目代码块的测试覆盖情况；通过Jenkins发起测试并实时显示结果。最后，还会学习如何让pytest运行基于unittest的测试用例，以及把pytest的fixture共享给unittest的测试用例使用。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Brian Okken是一位有二十多年工作经验的软件测试工程师，他业余时间录制了Test &amp; Code和Python Bytes两个播客。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>第1章 pytest入门 1<br>1.1 资源获取 4<br>1.2 运行Pytest 5<br>1.3 运行单个测试用例 10<br>1.4 使用命令行选项 10<br>–collect-only选项 11<br>-k选项 11<br>-m选项 12<br>-x选项 13<br>–maxfail&#x3D;num 15<br>-s与–capture&#x3D;method 16<br>–lf（–last-failed）选项 16<br>–ff（–failed-first）选项 17<br>-v（–verbose）选项 17<br>-q（–quiet）选项 18<br>-l（–showlocals）选项 19<br>–tb&#x3D;style选项 20<br>–duration&#x3D;N选项 21<br>–version选项 22<br>-h（–help）选项 23<br>1.5 练习 24<br>1.6 预告 25<br>第2章 编写测试函数 27<br>2.1 测试示例程序 27<br>本地安装Tasks项目程序包 30<br>2.2 使用assert声明 32<br>2.3 预期异常 35<br>2.4 测试函数的标记 36<br>完善冒烟测试 38<br>2.5 跳过测试 40<br>2.6 标记预期会失败的测试 43<br>2.7 运行测试子集 45<br>单个目录 45<br>单个测试文件&#x2F;模块 46<br>单个测试函数 47<br>单个测试类 47<br>单个测试类中的测试方法 48<br>用测试名划分测试集合 48<br>2.8 参数化测试 49<br>2.9 练习 56<br>2.10 预告 57<br>第3章 pytest Fixture 59<br>3.1 通过conftest.py共享fixture 60<br>3.2 使用fixture执行配置及销毁逻辑 61<br>3.3 使用–setup-show回溯fixture的执行过程 63<br>3.4 使用fixture传递测试数据 64<br>3.5 使用多个fixture 66<br>3.6 指定fixture作用范围 68<br>修改Tasks项目的fixture作用范围 70<br>3.7 使用usefixtures指定fixture 73<br>3.8 为常用fixture添加autouse选项 74<br>3.9 为fixture重命名 75<br>3.10 Fixture的参数化 77<br>3.11 参数化Tasks项目中的fixture 80<br>3.12 练习 83<br>3.13 预告 83<br>第4章 内置Fixture 85<br>4.1 使用tmpdir和tmpdir_factory 86<br>在其他作用范围内使用临时目录 88<br>4.2 使用pytestconfig 90<br>4.3 使用cache 92<br>4.4 使用capsys 100<br>4.5 使用monkeypatch 102<br>4.6 使用doctest_namespace 106<br>4.7 使用recwarn 109<br>4.8 练习 110<br>4.9 预告 111<br>第5章 插件 113<br>5.1 寻找插件 114<br>5.2 安装插件 114<br>从PyPI安装 114<br>从PyPI安装指定版本 115<br>从.tar.gz或.whl文件安装 115<br>从本地目录安装 115<br>从Git存储仓库安装 116<br>5.3 编写自己的插件 116<br>5.4 创建可安装插件 121<br>5.5 测试插件 125<br>5.6 创建发布包 129<br>通过共享目录分发插件 130<br>通过PyPI发布插件 130<br>5.7 练习 131<br>5.8 预告 131<br>第6章 配置 133<br>6.1 理解pytest的配置文件 133<br>用pytest –help查看ini文件选项 135<br>插件可以添加ini文件选项 135<br>6.2 更改默认命令行选项 136<br>6.3 注册标记来防范拼写错误 136<br>6.4 指定pytest的最低版本号 138<br>6.5 指定pytest忽略某些目录 138<br>6.6 指定测试目录 139<br>6.7 更改测试搜索的规则 141<br>6.8 禁用XPASS 142<br>6.9 避免文件名冲突 143<br>6.10 练习 145<br>6.11 预告 145<br>第7章 pytest与其他工具的搭配使用 147<br>7.1 pdb：调试失败的测试用例 147<br>7.2 coverage.py：判断测试覆盖了多少代码 151<br>7.3 mock：替换部分系统 155<br>7.4 tox：测试多种配置 162<br>7.5 Jenkins CI：让测试自动化 166<br>7.6 unittest：用pytest运行历史遗留测试用例 173<br>7.7 练习 179<br>7.8 预告 180<br>附录A 虚拟环境 181<br>附录B Pip 183<br>附录C 常用插件 187<br>C.1 改变测试流程的插件 187<br>pytest-repeat：重复运行测试 187<br>pytest-xdist：并行运行测试 189<br>pytest-timeout：为测试设置时间限制 190<br>C.2 改善输出效果的插件 191<br>pytest-instafail：查看错误的详细信息 191<br>pytest-sugar：显示色彩和进度条 192<br>pytest-emoji：为测试增添一些乐趣 193<br>pytest-html：为测试生成HTML报告 195<br>C.3 静态分析用的插件 197<br>pytest-pycodestyle和pytest-pep8：Python代码风格检查 197<br>pytest-flake8：更多的风格检查 197<br>C.4 Web开发用的插件 198<br>pytest-selenium：借助浏览器完成自动化测试 198<br>pytest-django：测试Django应用 198<br>pytest-flask：测试Flask应用 199<br>附录D 打包和发布Python项目 201<br>D.1 创建可安装的模块 201<br>D.2 创建可安装的包 203<br>D.3 创建源码发布包和Wheel文件 205<br>D.4 创建可以从PyPI安装的包 209<br>附录E xUnit Fixture 211<br>E.1 xUnit Fixture的语法 211<br>E.2 混合使用pytest Fixture和xUnit Fixture 214<br>E.3 xUnit Fixture的限制 215<br>索引 216</p><h3 id="pytest测试实战-PDF-下载"><a href="#pytest测试实战-PDF-下载" class="headerlink" title="pytest测试实战 PDF 下载"></a>pytest测试实战 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Mg_nwvwOtwIiWakKA2BPJA?pwd=ylqm">https://pan.baidu.com/s/1Mg_nwvwOtwIiWakKA2BPJA?pwd=ylqm</a> </p><p>提取码：ylqm</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> PyTest </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
